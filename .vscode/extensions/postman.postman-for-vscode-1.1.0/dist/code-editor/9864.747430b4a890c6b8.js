"use strict";(self.webpackChunkcode_editor=self.webpackChunkcode_editor||[]).push([[9864],{29864:(e,n,t)=>{t.r(n),t.d(n,{assertTypeDef:()=>s,bufferTypeDef:()=>a,eventsTypeDef:()=>b,globalsTypeDef:()=>r,nodeJsTypeDef:()=>g,pathTypeDef:()=>i,punycodeTypeDef:()=>u,querystringTypeDef:()=>d,streamTypeDef:()=>f,stringDecoderTypeDef:()=>c,timersTypeDef:()=>m,urlTypeDef:()=>l,utilTypeDef:()=>o});const r="// This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build\n/* eslint-disable @typescript-eslint/no-explicit-any, no-var, @typescript-eslint/ban-types, unicorn/text-encoding-identifier-case, unicorn/prefer-number-properties */\ninterface Console {\n  /**\n   * The `console.debug()` function is an alias for {@link console.log()}.\n   */\n  debug(message?: any, ...optionalParams: any[]): void;\n  /**\n   * The {@link console.info()} function is an alias for {@link console.log()}.\n   */\n  info(message?: any, ...optionalParams: any[]): void;\n  /**\n   * Prints to `stdout` with newline.\n   */\n  log(message?: any, ...optionalParams: any[]): void;\n  /**\n   * The {@link console.warn()} function is an alias for {@link console.error()}.\n   */\n  warn(message?: any, ...optionalParams: any[]): void;\n  /**\n   * Prints to `stderr` with newline.\n   */\n  error(message?: any, ...optionalParams: any[]): void;\n  /**\n   * Clears the console.\n   */\n  clear(): void;\n}\n\ninterface Error {\n  stack?: string;\n}\n\n// Declare \"static\" methods in Error\ninterface ErrorConstructor {\n  /** Create .stack property on a target object */\n  captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\n\n  /**\n   * Optional override for formatting stack traces\n   *\n   * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\n   */\n  prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\n\n  stackTraceLimit: number;\n}\n\ninterface SymbolConstructor {\n  readonly observable: symbol;\n}\n\n// Node.js ESNEXT support\ninterface String {\n  /** Removes whitespace from the left end of a string. */\n  trimLeft(): string;\n  /** Removes whitespace from the right end of a string. */\n  trimRight(): string;\n}\n\ninterface ImportMeta {\n  url: string;\n}\n\n/*-----------------------------------------------*\n *                                               *\n *                   GLOBAL                      *\n *                                               *\n ------------------------------------------------*/\ndeclare let process: NodeJS.Process;\ndeclare let global: NodeJS.Global;\ndeclare let console: Console;\n\ndeclare let __filename: string;\ndeclare let __dirname: string;\n\ndeclare function setTimeout(\n  callback: (...args: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout;\ndeclare namespace setTimeout {\n  function __promisify__(ms: number): Promise<void>;\n  function __promisify__<T>(ms: number, value: T): Promise<T>;\n}\ndeclare function clearTimeout(timeoutId: NodeJS.Timeout): void;\ndeclare function setInterval(\n  callback: (...args: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout;\ndeclare function clearInterval(intervalId: NodeJS.Timeout): void;\ndeclare function setImmediate(\n  callback: (...args: any[]) => void,\n  ...args: any[]\n): NodeJS.Immediate;\ndeclare namespace setImmediate {\n  function __promisify__(): Promise<void>;\n  function __promisify__<T>(value: T): Promise<T>;\n}\ndeclare function clearImmediate(immediateId: NodeJS.Immediate): void;\n\ndeclare function queueMicrotask(callback: () => void): void;\n\n// TODO: change to `type NodeRequireFunction = (id: string) => any;` in next mayor version.\ninterface NodeRequireFunction {\n  /* tslint:disable-next-line:callable-types */\n  (id: string): any;\n}\n\ninterface NodeRequire extends NodeRequireFunction {\n  resolve: RequireResolve;\n  cache: any;\n  /**\n   * @deprecated\n   */\n  extensions: NodeExtensions;\n  main: NodeModule | undefined;\n}\n\ninterface RequireResolve {\n  (id: string, options?: { paths?: string[] }): string;\n  paths(request: string): string[] | null;\n}\n\ninterface NodeExtensions {\n  '.js': (m: NodeModule, filename: string) => any;\n  '.json': (m: NodeModule, filename: string) => any;\n  '.node': (m: NodeModule, filename: string) => any;\n  [ext: string]: (m: NodeModule, filename: string) => any;\n}\n\ndeclare let require: NodeRequire;\n\ninterface NodeModule {\n  exports: any;\n  require: NodeRequireFunction;\n  id: string;\n  filename: string;\n  loaded: boolean;\n  parent: NodeModule | null;\n  children: NodeModule[];\n  paths: string[];\n}\n\ndeclare let module: NodeModule;\n\n// Same as module.exports\ndeclare let exports: any;\n\n// Buffer class\ntype BufferEncoding =\n  | 'ascii'\n  | 'utf8'\n  | 'utf-8'\n  | 'utf16le'\n  | 'ucs2'\n  | 'ucs-2'\n  | 'base64'\n  | 'latin1'\n  | 'binary'\n  | 'hex';\n\ninterface Buffer {\n  constructor: typeof Buffer;\n}\n\n/**\n * Raw data is stored in instances of the Buffer class.\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n */\ndeclare class Buffer extends Uint8Array {\n  /**\n   * Allocates a new buffer containing the given {str}.\n   *\n   * @param str String to store in buffer.\n   * @param encoding encoding to use, optional.  Default is 'utf8'\n   * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n   */\n  constructor(str: string, encoding?: BufferEncoding);\n  /**\n   * Allocates a new buffer of {size} octets.\n   *\n   * @param size count of octets to allocate.\n   * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n   */\n  constructor(size: number);\n  /**\n   * Allocates a new buffer containing the given {array} of octets.\n   *\n   * @param array The octets to store.\n   * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n   */\n  constructor(array: Uint8Array);\n  /**\n   * Produces a Buffer backed by the same allocated memory as\n   * the given {ArrayBuffer}/{SharedArrayBuffer}.\n   *\n   *\n   * @param arrayBuffer The ArrayBuffer with which to share memory.\n   * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n   */\n  constructor(arrayBuffer: ArrayBuffer | SharedArrayBuffer);\n  /**\n   * Allocates a new buffer containing the given {array} of octets.\n   *\n   * @param array The octets to store.\n   * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n   */\n  constructor(array: any[]);\n  /**\n   * Copies the passed {buffer} data onto a new {Buffer} instance.\n   *\n   * @param buffer The buffer to copy.\n   * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n   */\n  constructor(buffer: Buffer);\n  /**\n   * When passed a reference to the .buffer property of a TypedArray instance,\n   * the newly created Buffer will share the same allocated memory as the TypedArray.\n   * The optional {byteOffset} and {length} arguments specify a memory range\n   * within the {arrayBuffer} that will be shared by the Buffer.\n   *\n   * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()\n   */\n  static from(\n    arrayBuffer: ArrayBuffer | SharedArrayBuffer,\n    byteOffset?: number,\n    length?: number\n  ): Buffer;\n  /**\n   * Creates a new Buffer using the passed {data}\n   * @param data data to create a new Buffer\n   */\n  static from(data: number[]): Buffer;\n  static from(data: Uint8Array): Buffer;\n  /**\n   * Creates a new Buffer containing the given JavaScript string {str}.\n   * If provided, the {encoding} parameter identifies the character encoding.\n   * If not provided, {encoding} defaults to 'utf8'.\n   */\n  static from(str: string, encoding?: BufferEncoding): Buffer;\n  /**\n   * Creates a new Buffer using the passed {data}\n   * @param values to create a new Buffer\n   */\n  static of(...items: number[]): Buffer;\n  /**\n   * Returns true if {obj} is a Buffer\n   *\n   * @param obj object to test.\n   */\n  static isBuffer(obj: any): obj is Buffer;\n  /**\n   * Returns true if {encoding} is a valid encoding argument.\n   * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n   *\n   * @param encoding string to test.\n   */\n  static isEncoding(encoding: string): encoding is BufferEncoding;\n  /**\n   * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n   * This is not the same as String.prototype.length since that returns the number of characters in a string.\n   *\n   * @param string string to test.\n   * @param encoding encoding used to evaluate (defaults to 'utf8')\n   */\n  static byteLength(\n    string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n    encoding?: BufferEncoding\n  ): number;\n  /**\n   * Returns a buffer which is the result of concatenating all the buffers in the list together.\n   *\n   * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n   * If the list has exactly one item, then the first item of the list is returned.\n   * If the list has more than one item, then a new Buffer is created.\n   *\n   * @param list An array of Buffer objects to concatenate\n   * @param totalLength Total length of the buffers when concatenated.\n   *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n   */\n  static concat(list: Uint8Array[], totalLength?: number): Buffer;\n  /**\n   * The same as buf1.compare(buf2).\n   */\n  static compare(buf1: Uint8Array, buf2: Uint8Array): number;\n  /**\n   * Allocates a new buffer of {size} octets.\n   *\n   * @param size count of octets to allocate.\n   * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n   *    If parameter is omitted, buffer will be filled with zeros.\n   * @param encoding encoding used for call to buf.fill while initalizing\n   */\n  static alloc(\n    size: number,\n    fill?: string | Buffer | number,\n    encoding?: BufferEncoding\n  ): Buffer;\n  /**\n   * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n   * of the newly created Buffer are unknown and may contain sensitive data.\n   *\n   * @param size count of octets to allocate\n   */\n  static allocUnsafe(size: number): Buffer;\n  /**\n   * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n   * of the newly created Buffer are unknown and may contain sensitive data.\n   *\n   * @param size count of octets to allocate\n   */\n  static allocUnsafeSlow(size: number): Buffer;\n  /**\n   * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\n   */\n  static poolSize: number;\n\n  write(string: string, encoding?: BufferEncoding): number;\n  write(string: string, offset: number, encoding?: BufferEncoding): number;\n  write(\n    string: string,\n    offset: number,\n    length: number,\n    encoding?: BufferEncoding\n  ): number;\n  toString(encoding?: string, start?: number, end?: number): string;\n  toJSON(): { type: 'Buffer'; data: number[] };\n  equals(otherBuffer: Uint8Array): boolean;\n  compare(\n    otherBuffer: Uint8Array,\n    targetStart?: number,\n    targetEnd?: number,\n    sourceStart?: number,\n    sourceEnd?: number\n  ): number;\n  copy(\n    targetBuffer: Uint8Array,\n    targetStart?: number,\n    sourceStart?: number,\n    sourceEnd?: number\n  ): number;\n  /**\n   * Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.\n   *\n   * This method is incompatible with `Uint8Array#slice()`, which returns a copy of the original memory.\n   *\n   * @param begin Where the new `Buffer` will start. Default: `0`.\n   * @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.\n   */\n  slice(begin?: number, end?: number): Buffer;\n  /**\n   * Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.\n   *\n   * This method is compatible with `Uint8Array#subarray()`.\n   *\n   * @param begin Where the new `Buffer` will start. Default: `0`.\n   * @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.\n   */\n  subarray(begin?: number, end?: number): Buffer;\n  writeUIntLE(value: number, offset: number, byteLength: number): number;\n  writeUIntBE(value: number, offset: number, byteLength: number): number;\n  writeIntLE(value: number, offset: number, byteLength: number): number;\n  writeIntBE(value: number, offset: number, byteLength: number): number;\n  readUIntLE(offset: number, byteLength: number): number;\n  readUIntBE(offset: number, byteLength: number): number;\n  readIntLE(offset: number, byteLength: number): number;\n  readIntBE(offset: number, byteLength: number): number;\n  readUInt8(offset: number): number;\n  readUInt16LE(offset: number): number;\n  readUInt16BE(offset: number): number;\n  readUInt32LE(offset: number): number;\n  readUInt32BE(offset: number): number;\n  readInt8(offset: number): number;\n  readInt16LE(offset: number): number;\n  readInt16BE(offset: number): number;\n  readInt32LE(offset: number): number;\n  readInt32BE(offset: number): number;\n  readFloatLE(offset: number): number;\n  readFloatBE(offset: number): number;\n  readDoubleLE(offset: number): number;\n  readDoubleBE(offset: number): number;\n  reverse(): this;\n  swap16(): Buffer;\n  swap32(): Buffer;\n  swap64(): Buffer;\n  writeUInt8(value: number, offset: number): number;\n  writeUInt16LE(value: number, offset: number): number;\n  writeUInt16BE(value: number, offset: number): number;\n  writeUInt32LE(value: number, offset: number): number;\n  writeUInt32BE(value: number, offset: number): number;\n  writeInt8(value: number, offset: number): number;\n  writeInt16LE(value: number, offset: number): number;\n  writeInt16BE(value: number, offset: number): number;\n  writeInt32LE(value: number, offset: number): number;\n  writeInt32BE(value: number, offset: number): number;\n  writeFloatLE(value: number, offset: number): number;\n  writeFloatBE(value: number, offset: number): number;\n  writeDoubleLE(value: number, offset: number): number;\n  writeDoubleBE(value: number, offset: number): number;\n\n  fill(\n    value: string | Uint8Array | number,\n    offset?: number,\n    end?: number,\n    encoding?: BufferEncoding\n  ): this;\n\n  indexOf(\n    value: string | number | Uint8Array,\n    byteOffset?: number,\n    encoding?: BufferEncoding\n  ): number;\n  lastIndexOf(\n    value: string | number | Uint8Array,\n    byteOffset?: number,\n    encoding?: BufferEncoding\n  ): number;\n  entries(): IterableIterator<[number, number]>;\n  includes(\n    value: string | number | Buffer,\n    byteOffset?: number,\n    encoding?: BufferEncoding\n  ): boolean;\n  keys(): IterableIterator<number>;\n  values(): IterableIterator<number>;\n}\n\n/*----------------------------------------------*\n *                                               *\n *               GLOBAL INTERFACES               *\n *                                               *\n *-----------------------------------------------*/\ndeclare namespace NodeJS {\n  interface InspectOptions {\n    /**\n     * If set to `true`, getters are going to be\n     * inspected as well. If set to `'get'` only getters without setter are going\n     * to be inspected. If set to `'set'` only getters having a corresponding\n     * setter are going to be inspected. This might cause side effects depending on\n     * the getter function.\n     * @default `false`\n     */\n    getters?: 'get' | 'set' | boolean;\n    showHidden?: boolean;\n    /**\n     * @default 2\n     */\n    depth?: number | null;\n    colors?: boolean;\n    customInspect?: boolean;\n    showProxy?: boolean;\n    maxArrayLength?: number | null;\n    breakLength?: number;\n    /**\n     * Setting this to `false` causes each object key\n     * to be displayed on a new line. It will also add new lines to text that is\n     * longer than `breakLength`. If set to a number, the most `n` inner elements\n     * are united on a single line as long as all properties fit into\n     * `breakLength`. Short array elements are also grouped together. Note that no\n     * text will be reduced below 16 characters, no matter the `breakLength` size.\n     * For more information, see the example below.\n     * @default `true`\n     */\n    compact?: boolean | number;\n    sorted?: boolean | ((a: string, b: string) => number);\n  }\n\n  interface ConsoleConstructorOptions {\n    stdout: WritableStream;\n    stderr?: WritableStream;\n    ignoreErrors?: boolean;\n    colorMode?: boolean | 'auto';\n    inspectOptions?: InspectOptions;\n  }\n\n  interface ConsoleConstructor {\n    prototype: Console;\n    new (\n      stdout: WritableStream,\n      stderr?: WritableStream,\n      ignoreErrors?: boolean\n    ): Console;\n    new (options: ConsoleConstructorOptions): Console;\n  }\n\n  interface CallSite {\n    /**\n     * Value of \"this\"\n     */\n    getThis(): any;\n\n    /**\n     * Type of \"this\" as a string.\n     * This is the name of the function stored in the constructor field of\n     * \"this\", if available.  Otherwise the object's [[Class]] internal\n     * property.\n     */\n    getTypeName(): string | null;\n\n    /**\n     * Current function\n     */\n    getFunction(): Function | undefined;\n\n    /**\n     * Name of the current function, typically its name property.\n     * If a name property is not available an attempt will be made to try\n     * to infer a name from the function's context.\n     */\n    getFunctionName(): string | null;\n\n    /**\n     * Name of the property [of \"this\" or one of its prototypes] that holds\n     * the current function\n     */\n    getMethodName(): string | null;\n\n    /**\n     * Name of the script [if this function was defined in a script]\n     */\n    getFileName(): string | null;\n\n    /**\n     * Current line number [if this function was defined in a script]\n     */\n    getLineNumber(): number | null;\n\n    /**\n     * Current column number [if this function was defined in a script]\n     */\n    getColumnNumber(): number | null;\n\n    /**\n     * A call site object representing the location where eval was called\n     * [if this function was created using a call to eval]\n     */\n    getEvalOrigin(): string | undefined;\n\n    /**\n     * Is this a toplevel invocation, that is, is \"this\" the global object?\n     */\n    isToplevel(): boolean;\n\n    /**\n     * Does this call take place in code defined by a call to eval?\n     */\n    isEval(): boolean;\n\n    /**\n     * Is this call in native V8 code?\n     */\n    isNative(): boolean;\n\n    /**\n     * Is this a constructor call?\n     */\n    isConstructor(): boolean;\n  }\n\n  interface ErrnoException extends Error {\n    errno?: number;\n    code?: string;\n    path?: string;\n    syscall?: string;\n    stack?: string;\n  }\n\n  class EventEmitter {\n    addListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ): this;\n    on(event: string | symbol, listener: (...args: any[]) => void): this;\n    once(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ): this;\n    off(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeAllListeners(event?: string | symbol): this;\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n    listeners(event: string | symbol): Function[];\n    rawListeners(event: string | symbol): Function[];\n    emit(event: string | symbol, ...args: any[]): boolean;\n    listenerCount(type: string | symbol): number;\n    // Added in Node 6...\n    prependListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ): this;\n    prependOnceListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void\n    ): this;\n    eventNames(): Array<string | symbol>;\n  }\n\n  interface ReadableStream extends EventEmitter {\n    readable: boolean;\n    read(size?: number): string | Buffer;\n    setEncoding(encoding: string): this;\n    pause(): this;\n    resume(): this;\n    isPaused(): boolean;\n    pipe<T extends WritableStream>(\n      destination: T,\n      options?: { end?: boolean }\n    ): T;\n    unpipe(destination?: WritableStream): this;\n    unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): void;\n    wrap(oldStream: ReadableStream): this;\n    [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;\n  }\n\n  interface WritableStream extends EventEmitter {\n    writable: boolean;\n    write(\n      buffer: Uint8Array | string,\n      cb?: (err?: Error | null) => void\n    ): boolean;\n    write(\n      str: string,\n      encoding?: string,\n      cb?: (err?: Error | null) => void\n    ): boolean;\n    end(cb?: () => void): void;\n    end(data: string | Uint8Array, cb?: () => void): void;\n    end(str: string, encoding?: string, cb?: () => void): void;\n  }\n\n  interface ReadWriteStream extends ReadableStream, WritableStream {}\n\n  interface Domain extends EventEmitter {\n    run<T>(fn: (...args: any[]) => T, ...args: any[]): T;\n    add(emitter: EventEmitter | Timer): void;\n    remove(emitter: EventEmitter | Timer): void;\n    bind<T extends Function>(cb: T): T;\n    intercept<T extends Function>(cb: T): T;\n\n    addListener(event: string, listener: (...args: any[]) => void): this;\n    on(event: string, listener: (...args: any[]) => void): this;\n    once(event: string, listener: (...args: any[]) => void): this;\n    removeListener(event: string, listener: (...args: any[]) => void): this;\n    removeAllListeners(event?: string): this;\n  }\n\n  interface MemoryUsage {\n    rss: number;\n    heapTotal: number;\n    heapUsed: number;\n    external: number;\n  }\n\n  interface CpuUsage {\n    user: number;\n    system: number;\n  }\n\n  interface ProcessRelease {\n    name: string;\n    sourceUrl?: string;\n    headersUrl?: string;\n    libUrl?: string;\n    lts?: string;\n  }\n\n  interface ProcessVersions {\n    http_parser: string;\n    node: string;\n    v8: string;\n    ares: string;\n    uv: string;\n    zlib: string;\n    modules: string;\n    openssl: string;\n  }\n\n  type Platform =\n    | 'aix'\n    | 'android'\n    | 'darwin'\n    | 'freebsd'\n    | 'linux'\n    | 'openbsd'\n    | 'sunos'\n    | 'win32'\n    | 'cygwin'\n    | 'netbsd';\n\n  type Signals =\n    | 'SIGABRT'\n    | 'SIGALRM'\n    | 'SIGBUS'\n    | 'SIGCHLD'\n    | 'SIGCONT'\n    | 'SIGFPE'\n    | 'SIGHUP'\n    | 'SIGILL'\n    | 'SIGINT'\n    | 'SIGIO'\n    | 'SIGIOT'\n    | 'SIGKILL'\n    | 'SIGPIPE'\n    | 'SIGPOLL'\n    | 'SIGPROF'\n    | 'SIGPWR'\n    | 'SIGQUIT'\n    | 'SIGSEGV'\n    | 'SIGSTKFLT'\n    | 'SIGSTOP'\n    | 'SIGSYS'\n    | 'SIGTERM'\n    | 'SIGTRAP'\n    | 'SIGTSTP'\n    | 'SIGTTIN'\n    | 'SIGTTOU'\n    | 'SIGUNUSED'\n    | 'SIGURG'\n    | 'SIGUSR1'\n    | 'SIGUSR2'\n    | 'SIGVTALRM'\n    | 'SIGWINCH'\n    | 'SIGXCPU'\n    | 'SIGXFSZ'\n    | 'SIGBREAK'\n    | 'SIGLOST'\n    | 'SIGINFO';\n\n  type MultipleResolveType = 'resolve' | 'reject';\n\n  type BeforeExitListener = (code: number) => void;\n  type DisconnectListener = () => void;\n  type ExitListener = (code: number) => void;\n  type RejectionHandledListener = (promise: Promise<any>) => void;\n  type UncaughtExceptionListener = (error: Error) => void;\n  type UnhandledRejectionListener = (\n    reason: {} | null | undefined,\n    promise: Promise<any>\n  ) => void;\n  type WarningListener = (warning: Error) => void;\n  type MessageListener = (message: any, sendHandle: any) => void;\n  type SignalsListener = (signal: Signals) => void;\n  type NewListenerListener = (\n    type: string | symbol,\n    listener: (...args: any[]) => void\n  ) => void;\n  type RemoveListenerListener = (\n    type: string | symbol,\n    listener: (...args: any[]) => void\n  ) => void;\n  type MultipleResolveListener = (\n    type: MultipleResolveType,\n    promise: Promise<any>,\n    value: any\n  ) => void;\n\n  interface Socket extends ReadWriteStream {\n    isTTY?: true;\n  }\n\n  interface ProcessEnv {\n    [key: string]: string | undefined;\n  }\n\n  interface HRTime {\n    (time?: [number, number]): [number, number];\n  }\n\n  interface ProcessReport {\n    /**\n     * Directory where the report is written.\n     * working directory of the Node.js process.\n     * @default '' indicating that reports are written to the current\n     */\n    directory: string;\n\n    /**\n     * Filename where the report is written.\n     * The default value is the empty string.\n     * @default '' the output filename will be comprised of a timestamp,\n     * PID, and sequence number.\n     */\n    filename: string;\n\n    /**\n     * Returns a JSON-formatted diagnostic report for the running process.\n     * The report's JavaScript stack trace is taken from err, if present.\n     */\n    getReport(err?: Error): string;\n\n    /**\n     * If true, a diagnostic report is generated on fatal errors,\n     * such as out of memory errors or failed C++ assertions.\n     * @default false\n     */\n    reportOnFatalError: boolean;\n\n    /**\n     * If true, a diagnostic report is generated when the process\n     * receives the signal specified by process.report.signal.\n     * @defaul false\n     */\n    reportOnSignal: boolean;\n\n    /**\n     * If true, a diagnostic report is generated on uncaught exception.\n     * @default false\n     */\n    reportOnUncaughtException: boolean;\n\n    /**\n     * The signal used to trigger the creation of a diagnostic report.\n     * @default 'SIGUSR2'\n     */\n    signal: Signals;\n\n    /**\n     * Writes a diagnostic report to a file. If filename is not provided, the default filename\n     * includes the date, time, PID, and a sequence number.\n     * The report's JavaScript stack trace is taken from err, if present.\n     *\n     * @param fileName Name of the file where the report is written.\n     * This should be a relative path, that will be appended to the directory specified in\n     * `process.report.directory`, or the current working directory of the Node.js process,\n     * if unspecified.\n     * @param error A custom error used for reporting the JavaScript stack.\n     * @return Filename of the generated report.\n     */\n    writeReport(fileName?: string): string;\n    writeReport(error?: Error): string;\n    writeReport(fileName?: string, err?: Error): string;\n  }\n\n  interface ResourceUsage {\n    fsRead: number;\n    fsWrite: number;\n    involuntaryContextSwitches: number;\n    ipcReceived: number;\n    ipcSent: number;\n    majorPageFault: number;\n    maxRSS: number;\n    minorPageFault: number;\n    sharedMemorySize: number;\n    signalsCount: number;\n    swappedOut: number;\n    systemCPUTime: number;\n    unsharedDataSize: number;\n    unsharedStackSize: number;\n    userCPUTime: number;\n    voluntaryContextSwitches: number;\n  }\n\n  interface Process extends EventEmitter {\n    /**\n     * Can also be a tty.WriteStream, not typed due to limitation.s\n     */\n    stdout: WriteStream;\n    /**\n     * Can also be a tty.WriteStream, not typed due to limitation.s\n     */\n    stderr: WriteStream;\n    stdin: ReadStream;\n    openStdin(): Socket;\n    argv: string[];\n    argv0: string;\n    execArgv: string[];\n    execPath: string;\n    abort(): void;\n    chdir(directory: string): void;\n    cwd(): string;\n    debugPort: number;\n    emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n    env: ProcessEnv;\n    exit(code?: number): never;\n    exitCode?: number;\n    getgid(): number;\n    setgid(id: number | string): void;\n    getuid(): number;\n    setuid(id: number | string): void;\n    geteuid(): number;\n    seteuid(id: number | string): void;\n    getegid(): number;\n    setegid(id: number | string): void;\n    getgroups(): number[];\n    setgroups(groups: Array<string | number>): void;\n    setUncaughtExceptionCaptureCallback(\n      cb: ((err: Error) => void) | null\n    ): void;\n    hasUncaughtExceptionCaptureCallback(): boolean;\n    version: string;\n    versions: ProcessVersions;\n    config: {\n      target_defaults: {\n        cflags: any[];\n        default_configuration: string;\n        defines: string[];\n        include_dirs: string[];\n        libraries: string[];\n      };\n      variables: {\n        clang: number;\n        host_arch: string;\n        node_install_npm: boolean;\n        node_install_waf: boolean;\n        node_prefix: string;\n        node_shared_openssl: boolean;\n        node_shared_v8: boolean;\n        node_shared_zlib: boolean;\n        node_use_dtrace: boolean;\n        node_use_etw: boolean;\n        node_use_openssl: boolean;\n        target_arch: string;\n        v8_no_strict_aliasing: number;\n        v8_use_snapshot: boolean;\n        visibility: string;\n      };\n    };\n    kill(pid: number, signal?: string | number): void;\n    pid: number;\n    ppid: number;\n    title: string;\n    arch: string;\n    platform: Platform;\n    mainModule?: NodeModule;\n    memoryUsage(): MemoryUsage;\n    cpuUsage(previousValue?: CpuUsage): CpuUsage;\n    nextTick(callback: Function, ...args: any[]): void;\n    release: ProcessRelease;\n    features: {\n      inspector: boolean;\n      debug: boolean;\n      uv: boolean;\n      ipv6: boolean;\n      tls_alpn: boolean;\n      tls_sni: boolean;\n      tls_ocsp: boolean;\n      tls: boolean;\n    };\n    /**\n     * Can only be set if not in worker thread.\n     */\n    umask(mask?: number): number;\n    uptime(): number;\n    hrtime: HRTime;\n    domain: Domain;\n\n    // Worker\n    send?(\n      message: any,\n      sendHandle?: any,\n      options?: { swallowErrors?: boolean },\n      callback?: (error: Error | null) => void\n    ): boolean;\n    disconnect(): void;\n    connected: boolean;\n\n    /**\n     * The `process.allowedNodeEnvironmentFlags` property is a special,\n     * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n     * environment variable.\n     */\n    allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n    /**\n     * Only available with `--experimental-report`\n     */\n    report?: ProcessReport;\n\n    resourceUsage(): ResourceUsage;\n\n    /**\n     * EventEmitter\n     *   1. beforeExit\n     *   2. disconnect\n     *   3. exit\n     *   4. message\n     *   5. rejectionHandled\n     *   6. uncaughtException\n     *   7. unhandledRejection\n     *   8. warning\n     *   9. message\n     *  10. <All OS Signals>\n     *  11. newListener/removeListener inherited from EventEmitter\n     */\n    addListener(event: 'beforeExit', listener: BeforeExitListener): this;\n    addListener(event: 'disconnect', listener: DisconnectListener): this;\n    addListener(event: 'exit', listener: ExitListener): this;\n    addListener(\n      event: 'rejectionHandled',\n      listener: RejectionHandledListener\n    ): this;\n    addListener(\n      event: 'uncaughtException',\n      listener: UncaughtExceptionListener\n    ): this;\n    addListener(\n      event: 'unhandledRejection',\n      listener: UnhandledRejectionListener\n    ): this;\n    addListener(event: 'warning', listener: WarningListener): this;\n    addListener(event: 'message', listener: MessageListener): this;\n    addListener(event: Signals, listener: SignalsListener): this;\n    addListener(event: 'newListener', listener: NewListenerListener): this;\n    addListener(\n      event: 'removeListener',\n      listener: RemoveListenerListener\n    ): this;\n    addListener(\n      event: 'multipleResolves',\n      listener: MultipleResolveListener\n    ): this;\n\n    emit(event: 'beforeExit', code: number): boolean;\n    emit(event: 'disconnect'): boolean;\n    emit(event: 'exit', code: number): boolean;\n    emit(event: 'rejectionHandled', promise: Promise<any>): boolean;\n    emit(event: 'uncaughtException', error: Error): boolean;\n    emit(\n      event: 'unhandledRejection',\n      reason: any,\n      promise: Promise<any>\n    ): boolean;\n    emit(event: 'warning', warning: Error): boolean;\n    emit(event: 'message', message: any, sendHandle: any): this;\n    emit(event: Signals, signal: Signals): boolean;\n    emit(\n      event: 'newListener',\n      eventName: string | symbol,\n      listener: (...args: any[]) => void\n    ): this;\n    emit(\n      event: 'removeListener',\n      eventName: string,\n      listener: (...args: any[]) => void\n    ): this;\n    emit(event: 'multipleResolves', listener: MultipleResolveListener): this;\n\n    on(event: 'beforeExit', listener: BeforeExitListener): this;\n    on(event: 'disconnect', listener: DisconnectListener): this;\n    on(event: 'exit', listener: ExitListener): this;\n    on(event: 'rejectionHandled', listener: RejectionHandledListener): this;\n    on(event: 'uncaughtException', listener: UncaughtExceptionListener): this;\n    on(event: 'unhandledRejection', listener: UnhandledRejectionListener): this;\n    on(event: 'warning', listener: WarningListener): this;\n    on(event: 'message', listener: MessageListener): this;\n    on(event: Signals, listener: SignalsListener): this;\n    on(event: 'newListener', listener: NewListenerListener): this;\n    on(event: 'removeListener', listener: RemoveListenerListener): this;\n    on(event: 'multipleResolves', listener: MultipleResolveListener): this;\n\n    once(event: 'beforeExit', listener: BeforeExitListener): this;\n    once(event: 'disconnect', listener: DisconnectListener): this;\n    once(event: 'exit', listener: ExitListener): this;\n    once(event: 'rejectionHandled', listener: RejectionHandledListener): this;\n    once(event: 'uncaughtException', listener: UncaughtExceptionListener): this;\n    once(\n      event: 'unhandledRejection',\n      listener: UnhandledRejectionListener\n    ): this;\n    once(event: 'warning', listener: WarningListener): this;\n    once(event: 'message', listener: MessageListener): this;\n    once(event: Signals, listener: SignalsListener): this;\n    once(event: 'newListener', listener: NewListenerListener): this;\n    once(event: 'removeListener', listener: RemoveListenerListener): this;\n    once(event: 'multipleResolves', listener: MultipleResolveListener): this;\n\n    prependListener(event: 'beforeExit', listener: BeforeExitListener): this;\n    prependListener(event: 'disconnect', listener: DisconnectListener): this;\n    prependListener(event: 'exit', listener: ExitListener): this;\n    prependListener(\n      event: 'rejectionHandled',\n      listener: RejectionHandledListener\n    ): this;\n    prependListener(\n      event: 'uncaughtException',\n      listener: UncaughtExceptionListener\n    ): this;\n    prependListener(\n      event: 'unhandledRejection',\n      listener: UnhandledRejectionListener\n    ): this;\n    prependListener(event: 'warning', listener: WarningListener): this;\n    prependListener(event: 'message', listener: MessageListener): this;\n    prependListener(event: Signals, listener: SignalsListener): this;\n    prependListener(event: 'newListener', listener: NewListenerListener): this;\n    prependListener(\n      event: 'removeListener',\n      listener: RemoveListenerListener\n    ): this;\n    prependListener(\n      event: 'multipleResolves',\n      listener: MultipleResolveListener\n    ): this;\n\n    prependOnceListener(\n      event: 'beforeExit',\n      listener: BeforeExitListener\n    ): this;\n    prependOnceListener(\n      event: 'disconnect',\n      listener: DisconnectListener\n    ): this;\n    prependOnceListener(event: 'exit', listener: ExitListener): this;\n    prependOnceListener(\n      event: 'rejectionHandled',\n      listener: RejectionHandledListener\n    ): this;\n    prependOnceListener(\n      event: 'uncaughtException',\n      listener: UncaughtExceptionListener\n    ): this;\n    prependOnceListener(\n      event: 'unhandledRejection',\n      listener: UnhandledRejectionListener\n    ): this;\n    prependOnceListener(event: 'warning', listener: WarningListener): this;\n    prependOnceListener(event: 'message', listener: MessageListener): this;\n    prependOnceListener(event: Signals, listener: SignalsListener): this;\n    prependOnceListener(\n      event: 'newListener',\n      listener: NewListenerListener\n    ): this;\n    prependOnceListener(\n      event: 'removeListener',\n      listener: RemoveListenerListener\n    ): this;\n    prependOnceListener(\n      event: 'multipleResolves',\n      listener: MultipleResolveListener\n    ): this;\n\n    listeners(event: 'beforeExit'): BeforeExitListener[];\n    listeners(event: 'disconnect'): DisconnectListener[];\n    listeners(event: 'exit'): ExitListener[];\n    listeners(event: 'rejectionHandled'): RejectionHandledListener[];\n    listeners(event: 'uncaughtException'): UncaughtExceptionListener[];\n    listeners(event: 'unhandledRejection'): UnhandledRejectionListener[];\n    listeners(event: 'warning'): WarningListener[];\n    listeners(event: 'message'): MessageListener[];\n    listeners(event: Signals): SignalsListener[];\n    listeners(event: 'newListener'): NewListenerListener[];\n    listeners(event: 'removeListener'): RemoveListenerListener[];\n    listeners(event: 'multipleResolves'): MultipleResolveListener[];\n  }\n\n  interface Global {\n    Array: typeof Array;\n    ArrayBuffer: typeof ArrayBuffer;\n    Boolean: typeof Boolean;\n    Buffer: typeof Buffer;\n    DataView: typeof DataView;\n    Date: typeof Date;\n    Error: typeof Error;\n    EvalError: typeof EvalError;\n    Float32Array: typeof Float32Array;\n    Float64Array: typeof Float64Array;\n    Function: typeof Function;\n    GLOBAL: Global;\n    Infinity: typeof Number.POSITIVE_INFINITY;\n    Int16Array: typeof Int16Array;\n    Int32Array: typeof Int32Array;\n    Int8Array: typeof Int8Array;\n    Intl: typeof Intl;\n    JSON: typeof JSON;\n    Map: MapConstructor;\n    Math: typeof Math;\n    NaN: typeof Number.NaN;\n    Number: typeof Number;\n    Object: typeof Object;\n    Promise: Function;\n    RangeError: typeof RangeError;\n    ReferenceError: typeof ReferenceError;\n    RegExp: typeof RegExp;\n    Set: SetConstructor;\n    String: typeof String;\n    Symbol: Function;\n    SyntaxError: typeof SyntaxError;\n    TypeError: typeof TypeError;\n    URIError: typeof URIError;\n    Uint16Array: typeof Uint16Array;\n    Uint32Array: typeof Uint32Array;\n    Uint8Array: typeof Uint8Array;\n    Uint8ClampedArray: Function;\n    WeakMap: WeakMapConstructor;\n    WeakSet: WeakSetConstructor;\n    clearImmediate: (immediateId: Immediate) => void;\n    clearInterval: (intervalId: Timeout) => void;\n    clearTimeout: (timeoutId: Timeout) => void;\n    console: typeof console;\n    decodeURI: typeof decodeURI;\n    decodeURIComponent: typeof decodeURIComponent;\n    encodeURI: typeof encodeURI;\n    encodeURIComponent: typeof encodeURIComponent;\n    escape: (str: string) => string;\n    eval: typeof eval;\n    global: Global;\n    isFinite: typeof isFinite;\n    isNaN: typeof isNaN;\n    parseFloat: typeof Number.parseFloat;\n    parseInt: typeof Number.parseInt;\n    process: Process;\n    root: Global;\n    setImmediate: (\n      callback: (...args: any[]) => void,\n      ...args: any[]\n    ) => Immediate;\n    setInterval: (\n      callback: (...args: any[]) => void,\n      ms: number,\n      ...args: any[]\n    ) => Timeout;\n    setTimeout: (\n      callback: (...args: any[]) => void,\n      ms: number,\n      ...args: any[]\n    ) => Timeout;\n    queueMicrotask: typeof queueMicrotask;\n    undefined: typeof undefined;\n    unescape: (str: string) => string;\n    gc: () => void;\n    v8debug?: any;\n  }\n\n  // compatibility with older typings\n  interface Timer {\n    hasRef(): boolean;\n    ref(): this;\n    refresh(): this;\n    unref(): this;\n  }\n\n  class Immediate {\n    hasRef(): boolean;\n    ref(): this;\n    unref(): this;\n    _onImmediate: Function; // to distinguish it from the Timeout class\n  }\n\n  class Timeout implements Timer {\n    hasRef(): boolean;\n    ref(): this;\n    refresh(): this;\n    unref(): this;\n  }\n\n  class Module {\n    static runMain(): void;\n    static wrap(code: string): string;\n\n    /**\n     * @deprecated Deprecated since: v12.2.0. Please use createRequire() instead.\n     */\n    static createRequireFromPath(path: string): NodeRequireFunction;\n    static createRequire(path: string): NodeRequireFunction;\n    static builtinModules: string[];\n\n    static Module: typeof Module;\n\n    exports: any;\n    require: NodeRequireFunction;\n    id: string;\n    filename: string;\n    loaded: boolean;\n    parent: Module | null;\n    children: Module[];\n    paths: string[];\n\n    constructor(id: string, parent?: Module);\n  }\n\n  type TypedArray =\n    | Uint8Array\n    | Uint8ClampedArray\n    | Uint16Array\n    | Uint32Array\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Float32Array\n    | Float64Array;\n  type ArrayBufferView = TypedArray | DataView;\n\n  // The value type here is a \"poor man's `unknown`\". When these types support TypeScript\n  // 3.0+, we can replace this with `unknown`.\n  type PoorMansUnknown = {} | null | undefined;\n}\n";var i=t(14274),s=t(19727),a=t(26678),o=t(32999),l=t(10961),u=t(40482),d=t(33632),c=t(67914),f=t(89857),m=t(80370),b=t(57264);const g=r+i+s+a+o+l+u+d+c+f+m+b}}]);
//# sourceMappingURL=9864.747430b4a890c6b8.js.map