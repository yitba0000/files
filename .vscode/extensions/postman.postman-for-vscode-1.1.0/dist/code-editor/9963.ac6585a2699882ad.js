"use strict";(self.webpackChunkcode_editor=self.webpackChunkcode_editor||[]).push([[9963],{69963:e=>{e.exports='// Type definitions for postman-collection 4.0.2\n// Project: https://github.com/postmanlabs/postman-collection\n// Definitions by: PostmanLabs\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.4\n/// <reference types="node" />\n\ndeclare module "postman-collection" {\n\n    /**\n     * @example\n     * Create a new CertificateList\n     * var CertificateList = require(\'postman-collection\').CertificateList,\n     *    certificateList = new CertificateList({}, [\n     *        {\n     *            name: \'my certificate for example.com\',\n     *            matches: [\'https://example.com/*\'],\n     *            key: { src: \'/path/to/key/file\' },\n     *            cert: { src: \'/path/to/certificate/file\' }\n     *        },\n     *        {\n     *            name: \'my certificate for example2.com\',\n     *            matches: [\'https://example2.com/*\'],\n     *            key: { src: \'/path/to/key/file\' },\n     *            cert: { src: \'/path/to/key/file\' }\n     *        }\n     * ]);\n     * @param parent - -\n     * @param list - The list of certificate representations\n     */\n    export class CertificateList extends PropertyList {\n        constructor(parent: any, list: any[]);\n        /**\n         * Matches the given url against the member certificates\' allowed matches\n         * and returns the certificate that can be used for the url.\n         * @param url - The url to find the certificate for\n         * @returns The matched certificate\n         */\n        resolveOne(url: string): Certificate.definition;\n        /**\n         * Checks if the given object is a CertificateList\n         * @param obj - -\n         */\n        static isCertificateList(obj: any): boolean;\n    }\n\n    export namespace Certificate {\n        /**\n         * The following is the object representation accepted as param for the Certificate constructor.\n         * Also the type of the object returned when Property.toJSON or Property.toObjectResolved is called on a\n         * Certificate instance.\n         * @example\n         * JSON definition of an example certificate object\n         * {\n         *     "name": "My certificate for example.com",\n         *     "matches": ["https://example.com/*"],\n         *     "key": { "src": "/path/to/key" },\n         *     "cert": { "src": "/User/path/to/certificate" },\n         *     "passphrase": "iampassphrase"\n         * }\n         * @property [name] - A name for the certificate\n         * @property [matches] - A list of match patterns\n         * @property [key] - Object with path on the file system for private key file, as src\n         * @property [cert] - Object with path on the file system for certificate file, as src\n         * @property [passphrase] - The passphrase for the certificate key\n         */\n        type definition = {\n            name?: string;\n            matches?: any[];\n            key?: any;\n            cert?: any;\n            passphrase?: string;\n        };\n    }\n\n    /**\n     * A Certificate definition that represents the ssl certificate\n     * to be used for an url.\n     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n     * all the variable references replaced by corresponding values.\n     * @example\n     *  Create a new Certificate\n     *\n     * var Certificate = require(\'postman-collection\').Certificate,\n     *    certificate = new Certificate({\n     *     name: \'Certificate for example.com\',\n     *     matches: [\'example.com\'],\n     *     key: { src: \'/User/path/to/certificate/key\' },\n     *     cert: { src: \'/User/path/to/certificate\' },\n     *     passphrase: \'iampassphrase\'\n     * });\n     * @param [options] - Object with matches, key, cert and passphrase\n     */\n    export class Certificate extends Property {\n        constructor(options?: Certificate.definition);\n        /**\n         * Updates the certificate with the given properties.\n         * @param [options] - Object with matches, key, cert and passphrase\n         */\n        update(options?: Certificate.definition): void;\n        /**\n         * Unique identifier\n         */\n        id: string;\n        /**\n         * Name for user reference\n         */\n        name: string;\n        /**\n         * List of match pattern\n         */\n        matches: UrlMatchPatternList;\n        /**\n         * Private Key\n         */\n        key: any;\n        /**\n         * Certificate\n         */\n        cert: any;\n        /**\n         * PFX or PKCS12 Certificate\n         */\n        pfx: any;\n        /**\n         * passphrase\n         */\n        passphrase: any;\n        /**\n         * Checks if the certificate can be applied to a given url\n         * @param url - The url string for which the certificate is checked for match.\n         */\n        canApplyTo(url: string | Url): void;\n        /**\n         * Allows the serialization of a Certificate\n         *\n         * This is overridden, in order to ensure that certificate contents are not accidentally serialized,\n         * which can be a security risk.\n         */\n        toJSON(): void;\n        /**\n         * Checks if the given object is a Certificate\n         * @param obj - -\n         */\n        static isCertificate(obj: any): boolean;\n    }\n\n    export namespace Collection {\n        /**\n         * The following is the object structure accepted as constructor parameter while calling `new Collection(...)`. It is\n         * also the structure exported when Property.toJSON or Property.toObjectResolved is called on a\n         * collection instance.\n         * @example\n         * JSON definition of an example collection\n         * {\n         *     "info": {\n         *         "name": "My Postman Collection",\n         *         "version": "1.0.0"\n         *     }\n         *     "item": [{\n         *         "request": "{{base-url}}/get"\n         *     }],\n         *     "variables": [{\n         *         "id": "base-url",\n         *         "value": "https://postman-echo.com"\n         *     }]\n         * }\n         * @property [info] - The meta information regarding the collection is provided as the `info` object.\n         * @property [info.id] - Every collection is identified by the unique value of this property. It is recommended\n         * that you maintain the same id since changing the id usually implies that is a different collection than it was\n         * originally.\n         * @property [info.name] - A collection\'s friendly name is defined by this property. You would want to set this\n         * field to a value that would allow you to easily identify this collection among a bunch of other collections.\n         * @property [info.version] - Postman allows you to version your collections as they grow, and this field holds\n         * the version number. While optional, it is recommended that you use this field to its fullest extent.\n         * @property [item] - Items are the basic unit for a Postman collection.\n         * You can think of them as corresponding to a single API endpoint. Each Item has one request and may have multiple API\n         * responses associated with it.\n         * @property [variable] - Collection variables allow you to define a set of variables,\n         * that are a *part of the collection*, as opposed to environments, which are separate entities.\n         * @property [auth] - Collection auth allows you to define an authentication,\n         * that *applies to all items* in the collection.\n         * @property [event] - Postman allows you to configure scripts to run when specific events\n         * occur.\n         * @property [version] - Version of the collection expressed in [semver](http://semver.org/)\n         * format.\n         */\n        type definition = {\n            info?: {\n                id?: string;\n                name?: string;\n                version?: string;\n            };\n            item?: (Item.definition | ItemGroup.definition)[];\n            variable?: Variable.definition;\n            auth?: RequestAuth.definition;\n            event?: Event.definition[];\n            version?: string | Version.definition;\n        };\n    }\n\n    /**\n     * Create or load an instance of [Postman Collection](https://www.getpostman.com/docs/collections) as a JavaScript\n     * object that can be manipulated easily.\n     *\n     * A collection lets you group individual requests together. These requests can be further organized into folders to\n     * accurately mirror your API. Requests can also store sample responses when saved in a collection. You can add\n     * metadata like name and description too so that all the information that a developer needs to use your API is\n     * available easily.\n     * @example\n     * Load a Collection JSON file from disk\n     * var fs = require(\'fs\'), // needed to read JSON file from disk\n     *     pretty = function (obj) { // function to neatly log the collection object to console\n     *         return require(\'util\').inspect(obj, {colors: true});\n     *     },\n     *     Collection = require(\'postman-collection\').Collection,\n     *     myCollection;\n     *\n     * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n     * myCollection = new Collection(JSON.stringify(fs.readFileSync(\'sample-collection.json\').toString()));\n     *\n     * // log items at root level of the collection\n     * console.log(pretty(myCollection));\n     * @example\n     * Create a blank collection and write to file\n     * var fs = require(\'fs\'),\n     *     Collection = require(\'postman-collection\').Collection,\n     *     mycollection;\n     *\n     * myCollection = new Collection({\n     *     info: {\n     *         name: "my Collection"\n     *     }\n     * });\n     *\n     * // log the collection to console to see its contents\n     * fs.writeFileSync(\'myCollection.postman_collection\', JSON.stringify(myCollection, null, 2));\n     * @param [definition] - Pass the initial definition of the collection (name, id, etc) as\n     * the `definition` parameter. The definition object is structured exactly as the collection format as defined in\n     * [https://www.schema.getpostman.com/](https://www.schema.getpostman.com/). This parameter is optional. That\n     * implies that you can create an empty instance of collection and add requests and other properties in order to\n     * build a new collection.\n     * @param [environments] - The collection instance constructor accepts the second parameter as an\n     * array of environment objects. Environments objects store variable definitions that are inherited by\n     * Collection.variables. These environment variables are usually the ones that are exported from the Postman\n     * App to use them with different collections. Refer to Postman\n     * [documentation on environment variables](https://www.getpostman.com/docs/environments).\n     */\n    export class Collection extends ItemGroup {\n        constructor(definition?: Collection.definition, environments?: object[]);\n        /**\n         * The `variables` property holds a list of variables that are associated with a Collection. These variables\n         * are stored within a collection so that they can be re-used and replaced in rest of the collection. For\n         * example, if one has a variable named `port` with value `8080`, then one can write a request Url\n         * as `http://localhost:{{port}}/my/endpoint` and that will be replaced to form\n         * `http://localhost:8080/my/endpoint`. **Collection Variables** are like\n         * [environment variables](https://www.getpostman.com/docs/environments), but stored locally within a\n         * collection.\n         * @example\n         * Creating a collection with variables\n         * var fs = require(\'fs\'),\n         *     Collection = require(\'postman-collection\').Collection,\n         *     mycollection;\n         *\n         * // Create a new empty collection.\n         * myCollection = new Collection();\n         *\n         * // Add a variable to the collection\n         * myCollection.variables.add({\n         *     id: \'apiBaseUrl\',\n         *     value: \'http://timeapi.org\',\n         *     type: \'string\'\n         * });\n         *\n         * //Add a request that uses the variable that we just added.\n         * myCollection.items.add({\n         *     id: \'utc-time-now\',\n         *     name: \'Get the current time in UTC\',\n         *     request: \'{{apiBaseUrl}}/utc/now\'\n         * });\n         */\n        variables: VariableList;\n        /**\n         * The `version` key in collection is used to express the version of the collection. It is useful in either\n         * tracking development iteration of an API server or the version of an API itself. It can also be used to\n         * represent the number of iterations of the collection as it is updated through its lifetime.\n         *\n         * Version is expressed in [semver](http://semver.org/) format.\n         */\n        version: Version;\n        /**\n         * Using this function, one can sync the values of collection variables from a reference object.\n         * @param obj - -\n         * @param [track] - -\n         */\n        syncVariablesFrom(obj: any, track?: boolean): any;\n        /**\n         * Transfer the variables in this scope to an object\n         * @param [obj] - -\n         */\n        syncVariablesTo(obj?: any): any;\n        /**\n         * Convert the collection to JSON compatible plain object\n         */\n        toJSON(): any;\n        /**\n         * Check whether an object is an instance of ItemGroup.\n         * @param obj - -\n         */\n        static isCollection(obj: any): boolean;\n        /**\n         * In this list, one can define the Scripts to be executed when an event is triggered. Events are\n         * triggered before certain actions are taken on a Collection, Request, etc. For example, executing a\n         * request causes the `prerequest` and the `test` events to be triggered.\n         * @example\n         * Executing a common test script for all requests in a collection\n         * var fs = require(\'fs\'), // needed to read JSON file from disk\n         *     Collection = require(\'postman-collection\').Collection,\n         *     myCollection;\n         *\n         * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n         * myCollection = new Collection(JSON.stringify(fs.readFileSync(\'sample-collection.json\').toString()));\n         *\n         * // Add an event listener to the collection that listens to the `test` event.\n         * myCollection.events.add({\n         *     listen: \'test\',\n         *     script: {\n         *         exec: \'tests["Status code is 200"] = (responseCode.code === 200)\'\n         *     }\n         * });\n         */\n        events: EventList;\n    }\n\n    /**\n     * Contains a list of header elements\n     * @param parent - -\n     * @param cookies - -\n     */\n    export class CookieList extends PropertyList {\n        constructor(parent: any, cookies: object[]);\n        /**\n         * Checks if the given object is a CookieList\n         * @param obj - -\n         */\n        static isCookieList(obj: any): boolean;\n    }\n\n    export namespace Cookie {\n        /**\n         * The following is the object structure accepted as constructor parameter while calling `new Cookie(...)`. It is\n         * also the structure exported when Property.toJSON or Property.toObjectResolved is called on a\n         * Cookie instance.\n         * @example\n         * JSON definition of an example cookie\n         * {\n         *     "key": "my-cookie-name",\n         *     "expires": "1464769543832",\n         *      // UNIX timestamp, in *milliseconds*\n         *     "maxAge": "300",\n         *      // In seconds. In this case, the Cookie is valid for 5 minutes\n         *     "domain": "something.example.com",\n         *     "path": "/",\n         *     "secure": false,\n         *     "httpOnly": true,\n         *     "session": false,\n         *     "value": "my-cookie-value",\n         *     "extensions": [{\n         *         "key": "Priority",\n         *         "value": "HIGH"\n         *     }]\n         * }\n         * @property [key] - The name of the cookie. Some call it the "name".\n         * @property [value] - The value stored in the Cookie\n         * @property [expires] - Expires sets an expiry date for when a cookie gets deleted. It should either be a\n         * date object or timestamp string of date.\n         * @property [maxAge] - Max-age sets the time in seconds for when a cookie will be deleted.\n         * @property [domain] - Indicates the domain(s) for which the cookie should be sent.\n         * @property [path] - Limits the scope of the cookie to a specified path, e.g: "/accounts"\n         * @property [secure] - A secure cookie will only be sent to the server when a request is made using SSL and\n         * the HTTPS protocol.\n         * The idea that the contents of the cookie are of high value and could be potentially damaging to transmit\n         * as clear text.\n         * @property [httpOnly] - The idea behind HTTP-only cookies is to instruct a browser that a cookie should never\n         * be accessible via JavaScript through the document.cookie property. This feature was designed as a security measure\n         * to help prevent cross-site scripting (XSS) attacks perpetrated by stealing cookies via JavaScript.\n         * @property [hostOnly] - Indicates that this cookie is only valid for the given domain (and not its parent or\n         * child domains.)\n         * @property [session] - Indicates whether this is a Session Cookie. (A transient cookie, which is deleted at\n         * the end of an HTTP session.)\n         * @property [extensions] - Any extra attributes that are extensions to the original Cookie specification can be\n         * specified here.\n         * @property [extensions[].key] - Name of the extension.\n         * @property [extensions[].value] - Value of the extension\n         */\n        type definition = {\n            key?: string;\n            value?: string;\n            expires?: string;\n            maxAge?: number;\n            domain?: string;\n            path?: string;\n            secure?: boolean;\n            httpOnly?: boolean;\n            hostOnly?: boolean;\n            session?: boolean;\n            extensions?: {\n                key?: string;\n                value?: string;\n            };\n        };\n    }\n\n    /**\n     * A Postman Cookie definition that comprehensively represents an HTTP Cookie.\n     * @example\n     * Create a new Cookie\n     * var Cookie = require(\'postman-collection\').Cookie,\n     *     myCookie = new Cookie({\n     *          name: \'my-cookie-name\',\n     *          expires: \'1464769543832\', // UNIX timestamp, in *milliseconds*\n     *          maxAge: \'300\',  // In seconds. In this case, the Cookie is valid for 5 minutes\n     *          domain: \'something.example.com\',\n     *          path: \'/\',\n     *          secure: false,\n     *          httpOnly: true,\n     *          session: false,\n     *          value: \'my-cookie-value\',\n     *          extensions: [{\n     *              key: \'Priority\',\n     *              value: \'HIGH\'\n     *          }]\n     *     });\n     * @example\n     * Parse a Cookie Header\n     * var Cookie = require(\'postman-collection\').Cookie,\n     *     rawHeader = \'myCookie=myValue;Path=/;Expires=Sun, 04-Feb-2018 14:18:27 GMT;Secure;HttpOnly;Priority=HIGH\'\n     *     myCookie = new Cookie(rawHeader);\n     *\n     * console.log(myCookie.toJSON());\n     * @param [options] - Pass the initial definition of the Cookie.\n     */\n    export class Cookie extends PropertyBase {\n        constructor(options?: Cookie.definition);\n        /**\n         * The name of the cookie.\n         */\n        name: string;\n        /**\n         * Expires sets an expiry date for when a cookie gets deleted. It should either be a date object or\n         * timestamp string of date.\n         */\n        expires: Date | string;\n        /**\n         * Max-age sets the time in seconds for when a cookie will be deleted.\n         */\n        maxAge: number;\n        /**\n         * Indicates the domain(s) for which the cookie should be sent.\n         */\n        domain: string;\n        path: string;\n        /**\n         * A secure cookie will only be sent to the server when a request is made using SSL and the HTTPS protocol.\n         * The idea that the contents of the cookie are of high value and could be potentially damaging to transmit\n         * as clear text.\n         */\n        secure: boolean;\n        /**\n         * The idea behind HTTP-only cookies is to instruct a browser that a cookie should never be accessible via\n         * JavaScript through the document.cookie property. This feature was designed as a security measure to help\n         * prevent cross-site scripting (XSS) attacks perpetrated by stealing cookies via JavaScript.\n         */\n        httpOnly: boolean;\n        hostOnly: boolean;\n        /**\n         * Indicates whether this is a Session Cookie.\n         */\n        session: boolean;\n        value: string;\n        /**\n         * Any extra parameters that are not strictly a part of the Cookie spec go here.\n         */\n        extensions: any[];\n        /**\n         * Get the value of this cookie.\n         */\n        valueOf(): string;\n        /**\n         * Converts the Cookie to a single Set-Cookie header string.\n         */\n        toString(): string;\n        /**\n         * Check whether an object is an instance of PostmanCookie.\n         * @param obj - -\n         */\n        static isCookie(obj: any): boolean;\n        /**\n         * Stringifies an Array or PropertyList of Cookies into a single string.\n         * @param cookies - List of cookie definition object\n         */\n        static unparse(cookies: Cookie[]): string;\n        /**\n         * Unparses a single Cookie.\n         * @param cookie - Cookie definition object\n         */\n        static unparseSingle(cookie: Cookie): string;\n        /**\n         * Cookie header parser\n         * @param str - -\n         * @returns A plain cookie options object, use it to create a new Cookie\n         */\n        static parse(str: string): any;\n        /**\n         * Converts the Cookie to a single Set-Cookie header string.\n         * @param cookie - Cookie definition object\n         */\n        static stringify(cookie: Cookie): string;\n    }\n\n    export namespace Description {\n        type definition = {\n            content: string;\n            type: string;\n        };\n    }\n\n    /**\n     * This is one of the properties that are (if provided) processed by all other properties. Any property can have an\n     * instance of `Description` property assigned to it with the key name `description` and it should be treated as\n     * something that "describes" the property within which it belongs. Usually this property is used to generate\n     * documentation and other contextual information for a property in a Collection.\n     * @example\n     * Add a description to an instance of Collection\n     *  var SDK = require(\'postman-collection\'),\n     *     Collection = SDK.Collection,\n     *     Description = SDK.Description,\n     *     mycollection;\n     *\n     * // create a blank collection\n     * myCollection = new Collection();\n     * myCollection.description = new Description({\n     *     content: \'&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I am a Collection&lt;/p&gt;\',\n     *     type: \'text/html\'\n     * });\n     *\n     * // alternatively, you could also use the `.describe` method of any property to set or update the description of the\n     * // property.\n     * myCollection.describe(\'Hey! This is a cool collection.\');\n     * @param [definition] - The content of the description can be passed as a string when it\n     * is in `text/plain` format or otherwise be sent as part of an object adhering to the Description.definition\n     * structure having `content` and `type`.\n     */\n    export class Description {\n        constructor(definition?: Description.definition | string);\n        /**\n         * Updates the content of this description property.\n         * @param content - -\n         * @param [type] - -\n         */\n        update(content: string | Description.definition, type?: string): void;\n        /**\n         * The raw content of the description\n         */\n        content: string;\n        /**\n         * The mime-type of the description.\n         */\n        type: string;\n        /**\n         * Returns stringified Description.\n         */\n        toString(): string;\n        /**\n         * Creates a JSON representation of the Description (as a plain Javascript object).\n         */\n        toJSON(): any;\n        /**\n         * Checks whether a property is an instance of Description object.\n         * @param obj - -\n         */\n        static isDescription(obj: any): boolean;\n    }\n\n    /**\n     * A type of PropertyList, EventList handles resolving events from parents. If an ItemGroup contains\n     * a set of events, each Item in that group will inherit those events from its parent, and so on.\n     * @param parent - -\n     * @param populate - -\n     */\n    export class EventList extends PropertyList {\n        constructor(parent: any, populate: object[]);\n        /**\n         * Returns an array of listeners filtered by the listener name\n         * @param name - -\n         */\n        listeners(name: string): Event[];\n        /**\n         * Returns all events with specific listeners only within this list. Refer to EventList.listeners for\n         * procuring all inherited events\n         * @param name - -\n         */\n        listenersOwn(name: string): Event[];\n        /**\n         * Checks if the given object is an EventList.\n         * @param obj - -\n         */\n        static isEventList(obj: any): boolean;\n    }\n\n    export namespace Event {\n        /**\n         * @example\n         * Constructing an event\n         * var Event = require(\'postman-collection\').Event,\n         *     rawEvent = {\n         *         listen: \'test\',\n         *         script: \'tests["response code is 401"] = responseCode.code === 401\'\n         *     },\n         *     myEvent;\n         * myEvent = new Event(rawEvent);\n         * @property listen - The event-name that this script will be called for. Usually either "test" or "prerequest"\n         * @property script - A Script instance that will be executed on this event. In case of a\n         * string, a new Script is created.\n         */\n        type definition = {\n            listen: string;\n            script: Script | string;\n        };\n    }\n\n    /**\n     * A Postman event definition that refers to an event to be listened to and a script reference or definition to be\n     * executed.\n     * @param definition - Pass the initial definition of the event as the options parameter.\n     */\n    export class Event extends Property {\n        constructor(definition: Event.definition);\n        /**\n         * Update an event.\n         * @param definition - -\n         */\n        update(definition: Event.definition): void;\n        /**\n         * Name of the event that this instance is intended to listen to.\n         */\n        listen: string;\n        /**\n         * The script that is to be executed when this event is triggered.\n         */\n        script: Script;\n    }\n\n    export namespace FormParam {\n        /**\n         * @property key - The name ("key") of the form data parameter.\n         * @property value - The value of the parameter.\n         */\n        type definition = {\n            key: string;\n            value: string;\n        };\n    }\n\n    /**\n     * Represents a Form Data parameter, which can exist in request body.\n     * @param options - Pass the initial definition of the form data parameter.\n     */\n    export class FormParam {\n        constructor(options: FormParam.definition);\n        /**\n         * Converts the FormParameter to a single param string.\n         */\n        toString(): string;\n        /**\n         * Returns the value of the form parameter (if any).\n         */\n        valueOf(): any | string;\n        /**\n         * Convert the form-param to JSON compatible plain object.\n         */\n        toJSON(): any;\n        /**\n         * Declare the list index key, so that property lists of form parameters work correctly\n         */\n        static _postman_propertyIndexKey: string;\n        /**\n         * Form params can have multiple values, so set this to true.\n         */\n        static _postman_propertyAllowsMultipleValues: boolean;\n        /**\n         * Parse a form data string into an array of objects, where each object contains a key and a value.\n         */\n        static parse: any;\n    }\n\n    /**\n     * Contains a list of header elements\n     * @param parent - -\n     * @param headers - -\n     */\n    export class HeaderList extends PropertyList {\n        constructor(parent: any, headers: Header[]);\n        /**\n         * Gets size of a list of headers excluding standard header prefix.\n         */\n        contentSize(): number;\n        /**\n         * Checks if the given object is a HeaderList\n         * @param obj - -\n         */\n        static isHeaderList(obj: any): boolean;\n    }\n\n    export namespace Header {\n        /**\n         * @example\n         * Create a header\n         * var Header = require(\'postman-collection\').Header,\n         *     header = new Header({\n         *         key: \'Content-Type\',\n         *         value: \'application/xml\'\n         *     });\n         *\n         * console.log(header.toString()) // prints the string representation of the Header.\n         * @property key - The Header name (e.g: \'Content-Type\')\n         * @property value - The value of the header.\n         */\n        type definition = {\n            key: string;\n            value: string;\n        };\n    }\n\n    /**\n     * Represents an HTTP header, for requests or for responses.\n     * @example\n     * Parse a string of headers into an array of Header objects\n     * var Header = require(\'postman-collection\').Header,\n     *     headerString = \'Content-Type: application/json\\nUser-Agent: MyClientLibrary/2.0\\n\';\n     *\n     * var rawHeaders = Header.parse(headerString);\n     * console.log(rawHeaders); // [{ \'Content-Type\': \'application/json\', \'User-Agent\': \'MyClientLibrary/2.0\' }]\n     *\n     * var headers = rawHeaders.map(function (h) {\n     *     return new Header(h);\n     * });\n     *\n     * function assert(condition, message) {\n     *       if (!condition) {\n     *           message = message || "Assertion failed";\n     *           if (typeof Error !== "undefined") {\n     *               throw new Error(message);\n     *           }\n     *           throw message; //fallback\n     *       }\n     *       else {\n     *           console.log("Assertion passed");\n     *       }\n     *   }\n     *\n     * assert(headerString.trim() === Header.unparse(headers).trim());\n     * @param options - Pass the header definition as an object or the value of the header.\n     * If the value is passed as a string, it should either be in `name:value` format or the second "name" parameter\n     * should be used to pass the name as string\n     * @param [name] - optional override the header name or use when the first parameter is the header value as\n     * string.\n     */\n    export class Header extends Property {\n        constructor(options: Header.definition | string, name?: string);\n        /**\n         * Converts the header to a single header string.\n         */\n        toString(): string;\n        /**\n         * Return the value of this header.\n         */\n        valueOf(): string;\n        /**\n         * Assigns the given properties to the Header\n         * @param options - -\n         */\n        update(options: any): void;\n        /**\n         * The header Key\n         */\n        key: string;\n        /**\n         * The header value\n         */\n        value: string;\n        /**\n         * Parses a multi line header string into an array of Header.definition.\n         * @param headerString - -\n         */\n        static parse(headerString: string): any[];\n        /**\n         * Parses a single Header.\n         * @param header - -\n         */\n        static parseSingle(header: string): any;\n        /**\n         * Stringifies an Array or PropertyList of Headers into a single string.\n         * @param headers - -\n         * @param [separator = \'\\r\\n\'] - Specify a string for separating each header\n         */\n        static unparse(headers: any[] | PropertyList, separator?: string): string;\n        /**\n         * Unparses a single Header.\n         * @param header - -\n         */\n        static unparseSingle(header: string): string;\n        /**\n         * Check whether an object is an instance of PostmanHeader.\n         * @param obj - -\n         */\n        static isHeader(obj: any): boolean;\n        /**\n         * Create a new header instance\n         * @param [value] - Pass the header definition as an object or the value of the header.\n         * If the value is passed as a string, it should either be in `name:value` format or the second "name" parameter\n         * should be used to pass the name as string\n         * @param [name] - optional override the header name or use when the first parameter is the header value as\n         * string.\n         */\n        static create(value?: Header.definition | string, name?: string): Header;\n        /**\n         * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a\n         * property is part of a PropertyList. For example, in a PropertyList of Headers, the ones\n         * that are disabled can be filtered out and not processed.\n         */\n        disabled: boolean;\n    }\n\n    export namespace ItemGroup {\n        /**\n         * The following defines the object (or JSON) structure that one can pass to the ItemGroup while creating a new\n         * ItemGroup instance. This is also the object structure returned when `.toJSON()` is called on an ItemGroup instance.\n         * @example\n         * {\n         *     "name": "Echo Get Requests",\n         *     "id": "echo-get-requests",\n         *     "item": [{\n         *         "request": "https://postman-echo.com/get"\n         *     }, {\n         *         "request": "https://postman-echo.com/headers"\n         *     }],\n         *     "auth": {\n         *         "type": "basic",\n         *         "basic": {\n         *             "username": "jean",\n         *             "password": "{{somethingsecret}}"\n         *         }\n         *     },\n         *     "event": [{\n         *         "listen": "prerequest",\n         *         "script": {\n         *             "type": "text/javascript",\n         *             "exec": "console.log(new Date())"\n         *         }\n         *     }]\n         * }\n         */\n        type definition = {\n            item?: (ItemGroup.definition | Item.definition)[];\n            auth?: RequestAuth.definition;\n            event?: Event.definition[];\n        };\n    }\n\n    /**\n     * An ItemGroup represents a composite list of Item or ItemGroup. In terms of Postman App, ItemGroup\n     * represents a "Folder". This allows one to group Items into subsets that can have their own meaning. An\n     * ItemGroup also allows one to define a subset of common properties to be applied to each Item within it. For\n     * example, a `test` event defined on an ItemGroup is executed while testing any Item that belongs to that group.\n     * Similarly, ItemGroups can have a common {@RequestAuth} defined so that every Request, when processed,\n     * requires to be authenticated using the `auth` defined in the group.\n     *\n     * Essentially, Collection too is a special type of ItemGroup ;-).\n     * @example\n     * Add a new ItemGroup to a collection instance\n     * var Collection = require(\'postman-collection\').Collection,\n     *     ItemGroup = require(\'postman-collection\').ItemGroup,\n     *     myCollection;\n     *\n     * myCollection = new Collection(); // create an empty collection\n     * myCollection.items.add(new ItemGroup({ // add a folder called "blank folder"\n     *     "name": "This is a blank folder"\n     * }));\n     * @param [definition] - While creating a new instance of ItemGroup, one can provide the\n     * initial configuration of the item group with the requests it contains, the authentication applied to all\n     * requests, events that the requests responds to, etc.\n     */\n    export class ItemGroup extends Property {\n        constructor(definition?: ItemGroup.definition);\n        /**\n         * This is a PropertyList that holds the list of Items or ItemGroups belonging to a\n         * Collection or to an ItemGroup. Operation on an individual item in this list can be\n         * performed using various functions available to a PropertyList.\n         * @example\n         * Fetch empty ItemGroups in a list loaded from a file\n         * var fs = require(\'fs\'), // needed to read JSON file from disk\n         *     Collection = require(\'postman-collection\').Collection,\n         *     myCollection,\n         *     emptyGroups;\n         * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n         * myCollection = new Collection(JSON.stringify(fs.readFileSync(\'sample-collection.json\').toString()));\n         *\n         * // Filter items in Collection root that is an empty ItemGroup\n         * emptyGroups = myCollection.items.filter(function (item) {\n         *     return item && item.items && (item.items.count() === 0);\n         * });\n         *\n         * // Log the emptyGroups array to check it\'s contents\n         * console.log(emptyGroups);\n         */\n        items: PropertyList;\n        /**\n         * One can define the default authentication method required for every item that belongs to this list.\n         * Individual Requests can override this in their own definitions. More on how to define an\n         * authentication method is outlined in the RequestAuth property.\n         * @example\n         * Define an entire ItemGroup (folder) or Collection to follow Basic Auth\n         * var fs = require(\'fs\'),\n         *     Collection = require(\'postman-collection\').Collection,\n         *     RequestAuth = require(\'postman-collection\').RequestAuth,\n         *     mycollection;\n         *\n         * // Create a collection having two requests\n         * myCollection = new Collection();\n         * myCollection.items.add([\n         *     { name: \'GET Request\', request: \'https://postman-echo.com/get?auth=basic\' },\n         *     { name: \'PUT Request\', request: \'https://postman-echo.com/put?auth=basic\' }\n         * ]);\n         *\n         * // Add basic auth to the Collection, to be applied on all requests.\n         * myCollection.auth = new RequestAuth({\n         *     type: \'basic\',\n         *     username: \'postman\',\n         *     password: \'password\'\n         * });\n         */\n        auth: RequestAuth;\n        /**\n         * Set of configurations used to alter the usual behavior of sending the request.\n         * @property disableBodyPruning - Disable body pruning for request methods like GET, HEAD etc.\n         */\n        protocolProfileBehavior: {\n            disableBodyPruning: boolean;\n        };\n        /**\n         * Finds the first item with the given name or id in the current ItemGroup.\n         * @param idOrName - -\n         */\n        oneDeep(idOrName: string): void;\n        /**\n         * Sets authentication method for all the items within this group\n         */\n        authorizeRequestsUsing: any;\n        /**\n         * Check whether an object is an instance of ItemGroup.\n         * @param obj - -\n         */\n        static isItemGroup(obj: any): boolean;\n    }\n\n    export namespace Item {\n        /**\n         * The following defines the object (or JSON) structure that one can pass to the Item while creating a new Item\n         * instance. This is also the object structure returned when `.toJSON()` is called on an Item instance.\n         * @example\n         * {\n         *     "name": "Get Headers from Echo",\n         *     "id": "my-request-1",\n         *     "description": "Makes a GET call to echo service and returns the client headers that were sent",\n         *\n         *     "request": {\n         *         "url": "https://postman-echo.com/headers",\n         *         "method": "GET"\n         *     }\n         * }\n         * @property [request] - A request represents an HTTP request. If a string, the string is assumed to\n         * be the request URL and the method is assumed to be \'GET\'.\n         * @property [responses] - Sample responses for this request can be stored along with the\n         * item definition.\n         * @property [events] - Postman allows you to configure scripts to run when specific events\n         * occur. These scripts are stored here, and can be referenced in the collection by their id.\n         */\n        type definition = {\n            request?: Request.definition;\n            responses?: Response.definition[];\n            events?: Event.definition[];\n        };\n    }\n\n    /**\n     * A Postman Collection Item that holds your request definition, responses and other stuff. An Item essentially is\n     * a HTTP request definition along with the sample responses and test scripts clubbed together. One or more of these\n     * items can be grouped together and placed in an ItemGroup and as such forms a Collection of\n     * requests.\n     * @example\n     * Add a new Item to a folder in a collection instance\n     * var Collection = require(\'postman-collection\').Collection,\n     *     Item = require(\'postman-collection\').Item,\n     *     myCollection;\n     *\n     * myCollection = new Collection({\n     *     "item": [{\n     *         "id": "my-folder-1",\n     *         "name": "The solo folder in this collection",\n     *         "item": [] // blank array indicates this is a folder\n     *     }]\n     * }); // create a collection with an empty folder\n     * // add a request to "my-folder-1" that sends a GET request\n     * myCollection.items.one("my-folder-1").items.add(new Item({\n     *     "name": "Send a GET request",\n     *     "id": "my-get-request",\n     *     "request": {\n     *         "url": "https://postman-echo.com/get",\n     *         "method": "GET"\n     *     }\n     * }));\n     * @param [definition] - While creating a new instance of Item, one can provide the initial\n     * configuration of the item with the the request it sends, the expected sample responses, tests, etc\n     */\n    export class Item extends Property {\n        constructor(definition?: Item.definition);\n        /**\n         * The instance of the Request object inside an Item defines the HTTP request that is supposed to be\n         * sent. It further contains the request method, url, request body, etc.\n         */\n        request: Request;\n        /**\n         * An Item also contains a list of sample responses that is expected when the request defined in the item is\n         * executed. The sample responses are useful in elaborating API usage and is also useful for other\n         * integrations that use the sample responses to do something - say a mock service.\n         */\n        responses: PropertyList;\n        /**\n         * Events are a set of of Scripts that are executed when certain activities are triggered on an\n         * Item. For example, on defining an event that listens to the "test" event, would cause the associated\n         * script of the event to be executed when the test runs.\n         * @example\n         * Add a script to be executed on "prerequest" event\n         * var Collection = require(\'postman-collection\').Collection,\n         *     Item = require(\'postman-collection\').Item,\n         *     myCollection;\n         *\n         * myCollection = new Collection({\n         *     "item": [{\n         *         "name": "Send a GET request",\n         *         "id": "my-get-request",\n         *         "request": {\n         *             "url": "https://postman-echo.com/get",\n         *             "method": "GET"\n         *         }\n         *     }]\n         * }); // create a collection with one request\n         *\n         * // add a pre-request script to the event list\n         * myCollection.items.one(\'my-get-request\').events.add({\n         *     "listen": "prerequest",\n         *     "script": {\n         *         "type": "text/javascript",\n         *         "exec": "console.log(new Date())"\n         *     }\n         * });\n         */\n        events: EventList;\n        /**\n         * Set of configurations used to alter the usual behavior of sending the request.\n         */\n        protocolProfileBehavior: any;\n        /**\n         * Fetches applicable AuthType from the current item.\n         */\n        getAuth(): RequestAuth;\n        /**\n         * Returns Events corresponding to a particular event name. If no name is given, returns all events. This\n         * is useful when you want to trigger all associated scripts for an event.\n         * @example\n         * Get all events for an item and evaluate their scripts\n         * var fs = require(\'fs\'), // needed to read JSON file from disk\n         *     Collection = require(\'postman-collection\').Collection,\n         *     myCollection;\n         *\n         * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)\n         * myCollection = new Collection(JSON.stringify(fs.readFileSync(\'sample-collection.json\').toString()));\n         *\n         * // assuming the collection has a request called "my-request-1" in root, we get it\'s test events\n         * myCollection.items.one("my-request-1").getEvents("test").forEach(function (event) {\n         *     event.script && eval(event.script.toSource());\n         * });\n         * @param name - one of the available event types such as `test`, `prerequest`, `postrequest`, etc.\n         */\n        getEvents(name: string): Event[];\n        /**\n         * Sets authentication method for the request within this item\n         * @param type - -\n         * @param [options] - -\n         */\n        authorizeRequestUsing(type: string | RequestAuth.definition, options?: VariableList): void;\n        /**\n         * Check whether an object is an instance of PostmanItem.\n         * @param obj - -\n         */\n        static isItem(obj: any): boolean;\n    }\n\n    export namespace MutationTracker {\n        /**\n         * A JSON representation of a mutation on an object. Here objects mean instances of postman-collection classes.\n         * This captures the instruction and the parameters of the instruction so that it can be replayed on a different object.\n         * Mutations can be any change on an object. For example setting a key or unsetting a key.\n         *\n         * For example, the mutation to set `name` on an object to \'Bruce Wayne\' would look like [\'name\', \'Bruce Wayne\']. Where\n         * the first item is the key path and second item is the value. To add a property `punchLine` to the object it would be\n         * the same as updating the property i.e. [\'punchLine\', \'I\\\'m Batman\']. To remove a property `age` the mutation would\n         * look like [\'age\'].\n         *\n         * This format of representing changes is derived from\n         * http://json-delta.readthedocs.io/en/latest/philosophy.html.\n         *\n         * The `set` and `unset` are primitive instructions and can be derived from the mutation without explicitly stating the\n         * instruction. For more complex mutation the instruction would have to be explicitly stated.\n         */\n        type mutation = any[];\n        /**\n         * A JSON representation of the MutationTracker.\n         * @property stream - contains the stream mutations tracked\n         * @property compacted - contains a compacted version of the mutations\n         * @property [autoCompact = false] - when set to true, all new mutations would be compacted immediately\n         */\n        type definition = {\n            stream: any[];\n            compacted: any;\n            autoCompact?: boolean;\n        };\n    }\n\n    /**\n     * A MutationTracker allows to record mutations on any of object and store them. This stored mutations can be\n     * transported for reporting or to replay on similar objects.\n     * @param definition - serialized mutation tracker\n     */\n    export class MutationTracker extends PropertyBase {\n        constructor(definition: MutationTracker.definition);\n        /**\n         * Track a mutation.\n         * @param instruction - the type of mutation\n         * @param payload - mutation parameters\n         */\n        track(instruction: string, ...payload: any[]): void;\n        /**\n         * Compacts the recorded mutations removing duplicate mutations that apply on the same key path.\n         */\n        compact(): void;\n        /**\n         * Returns the number of mutations tracked so far.\n         */\n        count(): number;\n        /**\n         * Applies all the recorded mutations on a target object.\n         * @param target - Target to apply mutations. Must implement `applyMutation`.\n         */\n        applyOn(target: any): void;\n        /**\n         * Check whether an object is an instance of MutationTracker.\n         * @param obj - -\n         */\n        static isMutationTracker(obj: any): boolean;\n    }\n\n    export namespace PropertyBase {\n        type definition = {\n            description?: string | Description;\n        };\n    }\n\n    /**\n     * Base of all properties in Postman Collection. It defines the root for all standalone properties for postman\n     * collection.\n     * @param definition - -\n     */\n    export class PropertyBase {\n        constructor(definition: PropertyBase.definition);\n        /**\n         * Invokes the given iterator for every parent in the parent chain of the given element.\n         * @param options - A set of options for the parent chain traversal.\n         * @param [options.withRoot = false] - Set to true to include the collection object as well.\n         * @param iterator - The function to call for every parent in the ancestry chain.\n         */\n        forEachParent(options: {\n            withRoot?: boolean;\n        }, iterator: (...params: any[]) => any): void;\n        /**\n         * Tries to find the given property locally, and then proceeds to lookup in each parent,\n         * going up the chain as necessary. Lookup will continue until `customizer` returns a truthy value. If used\n         * without a customizer, the lookup will stop at the first parent that contains the property.\n         * @param property - -\n         * @param [customizer] - -\n         */\n        findInParents(property: string, customizer?: (...params: any[]) => any): any | undefined;\n        /**\n         * Returns the JSON representation of a property, which conforms to the way it is defined in a collection.\n         * You can use this method to get the instantaneous representation of any property, including a Collection.\n         */\n        toJSON(): void;\n        /**\n         * Returns the meta keys associated with the property\n         */\n        meta(): any;\n        /**\n         * Returns the parent of item\n         */\n        parent(): any | undefined;\n        /**\n         * Filter function to check whether a key starts with underscore or not. These usually are the meta properties. It\n         * returns `true` if the criteria is matched.\n         * @param value - -\n         * @param key - -\n         */\n        static propertyIsMeta(value: any, key: string): boolean;\n        /**\n         * Map function that removes the underscore prefix from an object key.\n         * @param value - -\n         * @param key - -\n         */\n        static propertyUnprefixMeta(value: any, key: string): string;\n        /**\n         * Static function which allows calling toJSON() on any object.\n         * @param obj - -\n         */\n        static toJSON(obj: any): any;\n    }\n\n    export namespace PropertyList {\n        /**\n         * An item constructed of PropertyList.Type.\n         */\n        type Type = any;\n    }\n\n    /**\n     * @param type - -\n     * @param parent - -\n     * @param populate - -\n     */\n    export class PropertyList {\n        constructor(type: (...params: any[]) => any, parent: any, populate: any[]);\n        /**\n         * Insert an element at the end of this list. When a reference member specified via second parameter is found, the\n         * member is inserted at an index before the reference member.\n         * @param item - -\n         * @param [before] - -\n         */\n        insert(item: PropertyList.Type, before?: PropertyList.Type | string): void;\n        /**\n         * Insert an element at the end of this list. When a reference member specified via second parameter is found, the\n         * member is inserted at an index after the reference member.\n         * @param item - -\n         * @param [after] - -\n         */\n        insertAfter(item: PropertyList.Type, after?: PropertyList.Type | string): void;\n        /**\n         * Adds or moves an item to the end of this list.\n         * @param item - -\n         */\n        append(item: PropertyList.Type): void;\n        /**\n         * Adds or moves an item to the beginning of this list.\n         * @param item - -\n         */\n        prepend(item: PropertyList.Type): void;\n        /**\n         * Add an item or item definition to this list.\n         * @param item - -\n         */\n        add(item: any | PropertyList.Type): void;\n        /**\n         * Add an item or update an existing item\n         * @param item - -\n         */\n        upsert(item: PropertyList.Type): boolean;\n        /**\n         * Removes all elements from the PropertyList for which the predicate returns truthy.\n         * @param predicate - -\n         * @param context - Optional context to bind the predicate to.\n         */\n        remove(predicate: ((...params: any[]) => any) | string | PropertyList.Type, context: any): void;\n        /**\n         * Removes all items in the list\n         */\n        clear(): void;\n        /**\n         * Load one or more items\n         * @param items - -\n         */\n        populate(items: any | any[]): void;\n        /**\n         * Clears the list and adds new items.\n         * @param items - -\n         */\n        repopulate(items: any | any[]): void;\n        /**\n         * Add or update values from a source list.\n         * @param source - -\n         * @param [prune = false] - Setting this to `true` will cause the extra items from the list to be deleted\n         */\n        assimilate(source: PropertyList | any[], prune?: boolean): void;\n        /**\n         * Returns a map of all items.\n         */\n        all(): any;\n        /**\n         * Get Item in this list by `ID` reference. If multiple values are allowed, the last value is returned.\n         * @param id - -\n         */\n        one(id: string): PropertyList.Type;\n        /**\n         * Get the value of an item in this list. This is similar to PropertyList.one barring the fact that it\n         * returns the value of the underlying type of the list content instead of the item itself.\n         * @param key - -\n         */\n        get(key: string | ((...params: any[]) => any)): PropertyList.Type | any;\n        /**\n         * Iterate on each item of this list.\n         * @param iterator - -\n         * @param context - -\n         */\n        each(iterator: (...params: any[]) => any, context: any): void;\n        /**\n         * @param rule - -\n         * @param context - -\n         */\n        filter(rule: (...params: any[]) => any, context: any): void;\n        /**\n         * Find an item within the item group\n         * @param rule - -\n         * @param [context] - -\n         */\n        find(rule: (...params: any[]) => any, context?: any): Item | ItemGroup;\n        /**\n         * Iterates over the property list.\n         * @param iterator - Function to call on each item.\n         * @param context - Optional context, defaults to the PropertyList itself.\n         */\n        map(iterator: (...params: any[]) => any, context: any): void;\n        /**\n         * Iterates over the property list and accumulates the result.\n         * @param iterator - Function to call on each item.\n         * @param accumulator - Accumulator initial value\n         * @param context - Optional context, defaults to the PropertyList itself.\n         */\n        reduce(iterator: (...params: any[]) => any, accumulator: any, context: any): void;\n        /**\n         * Returns the length of the PropertyList\n         */\n        count(): number;\n        /**\n         * Get a member of this list by it\'s index\n         * @param index - -\n         */\n        idx(index: number): PropertyList.Type;\n        /**\n         * Find the index of an item in this list\n         * @param item - -\n         */\n        indexOf(item: string | any): number;\n        /**\n         * Check whether an item exists in this list\n         * @param item - -\n         * @param [value] - -\n         */\n        has(item: string | PropertyList.Type, value?: any): boolean;\n        /**\n         * Iterates over all parents of the property list\n         * @param iterator - -\n         * @param [context] - -\n         */\n        eachParent(iterator: (...params: any[]) => any, context?: any): void;\n        /**\n         * Converts a list of Properties into an object where key is `_postman_propertyIndexKey` and value is determined\n         * by the `valueOf` function\n         * @param [excludeDisabled = false] - When set to true, disabled properties are excluded from the resultant\n         * object.\n         * @param [caseSensitive] - When set to true, properties are treated strictly as per their original\n         * case. The default value for this property also depends on the case insensitivity definition of the current\n         * property.\n         * @param [multiValue = false] - When set to true, only the first value of a multi valued property is\n         * returned.\n         * @param [sanitizeKeys = false] - When set to true, properties with falsy keys are removed.\n         */\n        toObject(excludeDisabled?: boolean, caseSensitive?: boolean, multiValue?: boolean, sanitizeKeys?: boolean): any;\n        /**\n         * Adds ability to convert a list to a string provided it\'s underlying format has unparse function defined.\n         */\n        toString(): string;\n        /**\n         * Checks whether an object is a PropertyList\n         * @param obj - -\n         */\n        static isPropertyList(obj: any): boolean;\n    }\n\n    export namespace Property {\n        /**\n         * @property [id] - A unique string that identifies the property.\n         * @property [name] - A distinctive and human-readable name of the property.\n         * @property [disabled] - Denotes whether the property is disabled or not.\n         * @property [info] - The meta information regarding the Property is provided as the `info` object.\n         * @property [info.id] - If set, this is used instead of the definition root\'s id.\n         * @property [info.name] - If set, this is used instead of the definition root\'s name.\n         */\n        type definition = {\n            id?: string;\n            name?: string;\n            disabled?: boolean;\n            info?: {\n                id?: string;\n                name?: string;\n            };\n        };\n    }\n\n    /**\n     * The Property class forms the base of all postman collection SDK elements. This is to be used only for SDK\n     * development or to extend the SDK with additional functionalities. All SDK classes (constructors) that are\n     * supposed to be identifyable (i.e. ones that can have a `name` and `id`) are derived from this class.\n     *\n     * For more information on what is the structure of the `definition` the function parameter, have a look at\n     * Property.definition.\n     *\n     * > This is intended to be a private class except for those who want to extend the SDK itself and add more\n     * > functionalities.\n     * @param [definition] - Every constructor inherited from `Property` is required to call the\n     * super constructor function. This implies that construction parameters of every inherited member is propagated\n     * to be sent up to this point.\n     */\n    export class Property extends PropertyBase {\n        constructor(definition?: Property.definition);\n        /**\n         * The `id` of the property is a unique string that identifies this property and can be used to refer to\n         * this property from relevant other places. It is a good practice to define the id or let the system\n         * auto generate a UUID if one is not defined for properties that require an `id`.\n         */\n        id: string;\n        /**\n         * A property can have a distinctive and human-readable name. This is to be used to display the name of the\n         * property within Postman, Newman or other runtimes that consume collection. In certain cases, the absence\n         * of name might cause the runtime to use the `id` as a fallback.\n         */\n        name: string;\n        /**\n         * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a\n         * property is part of a PropertyList. For example, in a PropertyList of Headers, the ones\n         * that are disabled can be filtered out and not processed.\n         */\n        disabled: boolean;\n        /**\n         * This function allows to describe the property for the purpose of detailed identification or documentation\n         * generation. This function sets or updates the `description` child-property of this property.\n         * @example\n         * Add a description to an instance of Collection\n         *  var Collection = require(\'postman-collection\').Collection,\n         *     mycollection;\n         *\n         * // create a blank collection\n         * myCollection = new Collection();\n         * myCollection.describe(\'Hey! This is a cool collection.\');\n         *\n         * console.log(myCollection.description.toString()); // read the description\n         * @param content - The content of the description can be provided here as a string. Note that it is expected\n         * that if the content is formatted in any other way than simple text, it should be specified in the subsequent\n         * `type` parameter.\n         * @param [type = "text/plain"] - The type of the content.\n         */\n        describe(content: string, type?: string): void;\n        /**\n         * Returns all the substitutions (variables) that are needed (or referenced) in this property (recursively).\n         * @example\n         * // returns [\'host\', \'path1\']\n         * prop.findSubstitutions({request: \'https://{{host}}/{{path1}}-action/\'});\n         */\n        findSubstitutions(): string[];\n        /**\n         * This function accepts a string followed by a number of variable sources as arguments. One or more variable\n         * sources can be provided and it will use the one that has the value in left-to-right order.\n         * @param str - -\n         * @param variables - -\n         */\n        static replaceSubstitutions(str: string, variables: VariableList | any | (VariableList | object)[]): string;\n        /**\n         * This function accepts an object followed by a number of variable sources as arguments. One or more variable\n         * sources can be provided and it will use the one that has the value in left-to-right order.\n         * @param obj - -\n         * @param variables - -\n         */\n        static replaceSubstitutionsIn(obj: any, variables: (VariableList | object)[]): any;\n        /**\n         * This function recursively traverses a variable and detects all instances of variable replacements\n         * within the string of the object\n         * @example\n         * // returns [\'host\', \'path1\']\n         * Property.findSubstitutions({request: \'https://{{host}}/{{path1}}-action/\'});\n         * @param obj - Any JS variable within which we are trying to discover {{variables}}\n         */\n        static findSubstitutions(obj: any): string[];\n    }\n\n    /**\n     * @example\n     * Create a new ProxyConfigList\n     * var ProxyConfigList = require(\'postman-collection\').ProxyConfigList,\n     *     myProxyConfig = new ProxyConfigList({}, [\n     *              {match: \'https://example.com/*\', host: \'proxy.com\', port: 8080, tunnel: true},\n     *              {match: \'http+https://example2.com/*\', host: \'proxy2.com\'},\n     *          ]);\n     * @param parent - -\n     * @param populate - The list of proxy objects\n     */\n    export class ProxyConfigList extends PropertyList {\n        constructor(parent: any, populate: any[]);\n        /**\n         * Matches and gets the proxy config for the particular url.\n         * @param [url] - The url for which the proxy config needs to be fetched\n         * @returns The matched proxyConfig object\n         */\n        resolve(url?: URL): ProxyConfig.definition;\n        /**\n         * Checks whether an object is a ProxyConfigList\n         * @param obj - -\n         */\n        static isProxyConfigList(obj: any): boolean;\n    }\n\n    export namespace ProxyConfig {\n        /**\n         * The following is the object structure accepted as constructor parameter while calling `new ProxyConfig(...)`. It is\n         * also the structure exported when Property.toJSON or Property.toObjectResolved is called on a\n         * Proxy instance.\n         * @example\n         * JSON definition of an example proxy object\n         * {\n         *     "match": "http+https://example.com/*",\n         *     "host": "proxy.com",\n         *     "port": "8080",\n         *     "tunnel": true,\n         *     "disabled": false,\n         *     "authenticate": true,\n         *     "username": "proxy_username",\n         *     "password": "proxy_password"\n         * }\n         * @property [match = \'http+https://*\\/*\'] - The match for which the proxy needs to be configured.\n         * @property [host = \'\'] - The proxy server url.\n         * @property [port = 8080] - The proxy server port number.\n         * @property [tunnel = false] - The tunneling option for the proxy request.\n         * @property [disabled = false] - To override the proxy for the particular url, you need to provide true.\n         * @property [authenticate = false] - To enable authentication for the proxy, you need to provide true.\n         * @property [username] - The proxy authentication username\n         * @property [password] - The proxy authentication password\n         */\n        type definition = {\n            match?: string;\n            host?: string;\n            port?: number;\n            tunnel?: boolean;\n            disabled?: boolean;\n            authenticate?: boolean;\n            username?: string;\n            password?: string;\n        };\n    }\n\n    /**\n     * A ProxyConfig definition that represents the proxy configuration for an url match.\n     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with\n     * all the variable references replaced by corresponding values.\n     * @example\n     * Create a new ProxyConfig\n     * var ProxyConfig = require(\'postman-collection\').ProxyConfig,\n     *     myProxyConfig = new ProxyConfig({\n     *          host: \'proxy.com\',\n     *          match: \'http+https://example.com/*\',\n     *          port: 8080,\n     *          tunnel: true,\n     *          disabled: false,\n     *          authenticate: true,\n     *          username: \'proxy_username\',\n     *          password: \'proxy_password\'\n     *     });\n     * @param [options] - Specifies object with props matches, server and tunnel.\n     */\n    export class ProxyConfig extends Property {\n        constructor(options?: ProxyConfig.definition);\n        /**\n         * The proxy server host or ip\n         */\n        static host: string;\n        /**\n         * The url mach for which the proxy has been associated with.\n         */\n        static match: string;\n        /**\n         * The proxy server port number\n         */\n        static port: number;\n        /**\n         * This represents whether the tunneling needs to done while proxying this request.\n         */\n        static tunnel: boolean;\n        /**\n         * Proxy bypass list\n         */\n        static bypass: UrlMatchPatternList;\n        /**\n         * Enable proxy authentication\n         */\n        static authenticate: boolean;\n        /**\n         * Proxy auth username\n         */\n        static username: string;\n        /**\n         * Proxy auth password\n         */\n        static password: string;\n        /**\n         * Updates the properties of the proxy object based on the options provided.\n         * @param options - The proxy object structure.\n         */\n        update(options: ProxyConfig.definition): void;\n        /**\n         * Updates the protocols in the match pattern\n         * @param protocols - The array of protocols\n         */\n        updateProtocols(protocols: string[]): void;\n        /**\n         * Tests the url string with the match provided.\n         * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n         * @param [urlStr] - The url string for which the proxy match needs to be done.\n         */\n        test(urlStr?: string): void;\n        /**\n         * Returns the proxy server url.\n         */\n        getProxyUrl(): string;\n        /**\n         * Returns the protocols supported.\n         */\n        getProtocols(): string[];\n        /**\n         * Check whether an object is an instance of PostmanItem.\n         * @param obj - -\n         */\n        static isProxyConfig(obj: any): boolean;\n    }\n\n    export namespace QueryParam {\n        /**\n         * @property key - The name ("key") of the query parameter.\n         * @property value - The value of the parameter.\n         */\n        type definition = {\n            key: string;\n            value: string;\n        };\n    }\n\n    /**\n     * Represents a URL query parameter, which can exist in request URL or POST data.\n     * @param options - Pass the initial definition of the query parameter. In case of\n     * string, the query parameter is parsed using QueryParam.parseSingle.\n     */\n    export class QueryParam extends Property {\n        constructor(options: FormParam.definition | string);\n        /**\n         * Converts the QueryParameter to a single param string.\n         */\n        toString(): string;\n        /**\n         * Updates the key and value of the query parameter\n         * @param param - -\n         * @param param.key - -\n         * @param [param.value] - -\n         */\n        update(param: {\n            key: string;\n            value?: string;\n        }): void;\n        /**\n         * Declare the list index key, so that property lists of query parameters work correctly\n         */\n        static _postman_propertyIndexKey: string;\n        /**\n         * Query params can have multiple values, so set this to true.\n         */\n        static _postman_propertyAllowsMultipleValues: boolean;\n        /**\n         * Parse a query string into an array of objects, where each object contains a key and a value.\n         * @param query - -\n         */\n        static parse(query: string): any[];\n        /**\n         * Parses a single query parameter.\n         * @param param - -\n         * @param idx - -\n         * @param all - array of all params, in case this is being called while parsing multiple params.\n         */\n        static parseSingle(param: string, idx: number, all: string[]): any;\n        /**\n         * Create a query string from array of parameters (or object of key-values).\n         * @param params - -\n         */\n        static unparse(params: any[] | any): string;\n        /**\n         * Takes a query param and converts to string\n         * @param obj - -\n         */\n        static unparseSingle(obj: any): string;\n    }\n\n    export namespace RequestAuth {\n        /**\n         * This defines the definition of the authentication method to be used.\n         * @example\n         * Sample auth definition for Basic Auth\n         * {\n         *   "type": "basic",\n         *   "basic": [\n         *     { "key": "username", "value": "postman" },\n         *     { "key": "password", "value": "secrets" }\n         *   ]\n         * }\n         * @property [type] - The Auth type to use. Check the names in AuthTypes\n         */\n        type definition = {\n            type?: string;\n        };\n    }\n\n    /**\n     * A Postman Auth definition that comprehensively represents different types of auth mechanisms available.\n     * @example\n     * Creating a request with two auth data and one selected\n     * var auth = new RequestAuth({\n     *   type: \'digest\',\n     *\n     *   basic: [\n     *     { key: "username", value: "postman" },\n     *     { key: "password", value: "secrets" }\n     *   ],\n     *   digest: [\n     *     { key: "nonce", value: "aef54cde" },\n     *     { key: "realm", value: "items.x" }\n     *   ]\n     * });\n     *\n     * // change the selected auth\n     * auth.use(\'basic\');\n     * @param options - Pass the initial definition of the Auth.\n     * @param [parent] - optionally pass the parent of this auth. aides variable resolution.\n     */\n    export class RequestAuth extends Property {\n        constructor(options: RequestAuth.definition, parent?: Property | PropertyList);\n        /**\n         * Update the parameters of a specific authentication type. If none is provided then it uses the one marked as to be\n         * used.\n         * @param options - -\n         * @param [type = this.type] - -\n         */\n        update(options: VariableList | any[] | any, type?: string): void;\n        /**\n         * Sets the authentication type to be used by this item.\n         * @param type - -\n         * @param options - note that options set here would replace all existing\n         * options for the particular auth\n         */\n        use(type: string, options: VariableList | any[] | any): void;\n        /**\n         * Returns the parameters of the selected auth type\n         */\n        parameters(): VariableList;\n        /**\n         * Clears the definition of an auth type.\n         * @param type - -\n         */\n        clear(type: string): void;\n        /**\n         * Determines whether an authentication type name is valid or not\n         * @param type - -\n         */\n        static isValidType(type: string): boolean;\n    }\n\n    export namespace RequestBody {\n        type definition = {\n            mode: string;\n            raw: string;\n            file: string;\n            graphql: any;\n            formdata: object[];\n            urlencoded: object[] | string;\n        };\n        /**\n         * MODES\n         */\n        enum MODES {\n            file = "file",\n            formdata = "formdata",\n            graphql = "graphql",\n            raw = "raw",\n            urlencoded = "urlencoded"\n        }\n    }\n\n    /**\n     * RequestBody holds data related to the request body. By default, it provides a nice wrapper for url-encoded,\n     * form-data, and raw types of request bodies.\n     * @param options - -\n     */\n    export class RequestBody extends PropertyBase {\n        constructor(options: any);\n        /**\n         * Set the content of this request data\n         * @param options - -\n         */\n        update(options: any): void;\n        /**\n         * Indicates the type of request data to use.\n         */\n        mode: string;\n        /**\n         * If the request has raw body data associated with it, the data is held in this field.\n         */\n        raw: string;\n        /**\n         * Any URL encoded body params go here.\n         */\n        urlencoded: PropertyList;\n        /**\n         * Form data parameters for this request are held in this field.\n         */\n        formdata: PropertyList;\n        /**\n         * Holds a reference to a file which should be read as the RequestBody. It can be a file path (when used\n         * with Node) or a unique ID (when used with the browser).\n         */\n        file: any;\n        /**\n         * If the request has raw graphql data associated with it, the data is held in this field.\n         */\n        graphql: any;\n        /**\n         * If the request has body Options associated with it, the data is held in this field.\n         */\n        options: any;\n        /**\n         * Indicates whether to include body in request or not.\n         */\n        disabled: boolean;\n        /**\n         * Stringifies and returns the request body.\n         */\n        toString(): any;\n        /**\n         * If the request body is set to a mode, but does not contain data, then we should not be sending it.\n         */\n        isEmpty(): boolean;\n        /**\n         * Convert the request body to JSON compatible plain object\n         */\n        toJSON(): any;\n    }\n\n    export namespace Request {\n        /**\n         * @property url - The URL of the request. This can be a Url.definition or a string.\n         * @property method - The request method, e.g: "GET" or "POST".\n         * @property header - The headers that should be sent as a part of this request.\n         * @property body - The request body definition.\n         * @property auth - The authentication/signing information for this request.\n         * @property proxy - The proxy information for this request.\n         * @property certificate - The certificate information for this request.\n         */\n        type definition = {\n            url: string | Url;\n            method: string;\n            header: Header.definition[];\n            body: RequestBody.definition;\n            auth: RequestAuth.definition;\n            proxy: ProxyConfig.definition;\n            certificate: Certificate.definition;\n        };\n    }\n\n    /**\n     * A Postman HTTP request object.\n     * @param options - -\n     */\n    export class Request extends Property {\n        constructor(options: Request.definition);\n        url: Url;\n        headers: HeaderList;\n        method: string;\n        /**\n         * Updates the different properties of the request.\n         * @param options - -\n         */\n        update(options: Request.definition): void;\n        body: RequestBody | undefined;\n        auth: RequestAuth;\n        proxy: ProxyConfig;\n        certificate: Certificate | undefined;\n        /**\n         * Sets authentication method for the request\n         * @param type - -\n         * @param [options] - -\n         */\n        authorizeUsing(type: string | RequestAuth.definition, options?: VariableList): void;\n        /**\n         * Returns an object where the key is a header name and value is the header value.\n         * @param [options] - -\n         * @param options.ignoreCase - When set to "true", will ensure that all the header keys are lower case.\n         * @param options.enabled - Only get the enabled headers\n         * @param options.multiValue - When set to "true", duplicate header values will be stored in an array\n         * @param options.sanitizeKeys - When set to "true", headers with falsy keys are removed\n         */\n        getHeaders(options?: {\n            ignoreCase: boolean;\n            enabled: boolean;\n            multiValue: boolean;\n            sanitizeKeys: boolean;\n        }): any;\n        /**\n         * Calls the given callback on each Header object contained within the request.\n         * @param callback - -\n         */\n        forEachHeader(callback: (...params: any[]) => any): void;\n        /**\n         * Adds a header to the PropertyList of headers.\n         * @param header - Can be a {Header} object, or a raw header object.\n         */\n        addHeader(header: Header | any): void;\n        /**\n         * Removes a header from the request.\n         * @param toRemove - A header object to remove, or a string containing the header key.\n         * @param options - -\n         * @param options.ignoreCase - If set to true, ignores case while removing the header.\n         */\n        removeHeader(toRemove: string | Header, options: {\n            ignoreCase: boolean;\n        }): void;\n        /**\n         * Updates or inserts the given header.\n         * @param header - -\n         */\n        upsertHeader(header: any): void;\n        /**\n         * Add query parameters to the request.\n         * @param params - -\n         */\n        addQueryParams(params: QueryParam[] | string): void;\n        /**\n         * Removes parameters passed in params.\n         * @param params - -\n         */\n        removeQueryParams(params: string | any[]): void;\n        /**\n         * Get the request size by computing the headers and body or using the\n         * actual content length header once the request is sent.\n         */\n        size(): any;\n        /**\n         * Converts the Request to a plain JavaScript object, which is also how the request is\n         * represented in a collection file.\n         */\n        toJSON(): any;\n        /**\n         * Creates a clone of this request\n         */\n        clone(): Request;\n        /**\n         * Check whether an object is an instance of ItemGroup.\n         * @param obj - -\n         */\n        static isRequest(obj: any): boolean;\n    }\n\n    export namespace Response {\n        /**\n         * @property code - define the response code\n         * @property [reason] - optionally, if the response has a non-standard response code reason, provide it here\n         */\n        type definition = {\n            code: number;\n            reason?: string;\n            header?: Header.definition[];\n            cookie?: Cookie.definition[];\n            body?: string;\n            stream?: Buffer | ArrayBuffer;\n            responseTime: number;\n        };\n        /**\n         * Returns the durations of each request phase in milliseconds\n         * @example\n         * Output\n         * Request.timingPhases(timings);\n         * {\n         *     prepare: Number,         // duration of request preparation\n         *     wait: Number,            // duration of socket initialization\n         *     dns: Number,             // duration of DNS lookup\n         *     tcp: Number,             // duration of TCP connection\n         *     secureHandshake: Number, // duration of secure handshake\n         *     firstByte: Number,       // duration of HTTP server response\n         *     download: Number,        // duration of HTTP download\n         *     process: Number,         // duration of response processing\n         *     total: Number            // duration entire HTTP round-trip\n         * }\n         * @property start - timestamp of the request sent from the client (in Unix Epoch milliseconds)\n         * @property offset - event timestamps in millisecond resolution relative to start\n         * @property offset.request - timestamp of the start of the request\n         * @property offset.socket - timestamp when the socket is assigned to the request\n         * @property offset.lookup - timestamp when the DNS has been resolved\n         * @property offset.connect - timestamp when the server acknowledges the TCP connection\n         * @property offset.secureConnect - timestamp when secure handshaking process is completed\n         * @property offset.response - timestamp when the first bytes are received from the server\n         * @property offset.end - timestamp when the last bytes of the response are received\n         * @property offset.done - timestamp when the response is received at the client\n         * @param timings - -\n         */\n        type timings = {\n            start: number;\n            offset: {\n                request: number;\n                socket: number;\n                lookup: number;\n                connect: number;\n                secureConnect: number;\n                response: number;\n                end: number;\n                done: number;\n            };\n        };\n        /**\n         * @property mimeType - sanitized mime type\n         * @property mimeFormat - format for the identified mime type\n         * @property charset - the normalized character set\n         * @property fileExtension - extension identified from the mime type\n         * @property fileName - file name extracted from disposition header\n         * @property contentType - sanitized content-type extracted from header\n         */\n        type ResponseContentInfo = {\n            mimeType: string;\n            mimeFormat: string;\n            charset: string;\n            fileExtension: string;\n            fileName: string;\n            contentType: string;\n        };\n    }\n\n    /**\n     * Response holds data related to the request body. By default, it provides a nice wrapper for url-encoded,\n     * form-data, and raw types of request bodies.\n     * @param options - -\n     */\n    export class Response extends Property {\n        constructor(options: Response.definition);\n        originalRequest: Request;\n        status: string;\n        code: number;\n        headers: HeaderList;\n        body: string;\n        cookies: CookieList;\n        /**\n         * Time taken for the request to complete.\n         */\n        responseTime: number;\n        /**\n         * Convert this response into a JSON serializable object. The _details meta property is omitted.\n         */\n        toJSON(): any;\n        /**\n         * Get the http response reason phrase based on the current response code.\n         */\n        reason(): string | undefined;\n        /**\n         * Get the response body as a string/text.\n         */\n        text(): string | undefined;\n        /**\n         * Get the response body as a JavaScript object. Note that it throws an error if the response is not a valid JSON\n         * @example\n         * // assuming that the response is stored in a collection instance `myCollection`\n         * var response = myCollection.items.one(\'some request\').responses.idx(0),\n         *     jsonBody;\n         * try {\n         *     jsonBody = response.json();\n         * }\n         * catch (e) {\n         *     console.log("There was an error parsing JSON ", e);\n         * }\n         * // log the root-level keys in the response JSON.\n         * console.log(\'All keys in json response: \' + Object.keys(json));\n         * @param [reviver] - -\n         * @param [strict = false] - Specify whether JSON parsing will be strict. This will fail on comments and BOM\n         */\n        json(reviver?: (...params: any[]) => any, strict?: boolean): any;\n        /**\n         * Get the JSON from response body that returns JSONP response.\n         * @param [reviver] - -\n         * @param [strict = false] - Specify whether JSON parsing will be strict. This will fail on comments and BOM\n         */\n        jsonp(reviver?: (...params: any[]) => any, strict?: boolean): void;\n        /**\n         * Extracts mime type, format, charset, extension and filename of the response content\n         * A fallback of default filename is given, if filename is not present in content-disposition header\n         * @returns - contentInfo for the response\n         */\n        contentInfo(): Response.ResponseContentInfo;\n        /**\n         * Converts the response to a dataURI that can be used for storage or serialisation. The data URI is formed using\n         * the following syntax `data:;baseg4, `.\n         */\n        dataURI(): string;\n        /**\n         * Get the response size by computing the same from content length header or using the actual response body.\n         */\n        size(): number;\n        /**\n         * Check whether an object is an instance of ItemGroup.\n         * @param obj - -\n         */\n        static isResponse(obj: any): boolean;\n        /**\n         * Converts the response object from the request module to the postman responseBody format\n         * @param response - The response object, as received from the request module\n         * @param cookies - -\n         * @returns The transformed responseBody\n         */\n        static createFromNode(response: any, cookies: any): any;\n    }\n\n    /**\n     * Postman scripts that are executed upon events on a collection  / request such as test and pre request.\n     * @param options - -\n     */\n    export class Script extends Property {\n        constructor(options: any);\n        /**\n         * Converts the script lines array to a single source string.\n         */\n        toSource(): string;\n        /**\n         * Updates the properties of a Script.\n         * @param [options] - -\n         * @param [options.type] - Script type\n         * @param [options.src] - Script source url\n         * @param [options.exec] - Script to execute\n         */\n        update(options?: {\n            type?: string;\n            src?: string;\n            exec?: string[] | string;\n        }): void;\n        type: string;\n        src: Url;\n        exec: string[];\n        /**\n         * Check whether an object is an instance of ItemGroup.\n         * @param obj - -\n         */\n        static isScript(obj: any): boolean;\n    }\n\n    /**\n     * Defines a URL.\n     * @param options - -\n     */\n    export class Url extends PropertyBase {\n        constructor(options: any | string);\n        /**\n         * Set a URL.\n         * @param url - -\n         */\n        update(url: string | any): void;\n        auth: any;\n        protocol: string;\n        port: string;\n        path: string[];\n        hash: string;\n        host: string[];\n        query: PropertyList;\n        variables: VariableList;\n        /**\n         * Add query parameters to the URL.\n         * @param params - Key value pairs to add to the URL.\n         */\n        addQueryParams(params: any | string): void;\n        /**\n         * Removes query parameters from the URL.\n         * @param params - Params should be an array of strings, or an array of\n         * actual query parameters, or a string containing the parameter key.\n         */\n        removeQueryParams(params: QueryParam[] | string[] | string): void;\n        /**\n         * Unparses a {PostmanUrl} into a string.\n         * @param [forceProtocol] - Forces the URL to have a protocol\n         */\n        toString(forceProtocol?: boolean): string;\n        /**\n         * Returns the request path, with a leading \'/\'.\n         * @param [unresolved = false] - -\n         */\n        getPath(unresolved?: boolean): string;\n        /**\n         * Returns the stringified query string for this URL.\n         */\n        getQueryString(): string;\n        /**\n         * Returns the complete path, including the query string.\n         * @example\n         * /something/postman?hi=notbye\n         */\n        getPathWithQuery(): any | string;\n        /**\n         * Returns the host part of the URL\n         */\n        getHost(): string;\n        /**\n         * Returns the host *and* port (if any), separated by a ":"\n         * @param [forcePort = false] - forces the port to be added even for the protocol default ones (89, 443)\n         */\n        getRemote(forcePort?: boolean): string;\n        /**\n         * Parses a string to a PostmanUrl, decomposing the URL into it\'s constituent parts,\n         * such as path, host, port, etc.\n         * @param url - -\n         */\n        static parse(url: string): any;\n        /**\n         * Checks whether an object is a Url\n         * @param obj - -\n         */\n        static isUrl(obj: any): boolean;\n    }\n\n    /**\n     * @param parent - -\n     * @param populate - -\n     */\n    export class VariableList extends PropertyList {\n        constructor(parent: Property, populate: any | any[]);\n        /**\n         * Replaces the variable tokens inside a string with its actual values.\n         * @param str - -\n         * @param [overrides] - additional objects to lookup for variable values\n         */\n        replace(str: string, overrides?: any): string;\n        /**\n         * Recursively replace strings in an object with instances of variables. Note that it clones the original object. If\n         * the `mutate` param is set to true, then it replaces the same object instead of creating a new one.\n         * @param obj - -\n         * @param [overrides] - additional objects to lookup for variable values\n         * @param [mutate = false] - -\n         */\n        substitute(obj: any[] | any, overrides?: object[], mutate?: boolean): any[] | any;\n        /**\n         * Using this function, one can sync the values of this variable list from a reference object.\n         * @param obj - -\n         * @param [track] - -\n         * @param [prune = true] - -\n         */\n        syncFromObject(obj: any, track?: boolean, prune?: boolean): any;\n        /**\n         * Transfer all variables from this list to an object\n         * @param [obj] - -\n         */\n        syncToObject(obj?: any): any;\n        /**\n         * Checks whether an object is a VariableList\n         * @param obj - -\n         */\n        static isVariableList(obj: any): boolean;\n    }\n\n    export namespace VariableScope {\n        /**\n         * Environment and Globals of postman is exported and imported in a specified data structure. This data structure can be\n         * passed on to the constructor parameter of VariableScope or VariableList to instantiate an instance of\n         * the same with pre-populated values from arguments.\n         * @example\n         * JSON definition of a VariableScope (environment, globals, etc)\n         * {\n         *   "name": "globals",\n         *   "values": [{\n         *     "key": "var-1",\n         *     "value": "value-1"\n         *   }, {\n         *     "key": "var-2",\n         *     "value": "value-2"\n         *   }]\n         * }\n         * @property [id] - ID of the scope\n         * @property [name] - A name of the scope\n         * @property [values] - A list of variables defined in an array in form of `{name:String,\n         * value:String}`\n         */\n        type definition = {\n            id?: string;\n            name?: string;\n            values?: Variable.definition[];\n        };\n    }\n\n    /**\n     * VariableScope is a representation of a list of variables in Postman, such as the environment variables or the\n     * globals. Using this object, it is easy to perform operations on this list of variables such as get a variable or\n     * set a variable.\n     * @example\n     * Load a environment from file, modify and save back\n     * var fs = require(\'fs\'), // assuming NodeJS\n     *     env,\n     *     sum;\n     *\n     * // load env from file assuming it has initial data\n     * env = new VariableScope(JSON.parse(fs.readFileSync(\'./my-postman-environment.postman_environment\').toString()));\n     *\n     * // get two variables and add them\n     * sum = env.get(\'one-var\') + env.get(\'another-var\');\n     *\n     * // save it back in environment and write to file\n     * env.set(\'sum\', sum, \'number\');\n     * fs.writeFileSync(\'./sum-of-vars.postman_environment\', JSON.stringify(env.toJSON()));\n     * @param definition - The constructor accepts an initial set of values for initialising\n     * the scope\n     * @param [layers] - Additional parent scopes to search for and resolve variables\n     */\n    export class VariableScope extends Property {\n        constructor(definition: VariableScope.definition, layers?: VariableList[]);\n        /**\n         * Converts a list of Variables into an object where key is `_postman_propertyIndexKey` and value is determined\n         * by the `valueOf` function\n         * @param excludeDisabled - -\n         * @param caseSensitive - -\n         */\n        toObject(excludeDisabled: boolean, caseSensitive: boolean): any;\n        /**\n         * Determines whether one particular variable is defined in this scope of variables.\n         * @param key - The name of the variable to check\n         * @returns - Returns true if an enabled variable with given key is present in current or parent scopes,\n         *                      false otherwise\n         */\n        has(key: string): boolean;\n        /**\n         * Fetches a variable from the current scope or from parent scopes if present.\n         * @param key - The name of the variable to get.\n         * @returns The value of the specified variable across scopes.\n         */\n        get(key: string): any;\n        /**\n         * Creates a new variable, or updates an existing one.\n         * @param key - The name of the variable to set.\n         * @param value - The value of the variable to be set.\n         * @param [type] - Optionally, the value of the variable can be set to a type\n         */\n        set(key: string, value: any, type?: Variable.types): void;\n        /**\n         * Removes the variable with the specified name.\n         * @param key - -\n         */\n        unset(key: string): void;\n        /**\n         * Removes *all* variables from the current scope. This is a destructive action.\n         */\n        clear(): void;\n        /**\n         * Replace all variable names with their values in the given template.\n         * @param template - A string or an object to replace variables in\n         * @returns The string or object with variables (if any) substituted with their values\n         */\n        replaceIn(template: string | any): string | any;\n        /**\n         * Enable mutation tracking.\n         * @param [options] - Options for Mutation Tracker. See MutationTracker\n         */\n        enableTracking(options?: MutationTracker.definition): void;\n        /**\n         * Disable mutation tracking.\n         */\n        disableTracking(): void;\n        /**\n         * Convert this variable scope into a JSON serialisable object. Useful to transport or store, environment and\n         * globals as a whole.\n         */\n        toJSON(): any;\n        /**\n         * Check whether an object is an instance of VariableScope.\n         * @param obj - -\n         */\n        static isVariableScope(obj: any): boolean;\n    }\n\n    export namespace Variable {\n        /**\n         * The object representation of a Variable consists the variable value and type. It also optionally includes the `id`\n         * and a friendly `name` of the variable. The `id` and the `name` of a variable is usually managed and used when a\n         * variable is made part of a VariableList instance.\n         * @example\n         * {\n         *     "id": "my-var-1",\n         *     "name": "MyFirstVariable",\n         *     "value": "Hello World",\n         *     "type": "string"\n         * }\n         * @property [value] - The value of the variable that will be stored and will be typecast to the `type`\n         * set in the variable or passed along in this parameter.\n         * @property [type] - The type of this variable from the list of types defined at Variable.types.\n         */\n        type definition = {\n            value?: any;\n            type?: string;\n        };\n        /**\n         * The possible supported types of a variable is defined here. The keys defined here are the possible values of\n         * Variable.type.\n         *\n         * Additional variable types can be supported by adding the type-casting function to this enumeration.\n         */\n        enum types {\n            /**\n             * When a variable\'s `type` is set to "string", it ensures that Variable.get converts the value of the\n             * variable to a string before returning the data.\n             */\n            string = "String",\n            /**\n             * A boolean type of variable can either be set to `true` or `false`. Any other value set is converted to\n             * Boolean when procured from Variable.get.\n             */\n            boolean = "Boolean",\n            /**\n             * A "number" type variable ensures that the value is always represented as a number. A non-number type value\n             * is returned as `NaN`.\n             */\n            number = "Number",\n            /**\n             * A "array" type value stores Array data format\n             */\n            array = "{\\"in\\":\\"\\",\\"out\\":\\"\\"}",\n            /**\n             * A "object" type value stores Object data format\n             */\n            object = "{\\"in\\":\\"\\",\\"out\\":\\"\\"}",\n            /**\n             * Free-form type of a value. This is the default for any variable, unless specified otherwise. It ensures that\n             * the variable can store data in any type and no conversion is done while using Variable.get.\n             */\n            any = "{\\"in\\":\\"\\",\\"out\\":\\"\\"}"\n        }\n    }\n\n    /**\n     * A variable inside a collection is similar to variables in any programming construct. The variable has an\n     * identifier name (provided by its id) and a value. A variable is optionally accompanied by a variable type. One\n     * or more variables can be associated with a collection and can be referred from anywhere else in the collection\n     * using the double-brace {{variable-id}} format. Properties can then use the `.toObjectResolved` function to\n     * procure an object representation of the property with all variable references replaced by corresponding values.\n     * @param [definition] - Specify the initial value and type of the variable.\n     */\n    export class Variable extends Property {\n        constructor(definition?: Variable.definition);\n        type: Variable.types;\n        value: any;\n        /**\n         * The name of the variable. This is used for referencing this variable from other locations and scripts\n         */\n        key: string;\n        /**\n         * Gets the value of the variable.\n         */\n        get(): Variable.types;\n        /**\n         * Sets the value of the variable.\n         * @param value - -\n         */\n        set(value: any): void;\n        /**\n         * An alias of this.get and this.set.\n         * @param [value] - -\n         */\n        valueOf(value?: any): any;\n        /**\n         * Returns the stringified value of the variable.\n         */\n        toString(): string;\n        /**\n         * Typecasts a value to the Variable.types of this Variable. Returns the value of the variable\n         * converted to the type specified in Variable.type.\n         * @param value - -\n         */\n        cast(value: any): any;\n        /**\n         * Sets or gets the type of the value.\n         * @param typeName - -\n         * @param _noCast - -\n         * @returns - returns the current type of the variable from the list of Variable.types\n         */\n        valueType(typeName: string, _noCast: boolean): string;\n        /**\n         * Updates the type and value of a variable from an object or JSON definition of the variable.\n         * @param options - -\n         */\n        update(options: Variable.definition): void;\n        /**\n         * @param obj - -\n         */\n        static isVariable(obj: any): boolean;\n        /**\n         * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a\n         * property is part of a PropertyList. For example, in a PropertyList of Headers, the ones\n         * that are disabled can be filtered out and not processed.\n         */\n        disabled: boolean;\n    }\n\n    export namespace Version {\n        type definition = any | string;\n    }\n\n    /**\n     * Defines a Version.\n     * @param definition - -\n     */\n    export class Version extends PropertyBase {\n        constructor(definition: Version.definition);\n        /**\n         * Set the version value as string or object with separate components of version\n         * @param value - -\n         */\n        set(value: any | string): void;\n        /**\n         * The raw URL string. If Version.set is called with a string parameter, the string is saved here\n         * before parsing various Version components.\n         */\n        raw: string;\n        major: string;\n        minor: string;\n        patch: string;\n        prerelease: string;\n        build: string;\n        string: string;\n    }\n\n    /**\n     * UrlMatchPattern is a list of UrlMatchPatterns.\n     * This allows you to test for any url over a list of match patterns.\n     * @example\n     * An example UrlMatchPatternList\n     * var matchPatternList = new UrlMatchPatternList([\'https://*.google.com/*\']);\n     * @param parent - -\n     * @param list - -\n     */\n    export class UrlMatchPatternList extends PropertyList {\n        constructor(parent: any, list: string[]);\n        /**\n         * Tests the url string with the match pattern list provided to see if it matches any of it.\n         * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n         * @param [urlStr] - The url string for which the proxy match needs to be done.\n         */\n        test(urlStr?: string): boolean;\n    }\n\n    export namespace UrlMatchPattern {\n        /**\n         * @property pattern - The url match pattern string\n         */\n        type definition = {\n            pattern: string;\n        };\n    }\n\n    /**\n     * UrlMatchPattern allows to create rules to define Urls to match for.\n     * It is based on Google\'s Match Pattern - https://developer.chrome.com/extensions/match_patterns\n     * @example\n     * An example UrlMatchPattern\n     * var matchPattern = new UrlMatchPattern(\'https://*.google.com/*\');\n     * @param options - -\n     */\n    export class UrlMatchPattern extends Property {\n        constructor(options: UrlMatchPattern.definition);\n        /**\n         * The url match pattern string\n         */\n        static pattern: string;\n        /**\n         * Assigns the given properties to the UrlMatchPattern.\n         * @param options - -\n         */\n        update(options: any): void;\n        /**\n         * Tests if the given protocol string, is allowed by the pattern.\n         * @param [protocol] - The protocol to be checked if the pattern allows.\n         */\n        testProtocol(protocol?: string): boolean;\n        /**\n         * Returns the protocols supported\n         */\n        getProtocols(): string[];\n        /**\n         * Tests if the given host string, is allowed by the pattern.\n         * @param [host] - The host to be checked if the pattern allows.\n         */\n        testHost(host?: string): boolean;\n        /**\n         * Tests if the current pattern allows the given port.\n         * @param port - The port to be checked if the pattern allows.\n         * @param protocol - Protocol to refer default port.\n         */\n        testPort(port: string, protocol: string): boolean;\n        /**\n         * Tests if the current pattern allows the given path.\n         * @param [path] - The path to be checked if the pattern allows.\n         */\n        testPath(path?: string): boolean;\n        /**\n         * Tests the url string with the match pattern provided.\n         * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching\n         * @param [urlStr] - The url string for which the proxy match needs to be done.\n         */\n        test(urlStr?: string): boolean;\n        /**\n         * Returns a string representation of the match pattern\n         * @returns pattern\n         */\n        toString(): string;\n        /**\n         * Returns the JSON representation.\n         */\n        toJSON(): any;\n        /**\n         * Multiple protocols in the match pattern should be separated by this string\n         */\n        static readonly PROTOCOL_DELIMITER: string;\n        /**\n         * String representation for matching all urls - \n         */\n        static readonly MATCH_ALL_URLS: string;\n    }\n\n}\n'}}]);