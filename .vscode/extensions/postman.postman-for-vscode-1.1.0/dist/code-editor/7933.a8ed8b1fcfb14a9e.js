"use strict";(self.webpackChunkcode_editor=self.webpackChunkcode_editor||[]).push([[7933],{19727:e=>{e.exports="/**\n * The `node:assert` module provides a set of assertion functions for verifying\n * invariants.\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/assert.js)\n */\ndeclare module \"assert\" {\n    /**\n     * An alias of {@link ok}.\n     * @since v0.5.9\n     * @param value The input that is checked for being truthy.\n     */\n    function assert(value: unknown, message?: string | Error): asserts value;\n    namespace assert {\n        /**\n         * Indicates the failure of an assertion. All errors thrown by the `node:assert`module will be instances of the `AssertionError` class.\n         */\n        class AssertionError extends Error {\n            /**\n             * Set to the `actual` argument for methods such as {@link assert.strictEqual()}.\n             */\n            actual: unknown;\n            /**\n             * Set to the `expected` argument for methods such as {@link assert.strictEqual()}.\n             */\n            expected: unknown;\n            /**\n             * Set to the passed in operator value.\n             */\n            operator: string;\n            /**\n             * Indicates if the message was auto-generated (`true`) or not.\n             */\n            generatedMessage: boolean;\n            /**\n             * Value is always `ERR_ASSERTION` to show that the error is an assertion error.\n             */\n            code: \"ERR_ASSERTION\";\n            constructor(options?: {\n                /** If provided, the error message is set to this value. */\n                message?: string | undefined;\n                /** The `actual` property on the error instance. */\n                actual?: unknown | undefined;\n                /** The `expected` property on the error instance. */\n                expected?: unknown | undefined;\n                /** The `operator` property on the error instance. */\n                operator?: string | undefined;\n                /** If provided, the generated stack trace omits frames before this function. */\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                stackStartFn?: Function | undefined;\n            });\n        }\n        /**\n         * This feature is deprecated and will be removed in a future version.\n         * Please consider using alternatives such as the `mock` helper function.\n         * @since v14.2.0, v12.19.0\n         * @deprecated Deprecated\n         */\n        class CallTracker {\n            /**\n             * The wrapper function is expected to be called exactly `exact` times. If the\n             * function has not been called exactly `exact` times when `tracker.verify()` is called, then `tracker.verify()` will throw an\n             * error.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func);\n             * ```\n             * @since v14.2.0, v12.19.0\n             * @param [fn='A no-op function']\n             * @param [exact=1]\n             * @return that wraps `fn`.\n             */\n            calls(exact?: number): () => void;\n            calls<Func extends (...args: any[]) => any>(fn?: Func, exact?: number): Func;\n            /**\n             * Example:\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             * const callsfunc = tracker.calls(func);\n             * callsfunc(1, 2, 3);\n             *\n             * assert.deepStrictEqual(tracker.getCalls(callsfunc),\n             *                        [{ thisArg: undefined, arguments: [1, 2, 3] }]);\n             * ```\n             * @since v18.8.0, v16.18.0\n             * @param fn\n             * @return An Array with all the calls to a tracked function.\n             */\n            getCalls(fn: Function): CallTrackerCall[];\n            /**\n             * The arrays contains information about the expected and actual number of calls of\n             * the functions that have not been called the expected number of times.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func, 2);\n             *\n             * // Returns an array containing information on callsfunc()\n             * console.log(tracker.report());\n             * // [\n             * //  {\n             * //    message: 'Expected the func function to be executed 2 time(s) but was\n             * //    executed 0 time(s).',\n             * //    actual: 0,\n             * //    expected: 2,\n             * //    operator: 'func',\n             * //    stack: stack trace\n             * //  }\n             * // ]\n             * ```\n             * @since v14.2.0, v12.19.0\n             * @return An Array of objects containing information about the wrapper functions returned by `calls`.\n             */\n            report(): CallTrackerReportInformation[];\n            /**\n             * Reset calls of the call tracker.\n             * If a tracked function is passed as an argument, the calls will be reset for it.\n             * If no arguments are passed, all tracked functions will be reset.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             * const callsfunc = tracker.calls(func);\n             *\n             * callsfunc();\n             * // Tracker was called once\n             * assert.strictEqual(tracker.getCalls(callsfunc).length, 1);\n             *\n             * tracker.reset(callsfunc);\n             * assert.strictEqual(tracker.getCalls(callsfunc).length, 0);\n             * ```\n             * @since v18.8.0, v16.18.0\n             * @param fn a tracked function to reset.\n             */\n            reset(fn?: Function): void;\n            /**\n             * Iterates through the list of functions passed to `tracker.calls()` and will throw an error for functions that\n             * have not been called the expected number of times.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func, 2);\n             *\n             * callsfunc();\n             *\n             * // Will throw an error since callsfunc() was only called once.\n             * tracker.verify();\n             * ```\n             * @since v14.2.0, v12.19.0\n             */\n            verify(): void;\n        }\n        interface CallTrackerCall {\n            thisArg: object;\n            arguments: unknown[];\n        }\n        interface CallTrackerReportInformation {\n            message: string;\n            /** The actual number of times the function was called. */\n            actual: number;\n            /** The number of times the function was expected to be called. */\n            expected: number;\n            /** The name of the function that is wrapped. */\n            operator: string;\n            /** A stack trace of the function. */\n            stack: object;\n        }\n        type AssertPredicate = RegExp | (new() => object) | ((thrown: unknown) => boolean) | object | Error;\n        /**\n         * Throws an `AssertionError` with the provided error message or a default\n         * error message. If the `message` parameter is an instance of an `Error` then\n         * it will be thrown instead of the `AssertionError`.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.fail();\n         * // AssertionError [ERR_ASSERTION]: Failed\n         *\n         * assert.fail('boom');\n         * // AssertionError [ERR_ASSERTION]: boom\n         *\n         * assert.fail(new TypeError('need array'));\n         * // TypeError: need array\n         * ```\n         *\n         * Using `assert.fail()` with more than two arguments is possible but deprecated.\n         * See below for further details.\n         * @since v0.1.21\n         * @param [message='Failed']\n         */\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(\n            actual: unknown,\n            expected: unknown,\n            message?: string | Error,\n            operator?: string,\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            stackStartFn?: Function,\n        ): never;\n        /**\n         * Tests if `value` is truthy. It is equivalent to`assert.equal(!!value, true, message)`.\n         *\n         * If `value` is not truthy, an `AssertionError` is thrown with a `message`property set equal to the value of the `message` parameter. If the `message`parameter is `undefined`, a default\n         * error message is assigned. If the `message`parameter is an instance of an `Error` then it will be thrown instead of the`AssertionError`.\n         * If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.\n         *\n         * Be aware that in the `repl` the error message will be different to the one\n         * thrown in a file! See below for further details.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.ok(true);\n         * // OK\n         * assert.ok(1);\n         * // OK\n         *\n         * assert.ok();\n         * // AssertionError: No value argument passed to `assert.ok()`\n         *\n         * assert.ok(false, 'it\\'s false');\n         * // AssertionError: it's false\n         *\n         * // In the repl:\n         * assert.ok(typeof 123 === 'string');\n         * // AssertionError: false == true\n         *\n         * // In a file (e.g. test.js):\n         * assert.ok(typeof 123 === 'string');\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(typeof 123 === 'string')\n         *\n         * assert.ok(false);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(false)\n         *\n         * assert.ok(0);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(0)\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * // Using `assert()` works the same:\n         * assert(0);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert(0)\n         * ```\n         * @since v0.1.21\n         */\n        function ok(value: unknown, message?: string | Error): asserts value;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link strictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link strictEqual} instead.\n         *\n         * Tests shallow, coercive equality between the `actual` and `expected` parameters\n         * using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled\n         * and treated as being identical if both sides are `NaN`.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * assert.equal(1, 1);\n         * // OK, 1 == 1\n         * assert.equal(1, '1');\n         * // OK, 1 == '1'\n         * assert.equal(NaN, NaN);\n         * // OK\n         *\n         * assert.equal(1, 2);\n         * // AssertionError: 1 == 2\n         * assert.equal({ a: { b: 1 } }, { a: { b: 1 } });\n         * // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }\n         * ```\n         *\n         * If the values are not equal, an `AssertionError` is thrown with a `message`property set equal to the value of the `message` parameter. If the `message`parameter is undefined, a default\n         * error message is assigned. If the `message`parameter is an instance of an `Error` then it will be thrown instead of the`AssertionError`.\n         * @since v0.1.21\n         */\n        function equal(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link notStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link notStrictEqual} instead.\n         *\n         * Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is\n         * specially handled and treated as being identical if both sides are `NaN`.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * assert.notEqual(1, 2);\n         * // OK\n         *\n         * assert.notEqual(1, 1);\n         * // AssertionError: 1 != 1\n         *\n         * assert.notEqual(1, '1');\n         * // AssertionError: 1 != '1'\n         * ```\n         *\n         * If the values are equal, an `AssertionError` is thrown with a `message`property set equal to the value of the `message` parameter. If the `message`parameter is undefined, a default error\n         * message is assigned. If the `message`parameter is an instance of an `Error` then it will be thrown instead of the`AssertionError`.\n         * @since v0.1.21\n         */\n        function notEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link deepStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link deepStrictEqual} instead.\n         *\n         * Tests for deep equality between the `actual` and `expected` parameters. Consider\n         * using {@link deepStrictEqual} instead. {@link deepEqual} can have\n         * surprising results.\n         *\n         * _Deep equality_ means that the enumerable \"own\" properties of child objects\n         * are also recursively evaluated by the following rules.\n         * @since v0.1.21\n         */\n        function deepEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link notDeepStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link notDeepStrictEqual} instead.\n         *\n         * Tests for any deep inequality. Opposite of {@link deepEqual}.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * const obj1 = {\n         *   a: {\n         *     b: 1,\n         *   },\n         * };\n         * const obj2 = {\n         *   a: {\n         *     b: 2,\n         *   },\n         * };\n         * const obj3 = {\n         *   a: {\n         *     b: 1,\n         *   },\n         * };\n         * const obj4 = { __proto__: obj1 };\n         *\n         * assert.notDeepEqual(obj1, obj1);\n         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n         *\n         * assert.notDeepEqual(obj1, obj2);\n         * // OK\n         *\n         * assert.notDeepEqual(obj1, obj3);\n         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n         *\n         * assert.notDeepEqual(obj1, obj4);\n         * // OK\n         * ```\n         *\n         * If the values are deeply equal, an `AssertionError` is thrown with a`message` property set equal to the value of the `message` parameter. If the`message` parameter is undefined, a default\n         * error message is assigned. If the`message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Tests strict equality between the `actual` and `expected` parameters as\n         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.strictEqual(1, 2);\n         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:\n         * //\n         * // 1 !== 2\n         *\n         * assert.strictEqual(1, 1);\n         * // OK\n         *\n         * assert.strictEqual('Hello foobar', 'Hello World!');\n         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:\n         * // + actual - expected\n         * //\n         * // + 'Hello foobar'\n         * // - 'Hello World!'\n         * //          ^\n         *\n         * const apples = 1;\n         * const oranges = 2;\n         * assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);\n         * // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2\n         *\n         * assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));\n         * // TypeError: Inputs are not identical\n         * ```\n         *\n         * If the values are not strictly equal, an `AssertionError` is thrown with a`message` property set equal to the value of the `message` parameter. If the`message` parameter is undefined, a\n         * default error message is assigned. If the`message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function strictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;\n        /**\n         * Tests strict inequality between the `actual` and `expected` parameters as\n         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.notStrictEqual(1, 2);\n         * // OK\n         *\n         * assert.notStrictEqual(1, 1);\n         * // AssertionError [ERR_ASSERTION]: Expected \"actual\" to be strictly unequal to:\n         * //\n         * // 1\n         *\n         * assert.notStrictEqual(1, '1');\n         * // OK\n         * ```\n         *\n         * If the values are strictly equal, an `AssertionError` is thrown with a`message` property set equal to the value of the `message` parameter. If the`message` parameter is undefined, a\n         * default error message is assigned. If the`message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Tests for deep equality between the `actual` and `expected` parameters.\n         * \"Deep\" equality means that the enumerable \"own\" properties of child objects\n         * are recursively evaluated also by the following rules.\n         * @since v1.2.0\n         */\n        function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;\n        /**\n         * Tests for deep strict inequality. Opposite of {@link deepStrictEqual}.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.notDeepStrictEqual({ a: 1 }, { a: '1' });\n         * // OK\n         * ```\n         *\n         * If the values are deeply and strictly equal, an `AssertionError` is thrown\n         * with a `message` property set equal to the value of the `message` parameter. If\n         * the `message` parameter is undefined, a default error message is assigned. If\n         * the `message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v1.2.0\n         */\n        function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Expects the function `fn` to throw an error.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,\n         * a validation object where each property will be tested for strict deep equality,\n         * or an instance of error where each property will be tested for strict deep\n         * equality including the non-enumerable `message` and `name` properties. When\n         * using an object, it is also possible to use a regular expression, when\n         * validating against a string property. See below for examples.\n         *\n         * If specified, `message` will be appended to the message provided by the`AssertionError` if the `fn` call fails to throw or in case the error validation\n         * fails.\n         *\n         * Custom validation object/error instance:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * const err = new TypeError('Wrong value');\n         * err.code = 404;\n         * err.foo = 'bar';\n         * err.info = {\n         *   nested: true,\n         *   baz: 'text',\n         * };\n         * err.reg = /abc/i;\n         *\n         * assert.throws(\n         *   () => {\n         *     throw err;\n         *   },\n         *   {\n         *     name: 'TypeError',\n         *     message: 'Wrong value',\n         *     info: {\n         *       nested: true,\n         *       baz: 'text',\n         *     },\n         *     // Only properties on the validation object will be tested for.\n         *     // Using nested objects requires all properties to be present. Otherwise\n         *     // the validation is going to fail.\n         *   },\n         * );\n         *\n         * // Using regular expressions to validate error properties:\n         * assert.throws(\n         *   () => {\n         *     throw err;\n         *   },\n         *   {\n         *     // The `name` and `message` properties are strings and using regular\n         *     // expressions on those will match against the string. If they fail, an\n         *     // error is thrown.\n         *     name: /^TypeError$/,\n         *     message: /Wrong/,\n         *     foo: 'bar',\n         *     info: {\n         *       nested: true,\n         *       // It is not possible to use regular expressions for nested properties!\n         *       baz: 'text',\n         *     },\n         *     // The `reg` property contains a regular expression and only if the\n         *     // validation object contains an identical regular expression, it is going\n         *     // to pass.\n         *     reg: /abc/i,\n         *   },\n         * );\n         *\n         * // Fails due to the different `message` and `name` properties:\n         * assert.throws(\n         *   () => {\n         *     const otherErr = new Error('Not found');\n         *     // Copy all enumerable properties from `err` to `otherErr`.\n         *     for (const [key, value] of Object.entries(err)) {\n         *       otherErr[key] = value;\n         *     }\n         *     throw otherErr;\n         *   },\n         *   // The error's `message` and `name` properties will also be checked when using\n         *   // an error as validation object.\n         *   err,\n         * );\n         * ```\n         *\n         * Validate instanceof using constructor:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   Error,\n         * );\n         * ```\n         *\n         * Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):\n         *\n         * Using a regular expression runs `.toString` on the error object, and will\n         * therefore also include the error name.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   /^Error: Wrong value$/,\n         * );\n         * ```\n         *\n         * Custom error validation:\n         *\n         * The function must return `true` to indicate all internal validations passed.\n         * It will otherwise fail with an `AssertionError`.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   (err) => {\n         *     assert(err instanceof Error);\n         *     assert(/value/.test(err));\n         *     // Avoid returning anything from validation functions besides `true`.\n         *     // Otherwise, it's not clear what part of the validation failed. Instead,\n         *     // throw an error about the specific validation that failed (as done in this\n         *     // example) and add as much helpful debugging information to that error as\n         *     // possible.\n         *     return true;\n         *   },\n         *   'unexpected error',\n         * );\n         * ```\n         *\n         * `error` cannot be a string. If a string is provided as the second\n         * argument, then `error` is assumed to be omitted and the string will be used for`message` instead. This can lead to easy-to-miss mistakes. Using the same\n         * message as the thrown error message is going to result in an`ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using\n         * a string as the second argument gets considered:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * function throwingFirst() {\n         *   throw new Error('First');\n         * }\n         *\n         * function throwingSecond() {\n         *   throw new Error('Second');\n         * }\n         *\n         * function notThrowing() {}\n         *\n         * // The second argument is a string and the input function threw an Error.\n         * // The first case will not throw as it does not match for the error message\n         * // thrown by the input function!\n         * assert.throws(throwingFirst, 'Second');\n         * // In the next example the message has no benefit over the message from the\n         * // error and since it is not clear if the user intended to actually match\n         * // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.\n         * assert.throws(throwingSecond, 'Second');\n         * // TypeError [ERR_AMBIGUOUS_ARGUMENT]\n         *\n         * // The string is only used (as message) in case the function does not throw:\n         * assert.throws(notThrowing, 'Second');\n         * // AssertionError [ERR_ASSERTION]: Missing expected exception: Second\n         *\n         * // If it was intended to match for the error message do this instead:\n         * // It does not throw because the error messages match.\n         * assert.throws(throwingSecond, /Second$/);\n         *\n         * // If the error message does not match, an AssertionError is thrown.\n         * assert.throws(throwingFirst, /Second$/);\n         * // AssertionError [ERR_ASSERTION]\n         * ```\n         *\n         * Due to the confusing error-prone notation, avoid a string as the second\n         * argument.\n         * @since v0.1.21\n         */\n        function throws(block: () => unknown, message?: string | Error): void;\n        function throws(block: () => unknown, error: AssertPredicate, message?: string | Error): void;\n        /**\n         * Asserts that the function `fn` does not throw an error.\n         *\n         * Using `assert.doesNotThrow()` is actually not useful because there\n         * is no benefit in catching an error and then rethrowing it. Instead, consider\n         * adding a comment next to the specific code path that should not throw and keep\n         * error messages as expressive as possible.\n         *\n         * When `assert.doesNotThrow()` is called, it will immediately call the `fn`function.\n         *\n         * If an error is thrown and it is the same type as that specified by the `error`parameter, then an `AssertionError` is thrown. If the error is of a\n         * different type, or if the `error` parameter is undefined, the error is\n         * propagated back to the caller.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation\n         * function. See {@link throws} for more details.\n         *\n         * The following, for instance, will throw the `TypeError` because there is no\n         * matching error type in the assertion:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   SyntaxError,\n         * );\n         * ```\n         *\n         * However, the following will result in an `AssertionError` with the message\n         * 'Got unwanted exception...':\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   TypeError,\n         * );\n         * ```\n         *\n         * If an `AssertionError` is thrown and a value is provided for the `message`parameter, the value of `message` will be appended to the `AssertionError` message:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   /Wrong value/,\n         *   'Whoops',\n         * );\n         * // Throws: AssertionError: Got unwanted exception: Whoops\n         * ```\n         * @since v0.1.21\n         */\n        function doesNotThrow(block: () => unknown, message?: string | Error): void;\n        function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error): void;\n        /**\n         * Throws `value` if `value` is not `undefined` or `null`. This is useful when\n         * testing the `error` argument in callbacks. The stack trace contains all frames\n         * from the error passed to `ifError()` including the potential new frames for`ifError()` itself.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.ifError(null);\n         * // OK\n         * assert.ifError(0);\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0\n         * assert.ifError('error');\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'\n         * assert.ifError(new Error());\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error\n         *\n         * // Create some random error frames.\n         * let err;\n         * (function errorFrame() {\n         *   err = new Error('test error');\n         * })();\n         *\n         * (function ifErrorFrame() {\n         *   assert.ifError(err);\n         * })();\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error\n         * //     at ifErrorFrame\n         * //     at errorFrame\n         * ```\n         * @since v0.1.97\n         */\n        function ifError(value: unknown): asserts value is null | undefined;\n        /**\n         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately\n         * calls the function and awaits the returned promise to complete. It will then\n         * check that the promise is rejected.\n         *\n         * If `asyncFn` is a function and it throws an error synchronously,`assert.rejects()` will return a rejected `Promise` with that error. If the\n         * function does not return a promise, `assert.rejects()` will return a rejected`Promise` with an `ERR_INVALID_RETURN_VALUE` error. In both cases the error\n         * handler is skipped.\n         *\n         * Besides the async nature to await the completion behaves identically to {@link throws}.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,\n         * an object where each property will be tested for, or an instance of error where\n         * each property will be tested for including the non-enumerable `message` and`name` properties.\n         *\n         * If specified, `message` will be the message provided by the `AssertionError` if the `asyncFn` fails to reject.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.rejects(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   {\n         *     name: 'TypeError',\n         *     message: 'Wrong value',\n         *   },\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.rejects(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   (err) => {\n         *     assert.strictEqual(err.name, 'TypeError');\n         *     assert.strictEqual(err.message, 'Wrong value');\n         *     return true;\n         *   },\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.rejects(\n         *   Promise.reject(new Error('Wrong value')),\n         *   Error,\n         * ).then(() => {\n         *   // ...\n         * });\n         * ```\n         *\n         * `error` cannot be a string. If a string is provided as the second\n         * argument, then `error` is assumed to be omitted and the string will be used for`message` instead. This can lead to easy-to-miss mistakes. Please read the\n         * example in {@link throws} carefully if using a string as the second\n         * argument gets considered.\n         * @since v10.0.0\n         */\n        function rejects(block: (() => Promise<unknown>) | Promise<unknown>, message?: string | Error): Promise<void>;\n        function rejects(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            error: AssertPredicate,\n            message?: string | Error,\n        ): Promise<void>;\n        /**\n         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately\n         * calls the function and awaits the returned promise to complete. It will then\n         * check that the promise is not rejected.\n         *\n         * If `asyncFn` is a function and it throws an error synchronously,`assert.doesNotReject()` will return a rejected `Promise` with that error. If\n         * the function does not return a promise, `assert.doesNotReject()` will return a\n         * rejected `Promise` with an `ERR_INVALID_RETURN_VALUE` error. In both cases\n         * the error handler is skipped.\n         *\n         * Using `assert.doesNotReject()` is actually not useful because there is little\n         * benefit in catching a rejection and then rejecting it again. Instead, consider\n         * adding a comment next to the specific code path that should not reject and keep\n         * error messages as expressive as possible.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation\n         * function. See {@link throws} for more details.\n         *\n         * Besides the async nature to await the completion behaves identically to {@link doesNotThrow}.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.doesNotReject(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   SyntaxError,\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))\n         *   .then(() => {\n         *     // ...\n         *   });\n         * ```\n         * @since v10.0.0\n         */\n        function doesNotReject(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            message?: string | Error,\n        ): Promise<void>;\n        function doesNotReject(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            error: AssertPredicate,\n            message?: string | Error,\n        ): Promise<void>;\n        /**\n         * Expects the `string` input to match the regular expression.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.match('I will fail', /pass/);\n         * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...\n         *\n         * assert.match(123, /pass/);\n         * // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.\n         *\n         * assert.match('I will pass', /pass/);\n         * // OK\n         * ```\n         *\n         * If the values do not match, or if the `string` argument is of another type than`string`, an `AssertionError` is thrown with a `message` property set equal\n         * to the value of the `message` parameter. If the `message` parameter is\n         * undefined, a default error message is assigned. If the `message` parameter is an\n         * instance of an `Error` then it will be thrown instead of the `AssertionError`.\n         * @since v13.6.0, v12.16.0\n         */\n        function match(value: string, regExp: RegExp, message?: string | Error): void;\n        /**\n         * Expects the `string` input not to match the regular expression.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotMatch('I will fail', /fail/);\n         * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...\n         *\n         * assert.doesNotMatch(123, /pass/);\n         * // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.\n         *\n         * assert.doesNotMatch('I will pass', /different/);\n         * // OK\n         * ```\n         *\n         * If the values do match, or if the `string` argument is of another type than`string`, an `AssertionError` is thrown with a `message` property set equal\n         * to the value of the `message` parameter. If the `message` parameter is\n         * undefined, a default error message is assigned. If the `message` parameter is an\n         * instance of an `Error` then it will be thrown instead of the `AssertionError`.\n         * @since v13.6.0, v12.16.0\n         */\n        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;\n        const strict:\n            & Omit<\n                typeof assert,\n                | \"equal\"\n                | \"notEqual\"\n                | \"deepEqual\"\n                | \"notDeepEqual\"\n                | \"ok\"\n                | \"strictEqual\"\n                | \"deepStrictEqual\"\n                | \"ifError\"\n                | \"strict\"\n            >\n            & {\n                (value: unknown, message?: string | Error): asserts value;\n                equal: typeof strictEqual;\n                notEqual: typeof notStrictEqual;\n                deepEqual: typeof deepStrictEqual;\n                notDeepEqual: typeof notDeepStrictEqual;\n                // Mapped types and assertion functions are incompatible?\n                // TS2775: Assertions require every name in the call target\n                // to be declared with an explicit type annotation.\n                ok: typeof ok;\n                strictEqual: typeof strictEqual;\n                deepStrictEqual: typeof deepStrictEqual;\n                ifError: typeof ifError;\n                strict: typeof strict;\n            };\n    }\n    export = assert;\n}\ndeclare module \"node:assert\" {\n    import assert = require(\"assert\");\n    export = assert;\n}\n"},26678:e=>{e.exports="/**\n * `Buffer` objects are used to represent a fixed-length sequence of bytes. Many\n * Node.js APIs support `Buffer`s.\n *\n * The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and\n * extends it with methods that cover additional use cases. Node.js APIs accept\n * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.\n *\n * While the `Buffer` class is available within the global scope, it is still\n * recommended to explicitly reference it via an import or require statement.\n *\n * ```js\n * import { Buffer } from 'node:buffer';\n *\n * // Creates a zero-filled Buffer of length 10.\n * const buf1 = Buffer.alloc(10);\n *\n * // Creates a Buffer of length 10,\n * // filled with bytes which all have the value `1`.\n * const buf2 = Buffer.alloc(10, 1);\n *\n * // Creates an uninitialized buffer of length 10.\n * // This is faster than calling Buffer.alloc() but the returned\n * // Buffer instance might contain old data that needs to be\n * // overwritten using fill(), write(), or other functions that fill the Buffer's\n * // contents.\n * const buf3 = Buffer.allocUnsafe(10);\n *\n * // Creates a Buffer containing the bytes [1, 2, 3].\n * const buf4 = Buffer.from([1, 2, 3]);\n *\n * // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries\n * // are all truncated using `(value &#x26; 255)` to fit into the range 0–255.\n * const buf5 = Buffer.from([257, 257.5, -255, '1']);\n *\n * // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':\n * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)\n * // [116, 195, 169, 115, 116] (in decimal notation)\n * const buf6 = Buffer.from('tést');\n *\n * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].\n * const buf7 = Buffer.from('tést', 'latin1');\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/buffer.js)\n */\ndeclare module \"buffer\" {\n    import { BinaryLike } from \"node:crypto\";\n    import { ReadableStream as WebReadableStream } from \"node:stream/web\";\n    /**\n     * This function returns `true` if `input` contains only valid UTF-8-encoded data,\n     * including the case in which `input` is empty.\n     *\n     * Throws if the `input` is a detached array buffer.\n     * @since v19.4.0, v18.14.0\n     * @param input The input to validate.\n     */\n    export function isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;\n    /**\n     * This function returns `true` if `input` contains only valid ASCII-encoded data,\n     * including the case in which `input` is empty.\n     *\n     * Throws if the `input` is a detached array buffer.\n     * @since v19.6.0, v18.15.0\n     * @param input The input to validate.\n     */\n    export function isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;\n    export const INSPECT_MAX_BYTES: number;\n    export const kMaxLength: number;\n    export const kStringMaxLength: number;\n    export const constants: {\n        MAX_LENGTH: number;\n        MAX_STRING_LENGTH: number;\n    };\n    export type TranscodeEncoding =\n        | \"ascii\"\n        | \"utf8\"\n        | \"utf-8\"\n        | \"utf16le\"\n        | \"utf-16le\"\n        | \"ucs2\"\n        | \"ucs-2\"\n        | \"latin1\"\n        | \"binary\";\n    /**\n     * Re-encodes the given `Buffer` or `Uint8Array` instance from one character\n     * encoding to another. Returns a new `Buffer` instance.\n     *\n     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if\n     * conversion from `fromEnc` to `toEnc` is not permitted.\n     *\n     * Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`,`'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.\n     *\n     * The transcoding process will use substitution characters if a given byte\n     * sequence cannot be adequately represented in the target encoding. For instance:\n     *\n     * ```js\n     * import { Buffer, transcode } from 'node:buffer';\n     *\n     * const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');\n     * console.log(newBuf.toString('ascii'));\n     * // Prints: '?'\n     * ```\n     *\n     * Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced\n     * with `?` in the transcoded `Buffer`.\n     * @since v7.1.0\n     * @param source A `Buffer` or `Uint8Array` instance.\n     * @param fromEnc The current encoding.\n     * @param toEnc To target encoding.\n     */\n    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;\n    export const SlowBuffer: {\n        /** @deprecated since v6.0.0, use `Buffer.allocUnsafeSlow()` */\n        new(size: number): Buffer;\n        prototype: Buffer;\n    };\n    /**\n     * Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using\n     * a prior call to `URL.createObjectURL()`.\n     * @since v16.7.0\n     * @experimental\n     * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.\n     */\n    export function resolveObjectURL(id: string): Blob | undefined;\n    export { Buffer };\n    /**\n     * @experimental\n     */\n    export interface BlobOptions {\n        /**\n         * @default 'utf8'\n         */\n        encoding?: BufferEncoding | undefined;\n        /**\n         * The Blob content-type. The intent is for `type` to convey\n         * the MIME media type of the data, however no validation of the type format\n         * is performed.\n         */\n        type?: string | undefined;\n    }\n    /**\n     * A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across\n     * multiple worker threads.\n     * @since v15.7.0, v14.18.0\n     */\n    export class Blob {\n        /**\n         * The total size of the `Blob` in bytes.\n         * @since v15.7.0, v14.18.0\n         */\n        readonly size: number;\n        /**\n         * The content-type of the `Blob`.\n         * @since v15.7.0, v14.18.0\n         */\n        readonly type: string;\n        /**\n         * Creates a new `Blob` object containing a concatenation of the given sources.\n         *\n         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into\n         * the 'Blob' and can therefore be safely modified after the 'Blob' is created.\n         *\n         * String sources are also copied into the `Blob`.\n         */\n        constructor(sources: Array<BinaryLike | Blob>, options?: BlobOptions);\n        /**\n         * Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of\n         * the `Blob` data.\n         * @since v15.7.0, v14.18.0\n         */\n        arrayBuffer(): Promise<ArrayBuffer>;\n        /**\n         * Creates and returns a new `Blob` containing a subset of this `Blob` objects\n         * data. The original `Blob` is not altered.\n         * @since v15.7.0, v14.18.0\n         * @param start The starting index.\n         * @param end The ending index.\n         * @param type The content-type for the new `Blob`\n         */\n        slice(start?: number, end?: number, type?: string): Blob;\n        /**\n         * Returns a promise that fulfills with the contents of the `Blob` decoded as a\n         * UTF-8 string.\n         * @since v15.7.0, v14.18.0\n         */\n        text(): Promise<string>;\n        /**\n         * Returns a new `ReadableStream` that allows the content of the `Blob` to be read.\n         * @since v16.7.0\n         */\n        stream(): WebReadableStream;\n    }\n    export interface FileOptions {\n        /**\n         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be\n         * converted to the platform native line-ending as specified by `require('node:os').EOL`.\n         */\n        endings?: \"native\" | \"transparent\";\n        /** The File content-type. */\n        type?: string;\n        /** The last modified date of the file. `Default`: Date.now(). */\n        lastModified?: number;\n    }\n    /**\n     * A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files.\n     * @since v19.2.0, v18.13.0\n     */\n    export class File extends Blob {\n        constructor(sources: Array<BinaryLike | Blob>, fileName: string, options?: FileOptions);\n        /**\n         * The name of the `File`.\n         * @since v19.2.0, v18.13.0\n         */\n        readonly name: string;\n        /**\n         * The last modified date of the `File`.\n         * @since v19.2.0, v18.13.0\n         */\n        readonly lastModified: number;\n    }\n    export import atob = globalThis.atob;\n    export import btoa = globalThis.btoa;\n    import { Blob as NodeBlob } from \"buffer\";\n    // This conditional type will be the existing global Blob in a browser, or\n    // the copy below in a Node environment.\n    type __Blob = typeof globalThis extends { onmessage: any; Blob: any } ? {} : NodeBlob;\n    global {\n        namespace NodeJS {\n            export { BufferEncoding };\n        }\n        // Buffer class\n        type BufferEncoding =\n            | \"ascii\"\n            | \"utf8\"\n            | \"utf-8\"\n            | \"utf16le\"\n            | \"utf-16le\"\n            | \"ucs2\"\n            | \"ucs-2\"\n            | \"base64\"\n            | \"base64url\"\n            | \"latin1\"\n            | \"binary\"\n            | \"hex\";\n        type WithImplicitCoercion<T> =\n            | T\n            | {\n                valueOf(): T;\n            };\n        /**\n         * Raw data is stored in instances of the Buffer class.\n         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n         * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'\n         */\n        interface BufferConstructor {\n            /**\n             * Allocates a new buffer containing the given {str}.\n             *\n             * @param str String to store in buffer.\n             * @param encoding encoding to use, optional.  Default is 'utf8'\n             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n             */\n            new(str: string, encoding?: BufferEncoding): Buffer;\n            /**\n             * Allocates a new buffer of {size} octets.\n             *\n             * @param size count of octets to allocate.\n             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n             */\n            new(size: number): Buffer;\n            /**\n             * Allocates a new buffer containing the given {array} of octets.\n             *\n             * @param array The octets to store.\n             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n             */\n            new(array: Uint8Array): Buffer;\n            /**\n             * Produces a Buffer backed by the same allocated memory as\n             * the given {ArrayBuffer}/{SharedArrayBuffer}.\n             *\n             * @param arrayBuffer The ArrayBuffer with which to share memory.\n             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n             */\n            new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;\n            /**\n             * Allocates a new buffer containing the given {array} of octets.\n             *\n             * @param array The octets to store.\n             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n             */\n            new(array: readonly any[]): Buffer;\n            /**\n             * Copies the passed {buffer} data onto a new {Buffer} instance.\n             *\n             * @param buffer The buffer to copy.\n             * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n             */\n            new(buffer: Buffer): Buffer;\n            /**\n             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.\n             * Array entries outside that range will be truncated to fit into it.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.\n             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n             * ```\n             *\n             * If `array` is an `Array`\\-like object (that is, one with a `length` property of\n             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or\n             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an`Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use `Buffer.copyBytesFrom()`.\n             *\n             * A `TypeError` will be thrown if `array` is not an `Array` or another type\n             * appropriate for `Buffer.from()` variants.\n             *\n             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does.\n             * @since v5.10.0\n             */\n            from(\n                arrayBuffer: WithImplicitCoercion<ArrayBuffer | SharedArrayBuffer>,\n                byteOffset?: number,\n                length?: number,\n            ): Buffer;\n            /**\n             * Creates a new Buffer using the passed {data}\n             * @param data data to create a new Buffer\n             */\n            from(data: Uint8Array | readonly number[]): Buffer;\n            from(data: WithImplicitCoercion<Uint8Array | readonly number[] | string>): Buffer;\n            /**\n             * Creates a new Buffer containing the given JavaScript string {str}.\n             * If provided, the {encoding} parameter identifies the character encoding.\n             * If not provided, {encoding} defaults to 'utf8'.\n             */\n            from(\n                str:\n                    | WithImplicitCoercion<string>\n                    | {\n                        [Symbol.toPrimitive](hint: \"string\"): string;\n                    },\n                encoding?: BufferEncoding,\n            ): Buffer;\n            /**\n             * Creates a new Buffer using the passed {data}\n             * @param values to create a new Buffer\n             */\n            of(...items: number[]): Buffer;\n            /**\n             * Returns `true` if `obj` is a `Buffer`, `false` otherwise.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * Buffer.isBuffer(Buffer.alloc(10)); // true\n             * Buffer.isBuffer(Buffer.from('foo')); // true\n             * Buffer.isBuffer('a string'); // false\n             * Buffer.isBuffer([]); // false\n             * Buffer.isBuffer(new Uint8Array(1024)); // false\n             * ```\n             * @since v0.1.101\n             */\n            isBuffer(obj: any): obj is Buffer;\n            /**\n             * Returns `true` if `encoding` is the name of a supported character encoding,\n             * or `false` otherwise.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * console.log(Buffer.isEncoding('utf8'));\n             * // Prints: true\n             *\n             * console.log(Buffer.isEncoding('hex'));\n             * // Prints: true\n             *\n             * console.log(Buffer.isEncoding('utf/8'));\n             * // Prints: false\n             *\n             * console.log(Buffer.isEncoding(''));\n             * // Prints: false\n             * ```\n             * @since v0.9.1\n             * @param encoding A character encoding name to check.\n             */\n            isEncoding(encoding: string): encoding is BufferEncoding;\n            /**\n             * Returns the byte length of a string when encoded using `encoding`.\n             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account\n             * for the encoding that is used to convert the string into bytes.\n             *\n             * For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.\n             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the\n             * return value might be greater than the length of a `Buffer` created from the\n             * string.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const str = '\\u00bd + \\u00bc = \\u00be';\n             *\n             * console.log(`${str}: ${str.length} characters, ` +\n             *             `${Buffer.byteLength(str, 'utf8')} bytes`);\n             * // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\n             * ```\n             *\n             * When `string` is a\n             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-\n             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-\n             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.\n             * @since v0.1.90\n             * @param string A value to calculate the length of.\n             * @param [encoding='utf8'] If `string` is a string, this is its encoding.\n             * @return The number of bytes contained within `string`.\n             */\n            byteLength(\n                string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n                encoding?: BufferEncoding,\n            ): number;\n            /**\n             * Returns a new `Buffer` which is the result of concatenating all the `Buffer`instances in the `list` together.\n             *\n             * If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned.\n             *\n             * If `totalLength` is not provided, it is calculated from the `Buffer` instances\n             * in `list` by adding their lengths.\n             *\n             * If `totalLength` is provided, it is coerced to an unsigned integer. If the\n             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is\n             * truncated to `totalLength`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create a single `Buffer` from a list of three `Buffer` instances.\n             *\n             * const buf1 = Buffer.alloc(10);\n             * const buf2 = Buffer.alloc(14);\n             * const buf3 = Buffer.alloc(18);\n             * const totalLength = buf1.length + buf2.length + buf3.length;\n             *\n             * console.log(totalLength);\n             * // Prints: 42\n             *\n             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n             *\n             * console.log(bufA);\n             * // Prints: <Buffer 00 00 00 00 ...>\n             * console.log(bufA.length);\n             * // Prints: 42\n             * ```\n             *\n             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.\n             * @since v0.7.11\n             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.\n             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.\n             */\n            concat(list: readonly Uint8Array[], totalLength?: number): Buffer;\n            /**\n             * Copies the underlying memory of `view` into a new `Buffer`.\n             *\n             * ```js\n             * const u16 = new Uint16Array([0, 0xffff]);\n             * const buf = Buffer.copyBytesFrom(u16, 1, 1);\n             * u16[1] = 0;\n             * console.log(buf.length); // 2\n             * console.log(buf[0]); // 255\n             * console.log(buf[1]); // 255\n             * ```\n             * @since v19.8.0\n             * @param view The {TypedArray} to copy.\n             * @param [offset=': 0'] The starting offset within `view`.\n             * @param [length=view.length - offset] The number of elements from `view` to copy.\n             */\n            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer;\n            /**\n             * Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from('1234');\n             * const buf2 = Buffer.from('0123');\n             * const arr = [buf1, buf2];\n             *\n             * console.log(arr.sort(Buffer.compare));\n             * // Prints: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]\n             * // (This result is equal to: [buf2, buf1].)\n             * ```\n             * @since v0.11.13\n             * @return Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.\n             */\n            compare(buf1: Uint8Array, buf2: Uint8Array): -1 | 0 | 1;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(5);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 00 00 00 00 00>\n             * ```\n             *\n             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.\n             *\n             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(5, 'a');\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 61 61 61 61 61>\n             * ```\n             *\n             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be\n             * initialized by calling `buf.fill(fill, encoding)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n             * ```\n             *\n             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance\n             * contents will never contain sensitive data from previous allocations, including\n             * data that might not have been allocated for `Buffer`s.\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             * @since v5.10.0\n             * @param size The desired length of the new `Buffer`.\n             * @param [fill=0] A value to pre-fill the new `Buffer` with.\n             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.\n             */\n            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.\n             *\n             * The underlying memory for `Buffer` instances created in this way is _not_\n             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(10);\n             *\n             * console.log(buf);\n             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>\n             *\n             * buf.fill(0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>\n             * ```\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             *\n             * The `Buffer` module pre-allocates an internal `Buffer` instance of\n             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,\n             * and `Buffer.concat()` only when `size` is less than`Buffer.poolSize >>> 1` (floor of `Buffer.poolSize` divided by two).\n             *\n             * Use of this pre-allocated internal memory pool is a key difference between\n             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.\n             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less\n             * than or equal to half `Buffer.poolSize`. The\n             * difference is subtle but can be important when an application requires the\n             * additional performance that `Buffer.allocUnsafe()` provides.\n             * @since v5.10.0\n             * @param size The desired length of the new `Buffer`.\n             */\n            allocUnsafe(size: number): Buffer;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if\n             * `size` is 0.\n             *\n             * The underlying memory for `Buffer` instances created in this way is _not_\n             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize\n             * such `Buffer` instances with zeroes.\n             *\n             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,\n             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This\n             * allows applications to avoid the garbage collection overhead of creating many\n             * individually allocated `Buffer` instances. This approach improves both\n             * performance and memory usage by eliminating the need to track and clean up as\n             * many individual `ArrayBuffer` objects.\n             *\n             * However, in the case where a developer may need to retain a small chunk of\n             * memory from a pool for an indeterminate amount of time, it may be appropriate\n             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and\n             * then copying out the relevant bits.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Need to keep around a few small chunks of memory.\n             * const store = [];\n             *\n             * socket.on('readable', () => {\n             *   let data;\n             *   while (null !== (data = readable.read())) {\n             *     // Allocate for retained data.\n             *     const sb = Buffer.allocUnsafeSlow(10);\n             *\n             *     // Copy the data into the new allocation.\n             *     data.copy(sb, 0, 0, 10);\n             *\n             *     store.push(sb);\n             *   }\n             * });\n             * ```\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             * @since v5.12.0\n             * @param size The desired length of the new `Buffer`.\n             */\n            allocUnsafeSlow(size: number): Buffer;\n            /**\n             * This is the size (in bytes) of pre-allocated internal `Buffer` instances used\n             * for pooling. This value may be modified.\n             * @since v0.11.3\n             */\n            poolSize: number;\n        }\n        interface Buffer extends Uint8Array {\n            /**\n             * Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did\n             * not contain enough space to fit the entire string, only part of `string` will be\n             * written. However, partially encoded characters will not be written.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(256);\n             *\n             * const len = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\n             *\n             * console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n             * // Prints: 12 bytes: ½ + ¼ = ¾\n             *\n             * const buffer = Buffer.alloc(10);\n             *\n             * const length = buffer.write('abcd', 8);\n             *\n             * console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);\n             * // Prints: 2 bytes : ab\n             * ```\n             * @since v0.1.90\n             * @param string String to write to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write `string`.\n             * @param [length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).\n             * @param [encoding='utf8'] The character encoding of `string`.\n             * @return Number of bytes written.\n             */\n            write(string: string, encoding?: BufferEncoding): number;\n            write(string: string, offset: number, encoding?: BufferEncoding): number;\n            write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;\n            /**\n             * Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.\n             *\n             * If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,\n             * then each invalid byte is replaced with the replacement character `U+FFFD`.\n             *\n             * The maximum length of a string instance (in UTF-16 code units) is available\n             * as {@link constants.MAX_STRING_LENGTH}.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.allocUnsafe(26);\n             *\n             * for (let i = 0; i < 26; i++) {\n             *   // 97 is the decimal ASCII value for 'a'.\n             *   buf1[i] = i + 97;\n             * }\n             *\n             * console.log(buf1.toString('utf8'));\n             * // Prints: abcdefghijklmnopqrstuvwxyz\n             * console.log(buf1.toString('utf8', 0, 5));\n             * // Prints: abcde\n             *\n             * const buf2 = Buffer.from('tést');\n             *\n             * console.log(buf2.toString('hex'));\n             * // Prints: 74c3a97374\n             * console.log(buf2.toString('utf8', 0, 3));\n             * // Prints: té\n             * console.log(buf2.toString(undefined, 0, 3));\n             * // Prints: té\n             * ```\n             * @since v0.1.90\n             * @param [encoding='utf8'] The character encoding to use.\n             * @param [start=0] The byte offset to start decoding at.\n             * @param [end=buf.length] The byte offset to stop decoding at (not inclusive).\n             */\n            toString(encoding?: BufferEncoding, start?: number, end?: number): string;\n            /**\n             * Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls\n             * this function when stringifying a `Buffer` instance.\n             *\n             * `Buffer.from()` accepts objects in the format returned from this method.\n             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\n             * const json = JSON.stringify(buf);\n             *\n             * console.log(json);\n             * // Prints: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n             *\n             * const copy = JSON.parse(json, (key, value) => {\n             *   return value &#x26;&#x26; value.type === 'Buffer' ?\n             *     Buffer.from(value) :\n             *     value;\n             * });\n             *\n             * console.log(copy);\n             * // Prints: <Buffer 01 02 03 04 05>\n             * ```\n             * @since v0.9.2\n             */\n            toJSON(): {\n                type: \"Buffer\";\n                data: number[];\n            };\n            /**\n             * Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from('ABC');\n             * const buf2 = Buffer.from('414243', 'hex');\n             * const buf3 = Buffer.from('ABCD');\n             *\n             * console.log(buf1.equals(buf2));\n             * // Prints: true\n             * console.log(buf1.equals(buf3));\n             * // Prints: false\n             * ```\n             * @since v0.11.13\n             * @param otherBuffer A `Buffer` or {@link Uint8Array} with which to compare `buf`.\n             */\n            equals(otherBuffer: Uint8Array): boolean;\n            /**\n             * Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.\n             * Comparison is based on the actual sequence of bytes in each `Buffer`.\n             *\n             * * `0` is returned if `target` is the same as `buf`\n             * * `1` is returned if `target` should come _before_`buf` when sorted.\n             * * `-1` is returned if `target` should come _after_`buf` when sorted.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from('ABC');\n             * const buf2 = Buffer.from('BCD');\n             * const buf3 = Buffer.from('ABCD');\n             *\n             * console.log(buf1.compare(buf1));\n             * // Prints: 0\n             * console.log(buf1.compare(buf2));\n             * // Prints: -1\n             * console.log(buf1.compare(buf3));\n             * // Prints: -1\n             * console.log(buf2.compare(buf1));\n             * // Prints: 1\n             * console.log(buf2.compare(buf3));\n             * // Prints: 1\n             * console.log([buf1, buf2, buf3].sort(Buffer.compare));\n             * // Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]\n             * // (This result is equal to: [buf1, buf3, buf2].)\n             * ```\n             *\n             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n             *\n             * console.log(buf1.compare(buf2, 5, 9, 0, 4));\n             * // Prints: 0\n             * console.log(buf1.compare(buf2, 0, 6, 4));\n             * // Prints: -1\n             * console.log(buf1.compare(buf2, 5, 6, 5));\n             * // Prints: 1\n             * ```\n             *\n             * `ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`,`targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.\n             * @since v0.11.13\n             * @param target A `Buffer` or {@link Uint8Array} with which to compare `buf`.\n             * @param [targetStart=0] The offset within `target` at which to begin comparison.\n             * @param [targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).\n             * @param [sourceStart=0] The offset within `buf` at which to begin comparison.\n             * @param [sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).\n             */\n            compare(\n                target: Uint8Array,\n                targetStart?: number,\n                targetEnd?: number,\n                sourceStart?: number,\n                sourceEnd?: number,\n            ): -1 | 0 | 1;\n            /**\n             * Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.\n             *\n             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available\n             * for all TypedArrays, including Node.js `Buffer`s, although it takes\n             * different function arguments.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create two `Buffer` instances.\n             * const buf1 = Buffer.allocUnsafe(26);\n             * const buf2 = Buffer.allocUnsafe(26).fill('!');\n             *\n             * for (let i = 0; i < 26; i++) {\n             *   // 97 is the decimal ASCII value for 'a'.\n             *   buf1[i] = i + 97;\n             * }\n             *\n             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.\n             * buf1.copy(buf2, 8, 16, 20);\n             * // This is equivalent to:\n             * // buf2.set(buf1.subarray(16, 20), 8);\n             *\n             * console.log(buf2.toString('ascii', 0, 25));\n             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n             * ```\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create a `Buffer` and copy data from one region to an overlapping region\n             * // within the same `Buffer`.\n             *\n             * const buf = Buffer.allocUnsafe(26);\n             *\n             * for (let i = 0; i < 26; i++) {\n             *   // 97 is the decimal ASCII value for 'a'.\n             *   buf[i] = i + 97;\n             * }\n             *\n             * buf.copy(buf, 0, 4, 10);\n             *\n             * console.log(buf.toString());\n             * // Prints: efghijghijklmnopqrstuvwxyz\n             * ```\n             * @since v0.1.90\n             * @param target A `Buffer` or {@link Uint8Array} to copy into.\n             * @param [targetStart=0] The offset within `target` at which to begin writing.\n             * @param [sourceStart=0] The offset within `buf` from which to begin copying.\n             * @param [sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).\n             * @return The number of bytes copied.\n             */\n            copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n            /**\n             * Returns a new `Buffer` that references the same memory as the original, but\n             * offset and cropped by the `start` and `end` indices.\n             *\n             * This method is not compatible with the `Uint8Array.prototype.slice()`,\n             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * const copiedBuf = Uint8Array.prototype.slice.call(buf);\n             * copiedBuf[0]++;\n             * console.log(copiedBuf.toString());\n             * // Prints: cuffer\n             *\n             * console.log(buf.toString());\n             * // Prints: buffer\n             *\n             * // With buf.slice(), the original buffer is modified.\n             * const notReallyCopiedBuf = buf.slice();\n             * notReallyCopiedBuf[0]++;\n             * console.log(notReallyCopiedBuf.toString());\n             * // Prints: cuffer\n             * console.log(buf.toString());\n             * // Also prints: cuffer (!)\n             * ```\n             * @since v0.3.0\n             * @deprecated Use `subarray` instead.\n             * @param [start=0] Where the new `Buffer` will start.\n             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).\n             */\n            slice(start?: number, end?: number): Buffer;\n            /**\n             * Returns a new `Buffer` that references the same memory as the original, but\n             * offset and cropped by the `start` and `end` indices.\n             *\n             * Specifying `end` greater than `buf.length` will return the same result as\n             * that of `end` equal to `buf.length`.\n             *\n             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n             *\n             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n             * // from the original `Buffer`.\n             *\n             * const buf1 = Buffer.allocUnsafe(26);\n             *\n             * for (let i = 0; i < 26; i++) {\n             *   // 97 is the decimal ASCII value for 'a'.\n             *   buf1[i] = i + 97;\n             * }\n             *\n             * const buf2 = buf1.subarray(0, 3);\n             *\n             * console.log(buf2.toString('ascii', 0, buf2.length));\n             * // Prints: abc\n             *\n             * buf1[0] = 33;\n             *\n             * console.log(buf2.toString('ascii', 0, buf2.length));\n             * // Prints: !bc\n             * ```\n             *\n             * Specifying negative indexes causes the slice to be generated relative to the\n             * end of `buf` rather than the beginning.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * console.log(buf.subarray(-6, -1).toString());\n             * // Prints: buffe\n             * // (Equivalent to buf.subarray(0, 5).)\n             *\n             * console.log(buf.subarray(-6, -2).toString());\n             * // Prints: buff\n             * // (Equivalent to buf.subarray(0, 4).)\n             *\n             * console.log(buf.subarray(-5, -2).toString());\n             * // Prints: uff\n             * // (Equivalent to buf.subarray(1, 4).)\n             * ```\n             * @since v3.0.0\n             * @param [start=0] Where the new `Buffer` will start.\n             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).\n             */\n            subarray(start?: number, end?: number): Buffer;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian.\n             *\n             * `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeBigInt64BE(0x0102030405060708n, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 01 02 03 04 05 06 07 08>\n             * ```\n             * @since v12.0.0, v10.20.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeBigInt64BE(value: bigint, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian.\n             *\n             * `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeBigInt64LE(0x0102030405060708n, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 08 07 06 05 04 03 02 01>\n             * ```\n             * @since v12.0.0, v10.20.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeBigInt64LE(value: bigint, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian.\n             *\n             * This function is also available under the `writeBigUint64BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer de ca fa fe ca ce fa de>\n             * ```\n             * @since v12.0.0, v10.20.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeBigUInt64BE(value: bigint, offset?: number): number;\n            /**\n             * @alias Buffer.writeBigUInt64BE\n             * @since v14.10.0, v12.19.0\n             */\n            writeBigUint64BE(value: bigint, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer de fa ce ca fe fa ca de>\n             * ```\n             *\n             * This function is also available under the `writeBigUint64LE` alias.\n             * @since v12.0.0, v10.20.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeBigUInt64LE(value: bigint, offset?: number): number;\n            /**\n             * @alias Buffer.writeBigUInt64LE\n             * @since v14.10.0, v12.19.0\n             */\n            writeBigUint64LE(value: bigint, offset?: number): number;\n            /**\n             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\n             * when `value` is anything other than an unsigned integer.\n             *\n             * This function is also available under the `writeUintLE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(6);\n             *\n             * buf.writeUIntLE(0x1234567890ab, 0, 6);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer ab 90 78 56 34 12>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUIntLE(value: number, offset: number, byteLength: number): number;\n            /**\n             * @alias Buffer.writeUIntLE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUintLE(value: number, offset: number, byteLength: number): number;\n            /**\n             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined\n             * when `value` is anything other than an unsigned integer.\n             *\n             * This function is also available under the `writeUintBE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(6);\n             *\n             * buf.writeUIntBE(0x1234567890ab, 0, 6);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 12 34 56 78 90 ab>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUIntBE(value: number, offset: number, byteLength: number): number;\n            /**\n             * @alias Buffer.writeUIntBE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUintBE(value: number, offset: number, byteLength: number): number;\n            /**\n             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined\n             * when `value` is anything other than a signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(6);\n             *\n             * buf.writeIntLE(0x1234567890ab, 0, 6);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer ab 90 78 56 34 12>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeIntLE(value: number, offset: number, byteLength: number): number;\n            /**\n             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a\n             * signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(6);\n             *\n             * buf.writeIntBE(0x1234567890ab, 0, 6);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 12 34 56 78 90 ab>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeIntBE(value: number, offset: number, byteLength: number): number;\n            /**\n             * Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readBigUint64BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n             *\n             * console.log(buf.readBigUInt64BE(0));\n             * // Prints: 4294967295n\n             * ```\n             * @since v12.0.0, v10.20.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.\n             */\n            readBigUInt64BE(offset?: number): bigint;\n            /**\n             * @alias Buffer.readBigUInt64BE\n             * @since v14.10.0, v12.19.0\n             */\n            readBigUint64BE(offset?: number): bigint;\n            /**\n             * Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readBigUint64LE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);\n             *\n             * console.log(buf.readBigUInt64LE(0));\n             * // Prints: 18446744069414584320n\n             * ```\n             * @since v12.0.0, v10.20.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.\n             */\n            readBigUInt64LE(offset?: number): bigint;\n            /**\n             * @alias Buffer.readBigUInt64LE\n             * @since v14.10.0, v12.19.0\n             */\n            readBigUint64LE(offset?: number): bigint;\n            /**\n             * Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed\n             * values.\n             * @since v12.0.0, v10.20.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.\n             */\n            readBigInt64BE(offset?: number): bigint;\n            /**\n             * Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed\n             * values.\n             * @since v12.0.0, v10.20.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.\n             */\n            readBigInt64LE(offset?: number): bigint;\n            /**\n             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned, little-endian integer supporting\n             * up to 48 bits of accuracy.\n             *\n             * This function is also available under the `readUintLE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n             *\n             * console.log(buf.readUIntLE(0, 6).toString(16));\n             * // Prints: ab9078563412\n             * ```\n             * @since v0.11.15\n             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.\n             */\n            readUIntLE(offset: number, byteLength: number): number;\n            /**\n             * @alias Buffer.readUIntLE\n             * @since v14.9.0, v12.19.0\n             */\n            readUintLE(offset: number, byteLength: number): number;\n            /**\n             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned big-endian integer supporting\n             * up to 48 bits of accuracy.\n             *\n             * This function is also available under the `readUintBE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n             *\n             * console.log(buf.readUIntBE(0, 6).toString(16));\n             * // Prints: 1234567890ab\n             * console.log(buf.readUIntBE(1, 6).toString(16));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.11.15\n             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.\n             */\n            readUIntBE(offset: number, byteLength: number): number;\n            /**\n             * @alias Buffer.readUIntBE\n             * @since v14.9.0, v12.19.0\n             */\n            readUintBE(offset: number, byteLength: number): number;\n            /**\n             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a little-endian, two's complement signed value\n             * supporting up to 48 bits of accuracy.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n             *\n             * console.log(buf.readIntLE(0, 6).toString(16));\n             * // Prints: -546f87a9cbee\n             * ```\n             * @since v0.11.15\n             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.\n             */\n            readIntLE(offset: number, byteLength: number): number;\n            /**\n             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a big-endian, two's complement signed value\n             * supporting up to 48 bits of accuracy.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n             *\n             * console.log(buf.readIntBE(0, 6).toString(16));\n             * // Prints: 1234567890ab\n             * console.log(buf.readIntBE(1, 6).toString(16));\n             * // Throws ERR_OUT_OF_RANGE.\n             * console.log(buf.readIntBE(1, 0).toString(16));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.11.15\n             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.\n             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.\n             */\n            readIntBE(offset: number, byteLength: number): number;\n            /**\n             * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n             *\n             * This function is also available under the `readUint8` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([1, -2]);\n             *\n             * console.log(buf.readUInt8(0));\n             * // Prints: 1\n             * console.log(buf.readUInt8(1));\n             * // Prints: 254\n             * console.log(buf.readUInt8(2));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.\n             */\n            readUInt8(offset?: number): number;\n            /**\n             * @alias Buffer.readUInt8\n             * @since v14.9.0, v12.19.0\n             */\n            readUint8(offset?: number): number;\n            /**\n             * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readUint16LE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56]);\n             *\n             * console.log(buf.readUInt16LE(0).toString(16));\n             * // Prints: 3412\n             * console.log(buf.readUInt16LE(1).toString(16));\n             * // Prints: 5634\n             * console.log(buf.readUInt16LE(2).toString(16));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.\n             */\n            readUInt16LE(offset?: number): number;\n            /**\n             * @alias Buffer.readUInt16LE\n             * @since v14.9.0, v12.19.0\n             */\n            readUint16LE(offset?: number): number;\n            /**\n             * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readUint16BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56]);\n             *\n             * console.log(buf.readUInt16BE(0).toString(16));\n             * // Prints: 1234\n             * console.log(buf.readUInt16BE(1).toString(16));\n             * // Prints: 3456\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.\n             */\n            readUInt16BE(offset?: number): number;\n            /**\n             * @alias Buffer.readUInt16BE\n             * @since v14.9.0, v12.19.0\n             */\n            readUint16BE(offset?: number): number;\n            /**\n             * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readUint32LE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n             *\n             * console.log(buf.readUInt32LE(0).toString(16));\n             * // Prints: 78563412\n             * console.log(buf.readUInt32LE(1).toString(16));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readUInt32LE(offset?: number): number;\n            /**\n             * @alias Buffer.readUInt32LE\n             * @since v14.9.0, v12.19.0\n             */\n            readUint32LE(offset?: number): number;\n            /**\n             * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.\n             *\n             * This function is also available under the `readUint32BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n             *\n             * console.log(buf.readUInt32BE(0).toString(16));\n             * // Prints: 12345678\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readUInt32BE(offset?: number): number;\n            /**\n             * @alias Buffer.readUInt32BE\n             * @since v14.9.0, v12.19.0\n             */\n            readUint32BE(offset?: number): number;\n            /**\n             * Reads a signed 8-bit integer from `buf` at the specified `offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed values.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([-1, 5]);\n             *\n             * console.log(buf.readInt8(0));\n             * // Prints: -1\n             * console.log(buf.readInt8(1));\n             * // Prints: 5\n             * console.log(buf.readInt8(2));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.0\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.\n             */\n            readInt8(offset?: number): number;\n            /**\n             * Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed values.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0, 5]);\n             *\n             * console.log(buf.readInt16LE(0));\n             * // Prints: 1280\n             * console.log(buf.readInt16LE(1));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.\n             */\n            readInt16LE(offset?: number): number;\n            /**\n             * Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed values.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0, 5]);\n             *\n             * console.log(buf.readInt16BE(0));\n             * // Prints: 5\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.\n             */\n            readInt16BE(offset?: number): number;\n            /**\n             * Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed values.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0, 0, 0, 5]);\n             *\n             * console.log(buf.readInt32LE(0));\n             * // Prints: 83886080\n             * console.log(buf.readInt32LE(1));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readInt32LE(offset?: number): number;\n            /**\n             * Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.\n             *\n             * Integers read from a `Buffer` are interpreted as two's complement signed values.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([0, 0, 0, 5]);\n             *\n             * console.log(buf.readInt32BE(0));\n             * // Prints: 5\n             * ```\n             * @since v0.5.5\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readInt32BE(offset?: number): number;\n            /**\n             * Reads a 32-bit, little-endian float from `buf` at the specified `offset`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([1, 2, 3, 4]);\n             *\n             * console.log(buf.readFloatLE(0));\n             * // Prints: 1.539989614439558e-36\n             * console.log(buf.readFloatLE(1));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.11.15\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readFloatLE(offset?: number): number;\n            /**\n             * Reads a 32-bit, big-endian float from `buf` at the specified `offset`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([1, 2, 3, 4]);\n             *\n             * console.log(buf.readFloatBE(0));\n             * // Prints: 2.387939260590663e-38\n             * ```\n             * @since v0.11.15\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.\n             */\n            readFloatBE(offset?: number): number;\n            /**\n             * Reads a 64-bit, little-endian double from `buf` at the specified `offset`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n             *\n             * console.log(buf.readDoubleLE(0));\n             * // Prints: 5.447603722011605e-270\n             * console.log(buf.readDoubleLE(1));\n             * // Throws ERR_OUT_OF_RANGE.\n             * ```\n             * @since v0.11.15\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.\n             */\n            readDoubleLE(offset?: number): number;\n            /**\n             * Reads a 64-bit, big-endian double from `buf` at the specified `offset`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n             *\n             * console.log(buf.readDoubleBE(0));\n             * // Prints: 8.20788039913184e-304\n             * ```\n             * @since v0.11.15\n             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.\n             */\n            readDoubleBE(offset?: number): number;\n            reverse(): this;\n            /**\n             * Interprets `buf` as an array of unsigned 16-bit integers and swaps the\n             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 01 02 03 04 05 06 07 08>\n             *\n             * buf1.swap16();\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 02 01 04 03 06 05 08 07>\n             *\n             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);\n             *\n             * buf2.swap16();\n             * // Throws ERR_INVALID_BUFFER_SIZE.\n             * ```\n             *\n             * One convenient use of `buf.swap16()` is to perform a fast in-place conversion\n             * between UTF-16 little-endian and UTF-16 big-endian:\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');\n             * buf.swap16(); // Convert to big-endian UTF-16 text.\n             * ```\n             * @since v5.10.0\n             * @return A reference to `buf`.\n             */\n            swap16(): Buffer;\n            /**\n             * Interprets `buf` as an array of unsigned 32-bit integers and swaps the\n             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 01 02 03 04 05 06 07 08>\n             *\n             * buf1.swap32();\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 04 03 02 01 08 07 06 05>\n             *\n             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);\n             *\n             * buf2.swap32();\n             * // Throws ERR_INVALID_BUFFER_SIZE.\n             * ```\n             * @since v5.10.0\n             * @return A reference to `buf`.\n             */\n            swap32(): Buffer;\n            /**\n             * Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.\n             * Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 01 02 03 04 05 06 07 08>\n             *\n             * buf1.swap64();\n             *\n             * console.log(buf1);\n             * // Prints: <Buffer 08 07 06 05 04 03 02 01>\n             *\n             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);\n             *\n             * buf2.swap64();\n             * // Throws ERR_INVALID_BUFFER_SIZE.\n             * ```\n             * @since v6.3.0\n             * @return A reference to `buf`.\n             */\n            swap64(): Buffer;\n            /**\n             * Writes `value` to `buf` at the specified `offset`. `value` must be a\n             * valid unsigned 8-bit integer. Behavior is undefined when `value` is anything\n             * other than an unsigned 8-bit integer.\n             *\n             * This function is also available under the `writeUint8` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeUInt8(0x3, 0);\n             * buf.writeUInt8(0x4, 1);\n             * buf.writeUInt8(0x23, 2);\n             * buf.writeUInt8(0x42, 3);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 03 04 23 42>\n             * ```\n             * @since v0.5.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUInt8(value: number, offset?: number): number;\n            /**\n             * @alias Buffer.writeUInt8\n             * @since v14.9.0, v12.19.0\n             */\n            writeUint8(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is\n             * anything other than an unsigned 16-bit integer.\n             *\n             * This function is also available under the `writeUint16LE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeUInt16LE(0xdead, 0);\n             * buf.writeUInt16LE(0xbeef, 2);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer ad de ef be>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUInt16LE(value: number, offset?: number): number;\n            /**\n             * @alias Buffer.writeUInt16LE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUint16LE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an\n             * unsigned 16-bit integer.\n             *\n             * This function is also available under the `writeUint16BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeUInt16BE(0xdead, 0);\n             * buf.writeUInt16BE(0xbeef, 2);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer de ad be ef>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUInt16BE(value: number, offset?: number): number;\n            /**\n             * @alias Buffer.writeUInt16BE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUint16BE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is\n             * anything other than an unsigned 32-bit integer.\n             *\n             * This function is also available under the `writeUint32LE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeUInt32LE(0xfeedface, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer ce fa ed fe>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUInt32LE(value: number, offset?: number): number;\n            /**\n             * @alias Buffer.writeUInt32LE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUint32LE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an\n             * unsigned 32-bit integer.\n             *\n             * This function is also available under the `writeUint32BE` alias.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeUInt32BE(0xfeedface, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer fe ed fa ce>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeUInt32BE(value: number, offset?: number): number;\n            /**\n             * @alias Buffer.writeUInt32BE\n             * @since v14.9.0, v12.19.0\n             */\n            writeUint32BE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset`. `value` must be a valid\n             * signed 8-bit integer. Behavior is undefined when `value` is anything other than\n             * a signed 8-bit integer.\n             *\n             * `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(2);\n             *\n             * buf.writeInt8(2, 0);\n             * buf.writeInt8(-2, 1);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 02 fe>\n             * ```\n             * @since v0.5.0\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeInt8(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is\n             * anything other than a signed 16-bit integer.\n             *\n             * The `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(2);\n             *\n             * buf.writeInt16LE(0x0304, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 04 03>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeInt16LE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian.  The `value`must be a valid signed 16-bit integer. Behavior is undefined when `value` is\n             * anything other than a signed 16-bit integer.\n             *\n             * The `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(2);\n             *\n             * buf.writeInt16BE(0x0102, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 01 02>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeInt16BE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is\n             * anything other than a signed 32-bit integer.\n             *\n             * The `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeInt32LE(0x05060708, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 08 07 06 05>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeInt32LE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a valid signed 32-bit integer. Behavior is undefined when `value` is\n             * anything other than a signed 32-bit integer.\n             *\n             * The `value` is interpreted and written as a two's complement signed integer.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeInt32BE(0x01020304, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 01 02 03 04>\n             * ```\n             * @since v0.5.5\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeInt32BE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is\n             * undefined when `value` is anything other than a JavaScript number.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeFloatLE(0xcafebabe, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer bb fe 4a 4f>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeFloatLE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is\n             * undefined when `value` is anything other than a JavaScript number.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(4);\n             *\n             * buf.writeFloatBE(0xcafebabe, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 4f 4a fe bb>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeFloatBE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything\n             * other than a JavaScript number.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeDoubleLE(123.456, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeDoubleLE(value: number, offset?: number): number;\n            /**\n             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value`must be a JavaScript number. Behavior is undefined when `value` is anything\n             * other than a JavaScript number.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(8);\n             *\n             * buf.writeDoubleBE(123.456, 0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 40 5e dd 2f 1a 9f be 77>\n             * ```\n             * @since v0.11.15\n             * @param value Number to be written to `buf`.\n             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.\n             * @return `offset` plus the number of bytes written.\n             */\n            writeDoubleBE(value: number, offset?: number): number;\n            /**\n             * Fills `buf` with the specified `value`. If the `offset` and `end` are not given,\n             * the entire `buf` will be filled:\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Fill a `Buffer` with the ASCII character 'h'.\n             *\n             * const b = Buffer.allocUnsafe(50).fill('h');\n             *\n             * console.log(b.toString());\n             * // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n             *\n             * // Fill a buffer with empty string\n             * const c = Buffer.allocUnsafe(5).fill('');\n             *\n             * console.log(c.fill(''));\n             * // Prints: <Buffer 00 00 00 00 00>\n             * ```\n             *\n             * `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or\n             * integer. If the resulting integer is greater than `255` (decimal), `buf` will be\n             * filled with `value &#x26; 255`.\n             *\n             * If the final write of a `fill()` operation falls on a multi-byte character,\n             * then only the bytes of that character that fit into `buf` are written:\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Fill a `Buffer` with character that takes up two bytes in UTF-8.\n             *\n             * console.log(Buffer.allocUnsafe(5).fill('\\u0222'));\n             * // Prints: <Buffer c8 a2 c8 a2 c8>\n             * ```\n             *\n             * If `value` contains invalid characters, it is truncated; if no valid\n             * fill data remains, an exception is thrown:\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(5);\n             *\n             * console.log(buf.fill('a'));\n             * // Prints: <Buffer 61 61 61 61 61>\n             * console.log(buf.fill('aazz', 'hex'));\n             * // Prints: <Buffer aa aa aa aa aa>\n             * console.log(buf.fill('zz', 'hex'));\n             * // Throws an exception.\n             * ```\n             * @since v0.5.0\n             * @param value The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`.\n             * @param [offset=0] Number of bytes to skip before starting to fill `buf`.\n             * @param [end=buf.length] Where to stop filling `buf` (not inclusive).\n             * @param [encoding='utf8'] The encoding for `value` if `value` is a string.\n             * @return A reference to `buf`.\n             */\n            fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;\n            /**\n             * If `value` is:\n             *\n             * * a string, `value` is interpreted according to the character encoding in`encoding`.\n             * * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.\n             * To compare a partial `Buffer`, use `buf.subarray`.\n             * * a number, `value` will be interpreted as an unsigned 8-bit integer\n             * value between `0` and `255`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('this is a buffer');\n             *\n             * console.log(buf.indexOf('this'));\n             * // Prints: 0\n             * console.log(buf.indexOf('is'));\n             * // Prints: 2\n             * console.log(buf.indexOf(Buffer.from('a buffer')));\n             * // Prints: 8\n             * console.log(buf.indexOf(97));\n             * // Prints: 8 (97 is the decimal ASCII value for 'a')\n             * console.log(buf.indexOf(Buffer.from('a buffer example')));\n             * // Prints: -1\n             * console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));\n             * // Prints: 8\n             *\n             * const utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n             *\n             * console.log(utf16Buffer.indexOf('\\u03a3', 0, 'utf16le'));\n             * // Prints: 4\n             * console.log(utf16Buffer.indexOf('\\u03a3', -4, 'utf16le'));\n             * // Prints: 6\n             * ```\n             *\n             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,\n             * an integer between 0 and 255.\n             *\n             * If `byteOffset` is not a number, it will be coerced to a number. If the result\n             * of coercion is `NaN` or `0`, then the entire buffer will be searched. This\n             * behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const b = Buffer.from('abcdef');\n             *\n             * // Passing a value that's a number, but not a valid byte.\n             * // Prints: 2, equivalent to searching for 99 or 'c'.\n             * console.log(b.indexOf(99.9));\n             * console.log(b.indexOf(256 + 99));\n             *\n             * // Passing a byteOffset that coerces to NaN or 0.\n             * // Prints: 1, searching the whole buffer.\n             * console.log(b.indexOf('b', undefined));\n             * console.log(b.indexOf('b', {}));\n             * console.log(b.indexOf('b', null));\n             * console.log(b.indexOf('b', []));\n             * ```\n             *\n             * If `value` is an empty string or empty `Buffer` and `byteOffset` is less\n             * than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.\n             * @since v1.5.0\n             * @param value What to search for.\n             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.\n             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.\n             * @return The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.\n             */\n            indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;\n            /**\n             * Identical to `buf.indexOf()`, except the last occurrence of `value` is found\n             * rather than the first occurrence.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('this buffer is a buffer');\n             *\n             * console.log(buf.lastIndexOf('this'));\n             * // Prints: 0\n             * console.log(buf.lastIndexOf('buffer'));\n             * // Prints: 17\n             * console.log(buf.lastIndexOf(Buffer.from('buffer')));\n             * // Prints: 17\n             * console.log(buf.lastIndexOf(97));\n             * // Prints: 15 (97 is the decimal ASCII value for 'a')\n             * console.log(buf.lastIndexOf(Buffer.from('yolo')));\n             * // Prints: -1\n             * console.log(buf.lastIndexOf('buffer', 5));\n             * // Prints: 5\n             * console.log(buf.lastIndexOf('buffer', 4));\n             * // Prints: -1\n             *\n             * const utf16Buffer = Buffer.from('\\u039a\\u0391\\u03a3\\u03a3\\u0395', 'utf16le');\n             *\n             * console.log(utf16Buffer.lastIndexOf('\\u03a3', undefined, 'utf16le'));\n             * // Prints: 6\n             * console.log(utf16Buffer.lastIndexOf('\\u03a3', -5, 'utf16le'));\n             * // Prints: 4\n             * ```\n             *\n             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,\n             * an integer between 0 and 255.\n             *\n             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments\n             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.\n             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const b = Buffer.from('abcdef');\n             *\n             * // Passing a value that's a number, but not a valid byte.\n             * // Prints: 2, equivalent to searching for 99 or 'c'.\n             * console.log(b.lastIndexOf(99.9));\n             * console.log(b.lastIndexOf(256 + 99));\n             *\n             * // Passing a byteOffset that coerces to NaN.\n             * // Prints: 1, searching the whole buffer.\n             * console.log(b.lastIndexOf('b', undefined));\n             * console.log(b.lastIndexOf('b', {}));\n             *\n             * // Passing a byteOffset that coerces to 0.\n             * // Prints: -1, equivalent to passing 0.\n             * console.log(b.lastIndexOf('b', null));\n             * console.log(b.lastIndexOf('b', []));\n             * ```\n             *\n             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.\n             * @since v6.0.0\n             * @param value What to search for.\n             * @param [byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.\n             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.\n             * @return The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.\n             */\n            lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;\n            /**\n             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `[index, byte]` pairs from the contents\n             * of `buf`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Log the entire contents of a `Buffer`.\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * for (const pair of buf.entries()) {\n             *   console.log(pair);\n             * }\n             * // Prints:\n             * //   [0, 98]\n             * //   [1, 117]\n             * //   [2, 102]\n             * //   [3, 102]\n             * //   [4, 101]\n             * //   [5, 114]\n             * ```\n             * @since v1.1.0\n             */\n            entries(): IterableIterator<[number, number]>;\n            /**\n             * Equivalent to `buf.indexOf() !== -1`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('this is a buffer');\n             *\n             * console.log(buf.includes('this'));\n             * // Prints: true\n             * console.log(buf.includes('is'));\n             * // Prints: true\n             * console.log(buf.includes(Buffer.from('a buffer')));\n             * // Prints: true\n             * console.log(buf.includes(97));\n             * // Prints: true (97 is the decimal ASCII value for 'a')\n             * console.log(buf.includes(Buffer.from('a buffer example')));\n             * // Prints: false\n             * console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));\n             * // Prints: true\n             * console.log(buf.includes('this', 4));\n             * // Prints: false\n             * ```\n             * @since v5.3.0\n             * @param value What to search for.\n             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.\n             * @param [encoding='utf8'] If `value` is a string, this is its encoding.\n             * @return `true` if `value` was found in `buf`, `false` otherwise.\n             */\n            includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;\n            /**\n             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `buf` keys (indices).\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * for (const key of buf.keys()) {\n             *   console.log(key);\n             * }\n             * // Prints:\n             * //   0\n             * //   1\n             * //   2\n             * //   3\n             * //   4\n             * //   5\n             * ```\n             * @since v1.1.0\n             */\n            keys(): IterableIterator<number>;\n            /**\n             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) for `buf` values (bytes). This function is\n             * called automatically when a `Buffer` is used in a `for..of` statement.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * for (const value of buf.values()) {\n             *   console.log(value);\n             * }\n             * // Prints:\n             * //   98\n             * //   117\n             * //   102\n             * //   102\n             * //   101\n             * //   114\n             *\n             * for (const value of buf) {\n             *   console.log(value);\n             * }\n             * // Prints:\n             * //   98\n             * //   117\n             * //   102\n             * //   102\n             * //   101\n             * //   114\n             * ```\n             * @since v1.1.0\n             */\n            values(): IterableIterator<number>;\n        }\n        var Buffer: BufferConstructor;\n        /**\n         * Decodes a string of Base64-encoded data into bytes, and encodes those bytes\n         * into a string using Latin-1 (ISO-8859-1).\n         *\n         * The `data` may be any JavaScript-value that can be coerced into a string.\n         *\n         * **This function is only provided for compatibility with legacy web platform APIs**\n         * **and should never be used in new code, because they use strings to represent**\n         * **binary data and predate the introduction of typed arrays in JavaScript.**\n         * **For code running using Node.js APIs, converting between base64-encoded strings**\n         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**\n         * @since v15.13.0, v14.17.0\n         * @legacy Use `Buffer.from(data, 'base64')` instead.\n         * @param data The Base64-encoded input string.\n         */\n        function atob(data: string): string;\n        /**\n         * Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes\n         * into a string using Base64.\n         *\n         * The `data` may be any JavaScript-value that can be coerced into a string.\n         *\n         * **This function is only provided for compatibility with legacy web platform APIs**\n         * **and should never be used in new code, because they use strings to represent**\n         * **binary data and predate the introduction of typed arrays in JavaScript.**\n         * **For code running using Node.js APIs, converting between base64-encoded strings**\n         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**\n         * @since v15.13.0, v14.17.0\n         * @legacy Use `buf.toString('base64')` instead.\n         * @param data An ASCII (Latin1) string.\n         */\n        function btoa(data: string): string;\n        interface Blob extends __Blob {}\n        /**\n         * `Blob` class is a global reference for `require('node:buffer').Blob`\n         * https://nodejs.org/api/buffer.html#class-blob\n         * @since v18.0.0\n         */\n        var Blob: typeof globalThis extends {\n            onmessage: any;\n            Blob: infer T;\n        } ? T\n            : typeof NodeBlob;\n    }\n}\ndeclare module \"node:buffer\" {\n    export * from \"buffer\";\n}\n"},57264:e=>{e.exports="/**\n * Much of the Node.js core API is built around an idiomatic asynchronous\n * event-driven architecture in which certain kinds of objects (called \"emitters\")\n * emit named events that cause `Function` objects (\"listeners\") to be called.\n *\n * For instance: a `net.Server` object emits an event each time a peer\n * connects to it; a `fs.ReadStream` emits an event when the file is opened;\n * a `stream` emits an event whenever data is available to be read.\n *\n * All objects that emit events are instances of the `EventEmitter` class. These\n * objects expose an `eventEmitter.on()` function that allows one or more\n * functions to be attached to named events emitted by the object. Typically,\n * event names are camel-cased strings but any valid JavaScript property key\n * can be used.\n *\n * When the `EventEmitter` object emits an event, all of the functions attached\n * to that specific event are called _synchronously_. Any values returned by the\n * called listeners are _ignored_ and discarded.\n *\n * The following example shows a simple `EventEmitter` instance with a single\n * listener. The `eventEmitter.on()` method is used to register listeners, while\n * the `eventEmitter.emit()` method is used to trigger the event.\n *\n * ```js\n * import { EventEmitter } from 'node:events';\n *\n * class MyEmitter extends EventEmitter {}\n *\n * const myEmitter = new MyEmitter();\n * myEmitter.on('event', () => {\n *   console.log('an event occurred!');\n * });\n * myEmitter.emit('event');\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/events.js)\n */\ndeclare module \"events\" {\n    import { AsyncResource, AsyncResourceOptions } from \"node:async_hooks\";\n    // NOTE: This class is in the docs but is **not actually exported** by Node.\n    // If https://github.com/nodejs/node/issues/39903 gets resolved and Node\n    // actually starts exporting the class, uncomment below.\n    // import { EventListener, EventListenerObject } from '__dom-events';\n    // /** The NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API. */\n    // interface NodeEventTarget extends EventTarget {\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class that emulates the equivalent `EventEmitter` API.\n    //      * The only difference between `addListener()` and `addEventListener()` is that addListener() will return a reference to the EventTarget.\n    //      */\n    //     addListener(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;\n    //     /** Node.js-specific extension to the `EventTarget` class that returns an array of event `type` names for which event listeners are registered. */\n    //     eventNames(): string[];\n    //     /** Node.js-specific extension to the `EventTarget` class that returns the number of event listeners registered for the `type`. */\n    //     listenerCount(type: string): number;\n    //     /** Node.js-specific alias for `eventTarget.removeListener()`. */\n    //     off(type: string, listener: EventListener | EventListenerObject): this;\n    //     /** Node.js-specific alias for `eventTarget.addListener()`. */\n    //     on(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;\n    //     /** Node.js-specific extension to the `EventTarget` class that adds a `once` listener for the given event `type`. This is equivalent to calling `on` with the `once` option set to `true`. */\n    //     once(type: string, listener: EventListener | EventListenerObject): this;\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class.\n    //      * If `type` is specified, removes all registered listeners for `type`,\n    //      * otherwise removes all registered listeners.\n    //      */\n    //     removeAllListeners(type: string): this;\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class that removes the listener for the given `type`.\n    //      * The only difference between `removeListener()` and `removeEventListener()` is that `removeListener()` will return a reference to the `EventTarget`.\n    //      */\n    //     removeListener(type: string, listener: EventListener | EventListenerObject): this;\n    // }\n    interface EventEmitterOptions {\n        /**\n         * Enables automatic capturing of promise rejection.\n         */\n        captureRejections?: boolean | undefined;\n    }\n    // Any EventTarget with a Node-style `once` function\n    interface _NodeEventTarget {\n        once(eventName: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    // Any EventTarget with a DOM-style `addEventListener`\n    interface _DOMEventTarget {\n        addEventListener(\n            eventName: string,\n            listener: (...args: any[]) => void,\n            opts?: {\n                once: boolean;\n            },\n        ): any;\n    }\n    interface StaticEventEmitterOptions {\n        signal?: AbortSignal | undefined;\n    }\n    interface EventEmitter extends NodeJS.EventEmitter {}\n    /**\n     * The `EventEmitter` class is defined and exposed by the `node:events` module:\n     *\n     * ```js\n     * import { EventEmitter } from 'node:events';\n     * ```\n     *\n     * All `EventEmitter`s emit the event `'newListener'` when new listeners are\n     * added and `'removeListener'` when existing listeners are removed.\n     *\n     * It supports the following option:\n     * @since v0.1.26\n     */\n    class EventEmitter {\n        constructor(options?: EventEmitterOptions);\n\n        [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;\n\n        /**\n         * Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\n         * event or that is rejected if the `EventEmitter` emits `'error'` while waiting.\n         * The `Promise` will resolve with an array of all the arguments emitted to the\n         * given event.\n         *\n         * This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\n         * semantics and does not listen to the `'error'` event.\n         *\n         * ```js\n         * import { once, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ee = new EventEmitter();\n         *\n         * process.nextTick(() => {\n         *   ee.emit('myevent', 42);\n         * });\n         *\n         * const [value] = await once(ee, 'myevent');\n         * console.log(value);\n         *\n         * const err = new Error('kaboom');\n         * process.nextTick(() => {\n         *   ee.emit('error', err);\n         * });\n         *\n         * try {\n         *   await once(ee, 'myevent');\n         * } catch (err) {\n         *   console.error('error happened', err);\n         * }\n         * ```\n         *\n         * The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n         * '`error'` event itself, then it is treated as any other kind of event without\n         * special handling:\n         *\n         * ```js\n         * import { EventEmitter, once } from 'node:events';\n         *\n         * const ee = new EventEmitter();\n         *\n         * once(ee, 'error')\n         *   .then(([err]) => console.log('ok', err.message))\n         *   .catch((err) => console.error('error', err.message));\n         *\n         * ee.emit('error', new Error('boom'));\n         *\n         * // Prints: ok boom\n         * ```\n         *\n         * An `AbortSignal` can be used to cancel waiting for the event:\n         *\n         * ```js\n         * import { EventEmitter, once } from 'node:events';\n         *\n         * const ee = new EventEmitter();\n         * const ac = new AbortController();\n         *\n         * async function foo(emitter, event, signal) {\n         *   try {\n         *     await once(emitter, event, { signal });\n         *     console.log('event emitted!');\n         *   } catch (error) {\n         *     if (error.name === 'AbortError') {\n         *       console.error('Waiting for the event was canceled!');\n         *     } else {\n         *       console.error('There was an error', error.message);\n         *     }\n         *   }\n         * }\n         *\n         * foo(ee, 'foo', ac.signal);\n         * ac.abort(); // Abort waiting for the event\n         * ee.emit('foo'); // Prints: Waiting for the event was canceled!\n         * ```\n         * @since v11.13.0, v10.16.0\n         */\n        static once(\n            emitter: _NodeEventTarget,\n            eventName: string | symbol,\n            options?: StaticEventEmitterOptions,\n        ): Promise<any[]>;\n        static once(emitter: _DOMEventTarget, eventName: string, options?: StaticEventEmitterOptions): Promise<any[]>;\n        /**\n         * ```js\n         * import { on, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ee = new EventEmitter();\n         *\n         * // Emit later on\n         * process.nextTick(() => {\n         *   ee.emit('foo', 'bar');\n         *   ee.emit('foo', 42);\n         * });\n         *\n         * for await (const event of on(ee, 'foo')) {\n         *   // The execution of this inner block is synchronous and it\n         *   // processes one event at a time (even with await). Do not use\n         *   // if concurrent execution is required.\n         *   console.log(event); // prints ['bar'] [42]\n         * }\n         * // Unreachable here\n         * ```\n         *\n         * Returns an `AsyncIterator` that iterates `eventName` events. It will throw\n         * if the `EventEmitter` emits `'error'`. It removes all listeners when\n         * exiting the loop. The `value` returned by each iteration is an array\n         * composed of the emitted event arguments.\n         *\n         * An `AbortSignal` can be used to cancel waiting on events:\n         *\n         * ```js\n         * import { on, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ac = new AbortController();\n         *\n         * (async () => {\n         *   const ee = new EventEmitter();\n         *\n         *   // Emit later on\n         *   process.nextTick(() => {\n         *     ee.emit('foo', 'bar');\n         *     ee.emit('foo', 42);\n         *   });\n         *\n         *   for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n         *     // The execution of this inner block is synchronous and it\n         *     // processes one event at a time (even with await). Do not use\n         *     // if concurrent execution is required.\n         *     console.log(event); // prints ['bar'] [42]\n         *   }\n         *   // Unreachable here\n         * })();\n         *\n         * process.nextTick(() => ac.abort());\n         * ```\n         * @since v13.6.0, v12.16.0\n         * @param eventName The name of the event being listened for\n         * @return that iterates `eventName` events emitted by the `emitter`\n         */\n        static on(\n            emitter: NodeJS.EventEmitter,\n            eventName: string,\n            options?: StaticEventEmitterOptions,\n        ): AsyncIterableIterator<any>;\n        /**\n         * A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n         *\n         * ```js\n         * import { EventEmitter, listenerCount } from 'node:events';\n         *\n         * const myEmitter = new EventEmitter();\n         * myEmitter.on('event', () => {});\n         * myEmitter.on('event', () => {});\n         * console.log(listenerCount(myEmitter, 'event'));\n         * // Prints: 2\n         * ```\n         * @since v0.9.12\n         * @deprecated Since v3.2.0 - Use `listenerCount` instead.\n         * @param emitter The emitter to query\n         * @param eventName The event name\n         */\n        static listenerCount(emitter: NodeJS.EventEmitter, eventName: string | symbol): number;\n        /**\n         * Returns a copy of the array of listeners for the event named `eventName`.\n         *\n         * For `EventEmitter`s this behaves exactly the same as calling `.listeners` on\n         * the emitter.\n         *\n         * For `EventTarget`s this is the only way to get the event listeners for the\n         * event target. This is useful for debugging and diagnostic purposes.\n         *\n         * ```js\n         * import { getEventListeners, EventEmitter } from 'node:events';\n         *\n         * {\n         *   const ee = new EventEmitter();\n         *   const listener = () => console.log('Events are fun');\n         *   ee.on('foo', listener);\n         *   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n         * }\n         * {\n         *   const et = new EventTarget();\n         *   const listener = () => console.log('Events are fun');\n         *   et.addEventListener('foo', listener);\n         *   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n         * }\n         * ```\n         * @since v15.2.0, v14.17.0\n         */\n        static getEventListeners(emitter: _DOMEventTarget | NodeJS.EventEmitter, name: string | symbol): Function[];\n        /**\n         * Returns the currently set max amount of listeners.\n         *\n         * For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on\n         * the emitter.\n         *\n         * For `EventTarget`s this is the only way to get the max event listeners for the\n         * event target. If the number of event handlers on a single EventTarget exceeds\n         * the max set, the EventTarget will print a warning.\n         *\n         * ```js\n         * import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';\n         *\n         * {\n         *   const ee = new EventEmitter();\n         *   console.log(getMaxListeners(ee)); // 10\n         *   setMaxListeners(11, ee);\n         *   console.log(getMaxListeners(ee)); // 11\n         * }\n         * {\n         *   const et = new EventTarget();\n         *   console.log(getMaxListeners(et)); // 10\n         *   setMaxListeners(11, et);\n         *   console.log(getMaxListeners(et)); // 11\n         * }\n         * ```\n         * @since v19.9.0\n         */\n        static getMaxListeners(emitter: _DOMEventTarget | NodeJS.EventEmitter): number;\n        /**\n         * ```js\n         * import { setMaxListeners, EventEmitter } from 'node:events';\n         *\n         * const target = new EventTarget();\n         * const emitter = new EventEmitter();\n         *\n         * setMaxListeners(5, target, emitter);\n         * ```\n         * @since v15.4.0\n         * @param n A non-negative number. The maximum number of listeners per `EventTarget` event.\n         * @param eventsTargets Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter}\n         * objects.\n         */\n        static setMaxListeners(n?: number, ...eventTargets: Array<_DOMEventTarget | NodeJS.EventEmitter>): void;\n        /**\n         * Listens once to the `abort` event on the provided `signal`.\n         *\n         * Listening to the `abort` event on abort signals is unsafe and may\n         * lead to resource leaks since another third party with the signal can\n         * call `e.stopImmediatePropagation()`. Unfortunately Node.js cannot change\n         * this since it would violate the web standard. Additionally, the original\n         * API makes it easy to forget to remove listeners.\n         *\n         * This API allows safely using `AbortSignal`s in Node.js APIs by solving these\n         * two issues by listening to the event such that `stopImmediatePropagation` does\n         * not prevent the listener from running.\n         *\n         * Returns a disposable so that it may be unsubscribed from more easily.\n         *\n         * ```js\n         * import { addAbortListener } from 'node:events';\n         *\n         * function example(signal) {\n         *   let disposable;\n         *   try {\n         *     signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n         *     disposable = addAbortListener(signal, (e) => {\n         *       // Do something when signal is aborted.\n         *     });\n         *   } finally {\n         *     disposable?.[Symbol.dispose]();\n         *   }\n         * }\n         * ```\n         * @since v20.5.0\n         * @experimental\n         * @return Disposable that removes the `abort` listener.\n         */\n        static addAbortListener(signal: AbortSignal, resource: (event: Event) => void): Disposable;\n        /**\n         * This symbol shall be used to install a listener for only monitoring `'error'`events. Listeners installed using this symbol are called before the regular`'error'` listeners are called.\n         *\n         * Installing a listener using this symbol does not change the behavior once an`'error'` event is emitted. Therefore, the process will still crash if no\n         * regular `'error'` listener is installed.\n         * @since v13.6.0, v12.17.0\n         */\n        static readonly errorMonitor: unique symbol;\n        /**\n         * Value: `Symbol.for('nodejs.rejection')`\n         *\n         * See how to write a custom `rejection handler`.\n         * @since v13.4.0, v12.16.0\n         */\n        static readonly captureRejectionSymbol: unique symbol;\n        /**\n         * Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n         *\n         * Change the default `captureRejections` option on all new `EventEmitter` objects.\n         * @since v13.4.0, v12.16.0\n         */\n        static captureRejections: boolean;\n        /**\n         * By default, a maximum of `10` listeners can be registered for any single\n         * event. This limit can be changed for individual `EventEmitter` instances\n         * using the `emitter.setMaxListeners(n)` method. To change the default\n         * for _all_`EventEmitter` instances, the `events.defaultMaxListeners`property can be used. If this value is not a positive number, a `RangeError`is thrown.\n         *\n         * Take caution when setting the `events.defaultMaxListeners` because the\n         * change affects _all_`EventEmitter` instances, including those created before\n         * the change is made. However, calling `emitter.setMaxListeners(n)` still has\n         * precedence over `events.defaultMaxListeners`.\n         *\n         * This is not a hard limit. The `EventEmitter` instance will allow\n         * more listeners to be added but will output a trace warning to stderr indicating\n         * that a \"possible EventEmitter memory leak\" has been detected. For any single`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()`methods can be used to\n         * temporarily avoid this warning:\n         *\n         * ```js\n         * import { EventEmitter } from 'node:events';\n         * const emitter = new EventEmitter();\n         * emitter.setMaxListeners(emitter.getMaxListeners() + 1);\n         * emitter.once('event', () => {\n         *   // do stuff\n         *   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n         * });\n         * ```\n         *\n         * The `--trace-warnings` command-line flag can be used to display the\n         * stack trace for such warnings.\n         *\n         * The emitted warning can be inspected with `process.on('warning')` and will\n         * have the additional `emitter`, `type`, and `count` properties, referring to\n         * the event emitter instance, the event's name and the number of attached\n         * listeners, respectively.\n         * Its `name` property is set to `'MaxListenersExceededWarning'`.\n         * @since v0.11.2\n         */\n        static defaultMaxListeners: number;\n    }\n    import internal = require(\"node:events\");\n    namespace EventEmitter {\n        // Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4\n        export { internal as EventEmitter };\n        export interface Abortable {\n            /**\n             * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n             */\n            signal?: AbortSignal | undefined;\n        }\n\n        export interface EventEmitterReferencingAsyncResource extends AsyncResource {\n            readonly eventEmitter: EventEmitterAsyncResource;\n        }\n\n        export interface EventEmitterAsyncResourceOptions extends AsyncResourceOptions, EventEmitterOptions {\n            /**\n             * The type of async event, this is required when instantiating `EventEmitterAsyncResource`\n             * directly rather than as a child class.\n             * @default new.target.name if instantiated as a child class.\n             */\n            name?: string;\n        }\n\n        /**\n         * Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\n         * require manual async tracking. Specifically, all events emitted by instances\n         * of `events.EventEmitterAsyncResource` will run within its `async context`.\n         *\n         * ```js\n         * import { EventEmitterAsyncResource, EventEmitter } from 'node:events';\n         * import { notStrictEqual, strictEqual } from 'node:assert';\n         * import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n         *\n         * // Async tracking tooling will identify this as 'Q'.\n         * const ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n         *\n         * // 'foo' listeners will run in the EventEmitters async context.\n         * ee1.on('foo', () => {\n         *   strictEqual(executionAsyncId(), ee1.asyncId);\n         *   strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n         * });\n         *\n         * const ee2 = new EventEmitter();\n         *\n         * // 'foo' listeners on ordinary EventEmitters that do not track async\n         * // context, however, run in the same async context as the emit().\n         * ee2.on('foo', () => {\n         *   notStrictEqual(executionAsyncId(), ee2.asyncId);\n         *   notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n         * });\n         *\n         * Promise.resolve().then(() => {\n         *   ee1.emit('foo');\n         *   ee2.emit('foo');\n         * });\n         * ```\n         *\n         * The `EventEmitterAsyncResource` class has the same methods and takes the\n         * same options as `EventEmitter` and `AsyncResource` themselves.\n         * @since v17.4.0, v16.14.0\n         */\n        export class EventEmitterAsyncResource extends EventEmitter {\n            /**\n             * @param options Only optional in child class.\n             */\n            constructor(options?: EventEmitterAsyncResourceOptions);\n            /**\n             * Call all `destroy` hooks. This should only ever be called once. An error will\n             * be thrown if it is called more than once. This **must** be manually called. If\n             * the resource is left to be collected by the GC then the `destroy` hooks will\n             * never be called.\n             */\n            emitDestroy(): void;\n            /**\n             * The unique `asyncId` assigned to the resource.\n             */\n            readonly asyncId: number;\n            /**\n             * The same triggerAsyncId that is passed to the AsyncResource constructor.\n             */\n            readonly triggerAsyncId: number;\n            /**\n             * The returned `AsyncResource` object has an additional `eventEmitter` property\n             * that provides a reference to this `EventEmitterAsyncResource`.\n             */\n            readonly asyncResource: EventEmitterReferencingAsyncResource;\n        }\n    }\n    global {\n        namespace NodeJS {\n            interface EventEmitter {\n                [EventEmitter.captureRejectionSymbol]?(error: Error, event: string, ...args: any[]): void;\n                /**\n                 * Alias for `emitter.on(eventName, listener)`.\n                 * @since v0.1.26\n                 */\n                addListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Adds the `listener` function to the end of the listeners array for the\n                 * event named `eventName`. No checks are made to see if the `listener` has\n                 * already been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\n                 * times.\n                 *\n                 * ```js\n                 * server.on('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 *\n                 * By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the\n                 * event listener to the beginning of the listeners array.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEE = new EventEmitter();\n                 * myEE.on('foo', () => console.log('a'));\n                 * myEE.prependListener('foo', () => console.log('b'));\n                 * myEE.emit('foo');\n                 * // Prints:\n                 * //   b\n                 * //   a\n                 * ```\n                 * @since v0.1.101\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Adds a **one-time**`listener` function for the event named `eventName`. The\n                 * next time `eventName` is triggered, this listener is removed and then invoked.\n                 *\n                 * ```js\n                 * server.once('connection', (stream) => {\n                 *   console.log('Ah, we have our first user!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 *\n                 * By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the\n                 * event listener to the beginning of the listeners array.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEE = new EventEmitter();\n                 * myEE.once('foo', () => console.log('a'));\n                 * myEE.prependOnceListener('foo', () => console.log('b'));\n                 * myEE.emit('foo');\n                 * // Prints:\n                 * //   b\n                 * //   a\n                 * ```\n                 * @since v0.3.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                once(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Removes the specified `listener` from the listener array for the event named`eventName`.\n                 *\n                 * ```js\n                 * const callback = (stream) => {\n                 *   console.log('someone connected!');\n                 * };\n                 * server.on('connection', callback);\n                 * // ...\n                 * server.removeListener('connection', callback);\n                 * ```\n                 *\n                 * `removeListener()` will remove, at most, one instance of a listener from the\n                 * listener array. If any single listener has been added multiple times to the\n                 * listener array for the specified `eventName`, then `removeListener()` must be\n                 * called multiple times to remove each instance.\n                 *\n                 * Once an event is emitted, all listeners attached to it at the\n                 * time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\n                 * will not remove them from`emit()` in progress. Subsequent events behave as expected.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * class MyEmitter extends EventEmitter {}\n                 * const myEmitter = new MyEmitter();\n                 *\n                 * const callbackA = () => {\n                 *   console.log('A');\n                 *   myEmitter.removeListener('event', callbackB);\n                 * };\n                 *\n                 * const callbackB = () => {\n                 *   console.log('B');\n                 * };\n                 *\n                 * myEmitter.on('event', callbackA);\n                 *\n                 * myEmitter.on('event', callbackB);\n                 *\n                 * // callbackA removes listener callbackB but it will still be called.\n                 * // Internal listener array at time of emit [callbackA, callbackB]\n                 * myEmitter.emit('event');\n                 * // Prints:\n                 * //   A\n                 * //   B\n                 *\n                 * // callbackB is now removed.\n                 * // Internal listener array [callbackA]\n                 * myEmitter.emit('event');\n                 * // Prints:\n                 * //   A\n                 * ```\n                 *\n                 * Because listeners are managed using an internal array, calling this will\n                 * change the position indices of any listener registered _after_ the listener\n                 * being removed. This will not impact the order in which listeners are called,\n                 * but it means that any copies of the listener array as returned by\n                 * the `emitter.listeners()` method will need to be recreated.\n                 *\n                 * When a single function has been added as a handler multiple times for a single\n                 * event (as in the example below), `removeListener()` will remove the most\n                 * recently added instance. In the example the `once('ping')`listener is removed:\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const ee = new EventEmitter();\n                 *\n                 * function pong() {\n                 *   console.log('pong');\n                 * }\n                 *\n                 * ee.on('ping', pong);\n                 * ee.once('ping', pong);\n                 * ee.removeListener('ping', pong);\n                 *\n                 * ee.emit('ping');\n                 * ee.emit('ping');\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.1.26\n                 */\n                removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Alias for `emitter.removeListener()`.\n                 * @since v10.0.0\n                 */\n                off(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Removes all listeners, or those of the specified `eventName`.\n                 *\n                 * It is bad practice to remove listeners added elsewhere in the code,\n                 * particularly when the `EventEmitter` instance was created by some other\n                 * component or module (e.g. sockets or file streams).\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.1.26\n                 */\n                removeAllListeners(event?: string | symbol): this;\n                /**\n                 * By default `EventEmitter`s will print a warning if more than `10` listeners are\n                 * added for a particular event. This is a useful default that helps finding\n                 * memory leaks. The `emitter.setMaxListeners()` method allows the limit to be\n                 * modified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.3.5\n                 */\n                setMaxListeners(n: number): this;\n                /**\n                 * Returns the current max listener value for the `EventEmitter` which is either\n                 * set by `emitter.setMaxListeners(n)` or defaults to {@link defaultMaxListeners}.\n                 * @since v1.0.0\n                 */\n                getMaxListeners(): number;\n                /**\n                 * Returns a copy of the array of listeners for the event named `eventName`.\n                 *\n                 * ```js\n                 * server.on('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * console.log(util.inspect(server.listeners('connection')));\n                 * // Prints: [ [Function] ]\n                 * ```\n                 * @since v0.1.26\n                 */\n                listeners(eventName: string | symbol): Function[];\n                /**\n                 * Returns a copy of the array of listeners for the event named `eventName`,\n                 * including any wrappers (such as those created by `.once()`).\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const emitter = new EventEmitter();\n                 * emitter.once('log', () => console.log('log once'));\n                 *\n                 * // Returns a new Array with a function `onceWrapper` which has a property\n                 * // `listener` which contains the original listener bound above\n                 * const listeners = emitter.rawListeners('log');\n                 * const logFnWrapper = listeners[0];\n                 *\n                 * // Logs \"log once\" to the console and does not unbind the `once` event\n                 * logFnWrapper.listener();\n                 *\n                 * // Logs \"log once\" to the console and removes the listener\n                 * logFnWrapper();\n                 *\n                 * emitter.on('log', () => console.log('log persistently'));\n                 * // Will return a new Array with a single function bound by `.on()` above\n                 * const newListeners = emitter.rawListeners('log');\n                 *\n                 * // Logs \"log persistently\" twice\n                 * newListeners[0]();\n                 * emitter.emit('log');\n                 * ```\n                 * @since v9.4.0\n                 */\n                rawListeners(eventName: string | symbol): Function[];\n                /**\n                 * Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments\n                 * to each.\n                 *\n                 * Returns `true` if the event had listeners, `false` otherwise.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEmitter = new EventEmitter();\n                 *\n                 * // First listener\n                 * myEmitter.on('event', function firstListener() {\n                 *   console.log('Helloooo! first listener');\n                 * });\n                 * // Second listener\n                 * myEmitter.on('event', function secondListener(arg1, arg2) {\n                 *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n                 * });\n                 * // Third listener\n                 * myEmitter.on('event', function thirdListener(...args) {\n                 *   const parameters = args.join(', ');\n                 *   console.log(`event with parameters ${parameters} in third listener`);\n                 * });\n                 *\n                 * console.log(myEmitter.listeners('event'));\n                 *\n                 * myEmitter.emit('event', 1, 2, 3, 4, 5);\n                 *\n                 * // Prints:\n                 * // [\n                 * //   [Function: firstListener],\n                 * //   [Function: secondListener],\n                 * //   [Function: thirdListener]\n                 * // ]\n                 * // Helloooo! first listener\n                 * // event with parameters 1, 2 in second listener\n                 * // event with parameters 1, 2, 3, 4, 5 in third listener\n                 * ```\n                 * @since v0.1.26\n                 */\n                emit(eventName: string | symbol, ...args: any[]): boolean;\n                /**\n                 * Returns the number of listeners listening for the event named `eventName`.\n                 * If `listener` is provided, it will return how many times the listener is found\n                 * in the list of the listeners of the event.\n                 * @since v3.2.0\n                 * @param eventName The name of the event being listened for\n                 * @param listener The event handler function\n                 */\n                listenerCount(eventName: string | symbol, listener?: Function): number;\n                /**\n                 * Adds the `listener` function to the _beginning_ of the listeners array for the\n                 * event named `eventName`. No checks are made to see if the `listener` has\n                 * already been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\n                 * times.\n                 *\n                 * ```js\n                 * server.prependListener('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v6.0.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                prependListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\n                 * listener is removed, and then invoked.\n                 *\n                 * ```js\n                 * server.prependOnceListener('connection', (stream) => {\n                 *   console.log('Ah, we have our first user!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v6.0.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n                /**\n                 * Returns an array listing the events for which the emitter has registered\n                 * listeners. The values in the array are strings or `Symbol`s.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 *\n                 * const myEE = new EventEmitter();\n                 * myEE.on('foo', () => {});\n                 * myEE.on('bar', () => {});\n                 *\n                 * const sym = Symbol('symbol');\n                 * myEE.on(sym, () => {});\n                 *\n                 * console.log(myEE.eventNames());\n                 * // Prints: [ 'foo', 'bar', Symbol(symbol) ]\n                 * ```\n                 * @since v6.0.0\n                 */\n                eventNames(): Array<string | symbol>;\n            }\n        }\n    }\n    export = EventEmitter;\n}\ndeclare module \"node:events\" {\n    import events = require(\"events\");\n    export = events;\n}\n"},14274:e=>{e.exports="declare module \"path/posix\" {\n    import path = require(\"path\");\n    export = path;\n}\ndeclare module \"path/win32\" {\n    import path = require(\"path\");\n    export = path;\n}\n/**\n * The `node:path` module provides utilities for working with file and directory\n * paths. It can be accessed using:\n *\n * ```js\n * const path = require('node:path');\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/path.js)\n */\ndeclare module \"path\" {\n    namespace path {\n        /**\n         * A parsed path object generated by path.parse() or consumed by path.format().\n         */\n        interface ParsedPath {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root: string;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir: string;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base: string;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext: string;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name: string;\n        }\n        interface FormatInputPathObject {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root?: string | undefined;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir?: string | undefined;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base?: string | undefined;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext?: string | undefined;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name?: string | undefined;\n        }\n        interface PlatformPath {\n            /**\n             * Normalize a string path, reducing '..' and '.' parts.\n             * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n             *\n             * @param path string path to normalize.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            normalize(path: string): string;\n            /**\n             * Join all arguments together and normalize the resulting path.\n             *\n             * @param paths paths to join.\n             * @throws {TypeError} if any of the path segments is not a string.\n             */\n            join(...paths: string[]): string;\n            /**\n             * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.\n             *\n             * Starting from leftmost {from} parameter, resolves {to} to an absolute path.\n             *\n             * If {to} isn't already absolute, {from} arguments are prepended in right to left order,\n             * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n             * the current working directory is used as well. The resulting path is normalized,\n             * and trailing slashes are removed unless the path gets resolved to the root directory.\n             *\n             * @param paths A sequence of paths or path segments.\n             * @throws {TypeError} if any of the arguments is not a string.\n             */\n            resolve(...paths: string[]): string;\n            /**\n             * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n             *\n             * If the given {path} is a zero-length string, `false` will be returned.\n             *\n             * @param path path to test.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            isAbsolute(path: string): boolean;\n            /**\n             * Solve the relative path from {from} to {to} based on the current working directory.\n             * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n             *\n             * @throws {TypeError} if either `from` or `to` is not a string.\n             */\n            relative(from: string, to: string): string;\n            /**\n             * Return the directory name of a path. Similar to the Unix dirname command.\n             *\n             * @param path the path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            dirname(path: string): string;\n            /**\n             * Return the last portion of a path. Similar to the Unix basename command.\n             * Often used to extract the file name from a fully qualified path.\n             *\n             * @param path the path to evaluate.\n             * @param suffix optionally, an extension to remove from the result.\n             * @throws {TypeError} if `path` is not a string or if `ext` is given and is not a string.\n             */\n            basename(path: string, suffix?: string): string;\n            /**\n             * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\n             * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.\n             *\n             * @param path the path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            extname(path: string): string;\n            /**\n             * The platform-specific file separator. '\\\\' or '/'.\n             */\n            readonly sep: \"\\\\\" | \"/\";\n            /**\n             * The platform-specific file delimiter. ';' or ':'.\n             */\n            readonly delimiter: \";\" | \":\";\n            /**\n             * Returns an object from a path string - the opposite of format().\n             *\n             * @param path path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            parse(path: string): ParsedPath;\n            /**\n             * Returns a path string from an object - the opposite of parse().\n             *\n             * @param pathObject path to evaluate.\n             */\n            format(pathObject: FormatInputPathObject): string;\n            /**\n             * On Windows systems only, returns an equivalent namespace-prefixed path for the given path.\n             * If path is not a string, path will be returned without modifications.\n             * This method is meaningful only on Windows system.\n             * On POSIX systems, the method is non-operational and always returns path without modifications.\n             */\n            toNamespacedPath(path: string): string;\n            /**\n             * Posix specific pathing.\n             * Same as parent object on posix.\n             */\n            readonly posix: PlatformPath;\n            /**\n             * Windows specific pathing.\n             * Same as parent object on windows\n             */\n            readonly win32: PlatformPath;\n        }\n    }\n    const path: path.PlatformPath;\n    export = path;\n}\ndeclare module \"node:path\" {\n    import path = require(\"path\");\n    export = path;\n}\ndeclare module \"node:path/posix\" {\n    import path = require(\"path/posix\");\n    export = path;\n}\ndeclare module \"node:path/win32\" {\n    import path = require(\"path/win32\");\n    export = path;\n}\n"},40482:e=>{e.exports="/**\n * **The version of the punycode module bundled in Node.js is being deprecated.**In a future major version of Node.js this module will be removed. Users\n * currently depending on the `punycode` module should switch to using the\n * userland-provided [Punycode.js](https://github.com/bestiejs/punycode.js) module instead. For punycode-based URL\n * encoding, see `url.domainToASCII` or, more generally, the `WHATWG URL API`.\n *\n * The `punycode` module is a bundled version of the [Punycode.js](https://github.com/bestiejs/punycode.js) module. It\n * can be accessed using:\n *\n * ```js\n * const punycode = require('punycode');\n * ```\n *\n * [Punycode](https://tools.ietf.org/html/rfc3492) is a character encoding scheme defined by RFC 3492 that is\n * primarily intended for use in Internationalized Domain Names. Because host\n * names in URLs are limited to ASCII characters only, Domain Names that contain\n * non-ASCII characters must be converted into ASCII using the Punycode scheme.\n * For instance, the Japanese character that translates into the English word,`'example'` is `'例'`. The Internationalized Domain Name, `'例.com'` (equivalent\n * to `'example.com'`) is represented by Punycode as the ASCII string`'xn--fsq.com'`.\n *\n * The `punycode` module provides a simple implementation of the Punycode standard.\n *\n * The `punycode` module is a third-party dependency used by Node.js and\n * made available to developers as a convenience. Fixes or other modifications to\n * the module must be directed to the [Punycode.js](https://github.com/bestiejs/punycode.js) project.\n * @deprecated Since v7.0.0 - Deprecated\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/punycode.js)\n */\ndeclare module \"punycode\" {\n    /**\n     * The `punycode.decode()` method converts a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only\n     * characters to the equivalent string of Unicode codepoints.\n     *\n     * ```js\n     * punycode.decode('maana-pta'); // 'mañana'\n     * punycode.decode('--dqo34k'); // '☃-⌘'\n     * ```\n     * @since v0.5.1\n     */\n    function decode(string: string): string;\n    /**\n     * The `punycode.encode()` method converts a string of Unicode codepoints to a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only characters.\n     *\n     * ```js\n     * punycode.encode('mañana'); // 'maana-pta'\n     * punycode.encode('☃-⌘'); // '--dqo34k'\n     * ```\n     * @since v0.5.1\n     */\n    function encode(string: string): string;\n    /**\n     * The `punycode.toUnicode()` method converts a string representing a domain name\n     * containing [Punycode](https://tools.ietf.org/html/rfc3492) encoded characters into Unicode. Only the [Punycode](https://tools.ietf.org/html/rfc3492) encoded parts of the domain name are be\n     * converted.\n     *\n     * ```js\n     * // decode domain names\n     * punycode.toUnicode('xn--maana-pta.com'); // 'mañana.com'\n     * punycode.toUnicode('xn----dqo34k.com');  // '☃-⌘.com'\n     * punycode.toUnicode('example.com');       // 'example.com'\n     * ```\n     * @since v0.6.1\n     */\n    function toUnicode(domain: string): string;\n    /**\n     * The `punycode.toASCII()` method converts a Unicode string representing an\n     * Internationalized Domain Name to [Punycode](https://tools.ietf.org/html/rfc3492). Only the non-ASCII parts of the\n     * domain name will be converted. Calling `punycode.toASCII()` on a string that\n     * already only contains ASCII characters will have no effect.\n     *\n     * ```js\n     * // encode domain names\n     * punycode.toASCII('mañana.com');  // 'xn--maana-pta.com'\n     * punycode.toASCII('☃-⌘.com');   // 'xn----dqo34k.com'\n     * punycode.toASCII('example.com'); // 'example.com'\n     * ```\n     * @since v0.6.1\n     */\n    function toASCII(domain: string): string;\n    /**\n     * @deprecated since v7.0.0\n     * The version of the punycode module bundled in Node.js is being deprecated.\n     * In a future major version of Node.js this module will be removed.\n     * Users currently depending on the punycode module should switch to using\n     * the userland-provided Punycode.js module instead.\n     */\n    const ucs2: ucs2;\n    interface ucs2 {\n        /**\n         * @deprecated since v7.0.0\n         * The version of the punycode module bundled in Node.js is being deprecated.\n         * In a future major version of Node.js this module will be removed.\n         * Users currently depending on the punycode module should switch to using\n         * the userland-provided Punycode.js module instead.\n         */\n        decode(string: string): number[];\n        /**\n         * @deprecated since v7.0.0\n         * The version of the punycode module bundled in Node.js is being deprecated.\n         * In a future major version of Node.js this module will be removed.\n         * Users currently depending on the punycode module should switch to using\n         * the userland-provided Punycode.js module instead.\n         */\n        encode(codePoints: readonly number[]): string;\n    }\n    /**\n     * @deprecated since v7.0.0\n     * The version of the punycode module bundled in Node.js is being deprecated.\n     * In a future major version of Node.js this module will be removed.\n     * Users currently depending on the punycode module should switch to using\n     * the userland-provided Punycode.js module instead.\n     */\n    const version: string;\n}\ndeclare module \"node:punycode\" {\n    export * from \"punycode\";\n}\n"},33632:e=>{e.exports="/**\n * The `node:querystring` module provides utilities for parsing and formatting URL\n * query strings. It can be accessed using:\n *\n * ```js\n * const querystring = require('node:querystring');\n * ```\n *\n * `querystring` is more performant than `URLSearchParams` but is not a\n * standardized API. Use `URLSearchParams` when performance is not critical or\n * when compatibility with browser code is desirable.\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/querystring.js)\n */\ndeclare module \"querystring\" {\n    interface StringifyOptions {\n        encodeURIComponent?: ((str: string) => string) | undefined;\n    }\n    interface ParseOptions {\n        maxKeys?: number | undefined;\n        decodeURIComponent?: ((str: string) => string) | undefined;\n    }\n    interface ParsedUrlQuery extends NodeJS.Dict<string | string[]> {}\n    interface ParsedUrlQueryInput extends\n        NodeJS.Dict<\n            | string\n            | number\n            | boolean\n            | readonly string[]\n            | readonly number[]\n            | readonly boolean[]\n            | null\n        >\n    {}\n    /**\n     * The `querystring.stringify()` method produces a URL query string from a\n     * given `obj` by iterating through the object's \"own properties\".\n     *\n     * It serializes the following types of values passed in `obj`:[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |\n     * [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |\n     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |\n     * [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) |\n     * [string\\[\\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |\n     * [number\\[\\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |\n     * [bigint\\[\\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |\n     * [boolean\\[\\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) The numeric values must be finite. Any other input values will be coerced to\n     * empty strings.\n     *\n     * ```js\n     * querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });\n     * // Returns 'foo=bar&#x26;baz=qux&#x26;baz=quux&#x26;corge='\n     *\n     * querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');\n     * // Returns 'foo:bar;baz:qux'\n     * ```\n     *\n     * By default, characters requiring percent-encoding within the query string will\n     * be encoded as UTF-8\\. If an alternative encoding is required, then an alternative`encodeURIComponent` option will need to be specified:\n     *\n     * ```js\n     * // Assuming gbkEncodeURIComponent function already exists,\n     *\n     * querystring.stringify({ w: '中文', foo: 'bar' }, null, null,\n     *                       { encodeURIComponent: gbkEncodeURIComponent });\n     * ```\n     * @since v0.1.25\n     * @param obj The object to serialize into a URL query string\n     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.\n     * @param [eq='='] . The substring used to delimit keys and values in the query string.\n     */\n    function stringify(obj?: ParsedUrlQueryInput, sep?: string, eq?: string, options?: StringifyOptions): string;\n    /**\n     * The `querystring.parse()` method parses a URL query string (`str`) into a\n     * collection of key and value pairs.\n     *\n     * For example, the query string `'foo=bar&#x26;abc=xyz&#x26;abc=123'` is parsed into:\n     *\n     * ```json\n     * {\n     *   \"foo\": \"bar\",\n     *   \"abc\": [\"xyz\", \"123\"]\n     * }\n     * ```\n     *\n     * The object returned by the `querystring.parse()` method _does not_prototypically inherit from the JavaScript `Object`. This means that typical`Object` methods such as `obj.toString()`,\n     * `obj.hasOwnProperty()`, and others\n     * are not defined and _will not work_.\n     *\n     * By default, percent-encoded characters within the query string will be assumed\n     * to use UTF-8 encoding. If an alternative character encoding is used, then an\n     * alternative `decodeURIComponent` option will need to be specified:\n     *\n     * ```js\n     * // Assuming gbkDecodeURIComponent function already exists...\n     *\n     * querystring.parse('w=%D6%D0%CE%C4&#x26;foo=bar', null, null,\n     *                   { decodeURIComponent: gbkDecodeURIComponent });\n     * ```\n     * @since v0.1.25\n     * @param str The URL query string to parse\n     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.\n     * @param [eq='='] . The substring used to delimit keys and values in the query string.\n     */\n    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\n    /**\n     * The querystring.encode() function is an alias for querystring.stringify().\n     */\n    const encode: typeof stringify;\n    /**\n     * The querystring.decode() function is an alias for querystring.parse().\n     */\n    const decode: typeof parse;\n    /**\n     * The `querystring.escape()` method performs URL percent-encoding on the given`str` in a manner that is optimized for the specific requirements of URL\n     * query strings.\n     *\n     * The `querystring.escape()` method is used by `querystring.stringify()` and is\n     * generally not expected to be used directly. It is exported primarily to allow\n     * application code to provide a replacement percent-encoding implementation if\n     * necessary by assigning `querystring.escape` to an alternative function.\n     * @since v0.1.25\n     */\n    function escape(str: string): string;\n    /**\n     * The `querystring.unescape()` method performs decoding of URL percent-encoded\n     * characters on the given `str`.\n     *\n     * The `querystring.unescape()` method is used by `querystring.parse()` and is\n     * generally not expected to be used directly. It is exported primarily to allow\n     * application code to provide a replacement decoding implementation if\n     * necessary by assigning `querystring.unescape` to an alternative function.\n     *\n     * By default, the `querystring.unescape()` method will attempt to use the\n     * JavaScript built-in `decodeURIComponent()` method to decode. If that fails,\n     * a safer equivalent that does not throw on malformed URLs will be used.\n     * @since v0.1.25\n     */\n    function unescape(str: string): string;\n}\ndeclare module \"node:querystring\" {\n    export * from \"querystring\";\n}\n"},89857:e=>{e.exports='/**\n * A stream is an abstract interface for working with streaming data in Node.js.\n * The `node:stream` module provides an API for implementing the stream interface.\n *\n * There are many stream objects provided by Node.js. For instance, a `request to an HTTP server` and `process.stdout` are both stream instances.\n *\n * Streams can be readable, writable, or both. All streams are instances of `EventEmitter`.\n *\n * To access the `node:stream` module:\n *\n * ```js\n * const stream = require(\'node:stream\');\n * ```\n *\n * The `node:stream` module is useful for creating new types of stream instances.\n * It is usually not necessary to use the `node:stream` module to consume streams.\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/stream.js)\n */\ndeclare module "stream" {\n    import { Abortable, EventEmitter } from "node:events";\n    import { Blob as NodeBlob } from "node:buffer";\n    import * as streamPromises from "node:stream/promises";\n    import * as streamConsumers from "node:stream/consumers";\n    import * as streamWeb from "node:stream/web";\n\n    type ComposeFnParam = (source: any) => void;\n\n    class internal extends EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(\n            destination: T,\n            options?: {\n                end?: boolean | undefined;\n            },\n        ): T;\n        compose<T extends NodeJS.ReadableStream>(\n            stream: T | ComposeFnParam | Iterable<T> | AsyncIterable<T>,\n            options?: { signal: AbortSignal },\n        ): T;\n    }\n    import Stream = internal.Stream;\n    import Readable = internal.Readable;\n    import ReadableOptions = internal.ReadableOptions;\n    interface ArrayOptions {\n        /** the maximum concurrent invocations of `fn` to call on the stream at once. **Default: 1**. */\n        concurrency?: number;\n        /** allows destroying the stream if the signal is aborted. */\n        signal?: AbortSignal;\n    }\n    class ReadableBase extends Stream implements NodeJS.ReadableStream {\n        /**\n         * A utility method for creating Readable Streams out of iterators.\n         */\n        static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;\n        /**\n         * Returns whether the stream has been read from or cancelled.\n         * @since v16.8.0\n         */\n        static isDisturbed(stream: Readable | NodeJS.ReadableStream): boolean;\n        /**\n         * Returns whether the stream was destroyed or errored before emitting `\'end\'`.\n         * @since v16.8.0\n         * @experimental\n         */\n        readonly readableAborted: boolean;\n        /**\n         * Is `true` if it is safe to call `readable.read()`, which means\n         * the stream has not been destroyed or emitted `\'error\'` or `\'end\'`.\n         * @since v11.4.0\n         */\n        readable: boolean;\n        /**\n         * Returns whether `\'data\'` has been emitted.\n         * @since v16.7.0, v14.18.0\n         * @experimental\n         */\n        readonly readableDidRead: boolean;\n        /**\n         * Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.\n         * @since v12.7.0\n         */\n        readonly readableEncoding: BufferEncoding | null;\n        /**\n         * Becomes `true` when `\'end\'` event is emitted.\n         * @since v12.9.0\n         */\n        readonly readableEnded: boolean;\n        /**\n         * This property reflects the current state of a `Readable` stream as described\n         * in the `Three states` section.\n         * @since v9.4.0\n         */\n        readonly readableFlowing: boolean | null;\n        /**\n         * Returns the value of `highWaterMark` passed when creating this `Readable`.\n         * @since v9.3.0\n         */\n        readonly readableHighWaterMark: number;\n        /**\n         * This property contains the number of bytes (or objects) in the queue\n         * ready to be read. The value provides introspection data regarding\n         * the status of the `highWaterMark`.\n         * @since v9.4.0\n         */\n        readonly readableLength: number;\n        /**\n         * Getter for the property `objectMode` of a given `Readable` stream.\n         * @since v12.3.0\n         */\n        readonly readableObjectMode: boolean;\n        /**\n         * Is `true` after `readable.destroy()` has been called.\n         * @since v8.0.0\n         */\n        destroyed: boolean;\n        /**\n         * Is `true` after `\'close\'` has been emitted.\n         * @since v18.0.0\n         */\n        readonly closed: boolean;\n        /**\n         * Returns error if the stream has been destroyed with an error.\n         * @since v18.0.0\n         */\n        readonly errored: Error | null;\n        constructor(opts?: ReadableOptions);\n        _construct?(callback: (error?: Error | null) => void): void;\n        _read(size: number): void;\n        /**\n         * The `readable.read()` method reads data out of the internal buffer and\n         * returns it. If no data is available to be read, `null` is returned. By default,\n         * the data is returned as a `Buffer` object unless an encoding has been\n         * specified using the `readable.setEncoding()` method or the stream is operating\n         * in object mode.\n         *\n         * The optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which\n         * case all of the data remaining in the internal\n         * buffer will be returned.\n         *\n         * If the `size` argument is not specified, all of the data contained in the\n         * internal buffer will be returned.\n         *\n         * The `size` argument must be less than or equal to 1 GiB.\n         *\n         * The `readable.read()` method should only be called on `Readable` streams\n         * operating in paused mode. In flowing mode, `readable.read()` is called\n         * automatically until the internal buffer is fully drained.\n         *\n         * ```js\n         * const readable = getReadableStreamSomehow();\n         *\n         * // \'readable\' may be triggered multiple times as data is buffered in\n         * readable.on(\'readable\', () => {\n         *   let chunk;\n         *   console.log(\'Stream is readable (new data received in buffer)\');\n         *   // Use a loop to make sure we read all currently available data\n         *   while (null !== (chunk = readable.read())) {\n         *     console.log(`Read ${chunk.length} bytes of data...`);\n         *   }\n         * });\n         *\n         * // \'end\' will be triggered once when there is no more data available\n         * readable.on(\'end\', () => {\n         *   console.log(\'Reached end of stream.\');\n         * });\n         * ```\n         *\n         * Each call to `readable.read()` returns a chunk of data, or `null`. The chunks\n         * are not concatenated. A `while` loop is necessary to consume all data\n         * currently in the buffer. When reading a large file `.read()` may return `null`,\n         * having consumed all buffered content so far, but there is still more data to\n         * come not yet buffered. In this case a new `\'readable\'` event will be emitted\n         * when there is more data in the buffer. Finally the `\'end\'` event will be\n         * emitted when there is no more data to come.\n         *\n         * Therefore to read a file\'s whole contents from a `readable`, it is necessary\n         * to collect chunks across multiple `\'readable\'` events:\n         *\n         * ```js\n         * const chunks = [];\n         *\n         * readable.on(\'readable\', () => {\n         *   let chunk;\n         *   while (null !== (chunk = readable.read())) {\n         *     chunks.push(chunk);\n         *   }\n         * });\n         *\n         * readable.on(\'end\', () => {\n         *   const content = chunks.join(\'\');\n         * });\n         * ```\n         *\n         * A `Readable` stream in object mode will always return a single item from\n         * a call to `readable.read(size)`, regardless of the value of the`size` argument.\n         *\n         * If the `readable.read()` method returns a chunk of data, a `\'data\'` event will\n         * also be emitted.\n         *\n         * Calling {@link read} after the `\'end\'` event has\n         * been emitted will return `null`. No runtime error will be raised.\n         * @since v0.9.4\n         * @param size Optional argument to specify how much data to read.\n         */\n        read(size?: number): any;\n        /**\n         * The `readable.setEncoding()` method sets the character encoding for\n         * data read from the `Readable` stream.\n         *\n         * By default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data\n         * to be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding(\'utf8\')` will cause the\n         * output data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding(\'hex\')` will cause the data to be encoded in hexadecimal\n         * string format.\n         *\n         * The `Readable` stream will properly handle multi-byte characters delivered\n         * through the stream that would otherwise become improperly decoded if simply\n         * pulled from the stream as `Buffer` objects.\n         *\n         * ```js\n         * const readable = getReadableStreamSomehow();\n         * readable.setEncoding(\'utf8\');\n         * readable.on(\'data\', (chunk) => {\n         *   assert.equal(typeof chunk, \'string\');\n         *   console.log(\'Got %d characters of string data:\', chunk.length);\n         * });\n         * ```\n         * @since v0.9.4\n         * @param encoding The encoding to use.\n         */\n        setEncoding(encoding: BufferEncoding): this;\n        /**\n         * The `readable.pause()` method will cause a stream in flowing mode to stop\n         * emitting `\'data\'` events, switching out of flowing mode. Any data that\n         * becomes available will remain in the internal buffer.\n         *\n         * ```js\n         * const readable = getReadableStreamSomehow();\n         * readable.on(\'data\', (chunk) => {\n         *   console.log(`Received ${chunk.length} bytes of data.`);\n         *   readable.pause();\n         *   console.log(\'There will be no additional data for 1 second.\');\n         *   setTimeout(() => {\n         *     console.log(\'Now data will start flowing again.\');\n         *     readable.resume();\n         *   }, 1000);\n         * });\n         * ```\n         *\n         * The `readable.pause()` method has no effect if there is a `\'readable\'`event listener.\n         * @since v0.9.4\n         */\n        pause(): this;\n        /**\n         * The `readable.resume()` method causes an explicitly paused `Readable` stream to\n         * resume emitting `\'data\'` events, switching the stream into flowing mode.\n         *\n         * The `readable.resume()` method can be used to fully consume the data from a\n         * stream without actually processing any of that data:\n         *\n         * ```js\n         * getReadableStreamSomehow()\n         *   .resume()\n         *   .on(\'end\', () => {\n         *     console.log(\'Reached the end, but did not read anything.\');\n         *   });\n         * ```\n         *\n         * The `readable.resume()` method has no effect if there is a `\'readable\'`event listener.\n         * @since v0.9.4\n         */\n        resume(): this;\n        /**\n         * The `readable.isPaused()` method returns the current operating state of the`Readable`. This is used primarily by the mechanism that underlies the`readable.pipe()` method. In most\n         * typical cases, there will be no reason to\n         * use this method directly.\n         *\n         * ```js\n         * const readable = new stream.Readable();\n         *\n         * readable.isPaused(); // === false\n         * readable.pause();\n         * readable.isPaused(); // === true\n         * readable.resume();\n         * readable.isPaused(); // === false\n         * ```\n         * @since v0.11.14\n         */\n        isPaused(): boolean;\n        /**\n         * The `readable.unpipe()` method detaches a `Writable` stream previously attached\n         * using the {@link pipe} method.\n         *\n         * If the `destination` is not specified, then _all_ pipes are detached.\n         *\n         * If the `destination` is specified, but no pipe is set up for it, then\n         * the method does nothing.\n         *\n         * ```js\n         * const fs = require(\'node:fs\');\n         * const readable = getReadableStreamSomehow();\n         * const writable = fs.createWriteStream(\'file.txt\');\n         * // All the data from readable goes into \'file.txt\',\n         * // but only for the first second.\n         * readable.pipe(writable);\n         * setTimeout(() => {\n         *   console.log(\'Stop writing to file.txt.\');\n         *   readable.unpipe(writable);\n         *   console.log(\'Manually close the file stream.\');\n         *   writable.end();\n         * }, 1000);\n         * ```\n         * @since v0.9.4\n         * @param destination Optional specific stream to unpipe\n         */\n        unpipe(destination?: NodeJS.WritableStream): this;\n        /**\n         * Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\n         * same as `readable.push(null)`, after which no more data can be written. The EOF\n         * signal is put at the end of the buffer and any buffered data will still be\n         * flushed.\n         *\n         * The `readable.unshift()` method pushes a chunk of data back into the internal\n         * buffer. This is useful in certain situations where a stream is being consumed by\n         * code that needs to "un-consume" some amount of data that it has optimistically\n         * pulled out of the source, so that the data can be passed on to some other party.\n         *\n         * The `stream.unshift(chunk)` method cannot be called after the `\'end\'` event\n         * has been emitted or a runtime error will be thrown.\n         *\n         * Developers using `stream.unshift()` often should consider switching to\n         * use of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n         *\n         * ```js\n         * // Pull off a header delimited by \\n\\n.\n         * // Use unshift() if we get too much.\n         * // Call the callback with (error, header, stream).\n         * const { StringDecoder } = require(\'node:string_decoder\');\n         * function parseHeader(stream, callback) {\n         *   stream.on(\'error\', callback);\n         *   stream.on(\'readable\', onReadable);\n         *   const decoder = new StringDecoder(\'utf8\');\n         *   let header = \'\';\n         *   function onReadable() {\n         *     let chunk;\n         *     while (null !== (chunk = stream.read())) {\n         *       const str = decoder.write(chunk);\n         *       if (str.includes(\'\\n\\n\')) {\n         *         // Found the header boundary.\n         *         const split = str.split(/\\n\\n/);\n         *         header += split.shift();\n         *         const remaining = split.join(\'\\n\\n\');\n         *         const buf = Buffer.from(remaining, \'utf8\');\n         *         stream.removeListener(\'error\', callback);\n         *         // Remove the \'readable\' listener before unshifting.\n         *         stream.removeListener(\'readable\', onReadable);\n         *         if (buf.length)\n         *           stream.unshift(buf);\n         *         // Now the body of the message can be read from the stream.\n         *         callback(null, header, stream);\n         *         return;\n         *       }\n         *       // Still reading the header.\n         *       header += str;\n         *     }\n         *   }\n         * }\n         * ```\n         *\n         * Unlike {@link push}, `stream.unshift(chunk)` will not\n         * end the reading process by resetting the internal reading state of the stream.\n         * This can cause unexpected results if `readable.unshift()` is called during a\n         * read (i.e. from within a {@link _read} implementation on a\n         * custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,\n         * however it is best to simply avoid calling `readable.unshift()` while in the\n         * process of performing a read.\n         * @since v0.9.11\n         * @param chunk Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must be a string, `Buffer`, `Uint8Array`, or `null`. For object mode\n         * streams, `chunk` may be any JavaScript value.\n         * @param encoding Encoding of string chunks. Must be a valid `Buffer` encoding, such as `\'utf8\'` or `\'ascii\'`.\n         */\n        unshift(chunk: any, encoding?: BufferEncoding): void;\n        /**\n         * Prior to Node.js 0.10, streams did not implement the entire `node:stream`module API as it is currently defined. (See `Compatibility` for more\n         * information.)\n         *\n         * When using an older Node.js library that emits `\'data\'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`\n         * stream that uses\n         * the old stream as its data source.\n         *\n         * It will rarely be necessary to use `readable.wrap()` but the method has been\n         * provided as a convenience for interacting with older Node.js applications and\n         * libraries.\n         *\n         * ```js\n         * const { OldReader } = require(\'./old-api-module.js\');\n         * const { Readable } = require(\'node:stream\');\n         * const oreader = new OldReader();\n         * const myReader = new Readable().wrap(oreader);\n         *\n         * myReader.on(\'readable\', () => {\n         *   myReader.read(); // etc.\n         * });\n         * ```\n         * @since v0.9.4\n         * @param stream An "old style" readable stream\n         */\n        wrap(stream: NodeJS.ReadableStream): this;\n        push(chunk: any, encoding?: BufferEncoding): boolean;\n        /**\n         * The iterator created by this method gives users the option to cancel the destruction\n         * of the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\n         * or if the iterator should destroy the stream if the stream emitted an error during iteration.\n         * @since v16.3.0\n         * @param options.destroyOnReturn When set to `false`, calling `return` on the async iterator,\n         * or exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n         * **Default: `true`**.\n         */\n        iterator(options?: { destroyOnReturn?: boolean }): AsyncIterableIterator<any>;\n        /**\n         * This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\n         * If the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.\n         * @since v17.4.0, v16.14.0\n         * @param fn a function to map over every chunk in the stream. Async or not.\n         * @returns a stream mapped with the function *fn*.\n         */\n        map(fn: (data: any, options?: Pick<ArrayOptions, "signal">) => any, options?: ArrayOptions): Readable;\n        /**\n         * This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\n         * and if it returns a truthy value, the chunk will be passed to the result stream.\n         * If the *fn* function returns a promise - that promise will be `await`ed.\n         * @since v17.4.0, v16.14.0\n         * @param fn a function to filter chunks from the stream. Async or not.\n         * @returns a stream filtered with the predicate *fn*.\n         */\n        filter(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Readable;\n        /**\n         * This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\n         * If the *fn* function returns a promise - that promise will be `await`ed.\n         *\n         * This method is different from `for await...of` loops in that it can optionally process chunks concurrently.\n         * In addition, a `forEach` iteration can only be stopped by having passed a `signal` option\n         * and aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\n         * In either case the stream will be destroyed.\n         *\n         * This method is different from listening to the `\'data\'` event in that it uses the `readable` event\n         * in the underlying machinary and can limit the number of concurrent *fn* calls.\n         * @since v17.5.0\n         * @param fn a function to call on each chunk of the stream. Async or not.\n         * @returns a promise for when the stream has finished.\n         */\n        forEach(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => void | Promise<void>,\n            options?: ArrayOptions,\n        ): Promise<void>;\n        /**\n         * This method allows easily obtaining the contents of a stream.\n         *\n         * As this method reads the entire stream into memory, it negates the benefits of streams. It\'s intended\n         * for interoperability and convenience, not as the primary way to consume streams.\n         * @since v17.5.0\n         * @returns a promise containing an array with the contents of the stream.\n         */\n        toArray(options?: Pick<ArrayOptions, "signal">): Promise<any[]>;\n        /**\n         * This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\n         * until the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n         * `await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\n         * If none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.\n         * @since v17.5.0\n         * @param fn a function to call on each chunk of the stream. Async or not.\n         * @returns a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.\n         */\n        some(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;\n        /**\n         * This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\n         * to find a chunk with a truthy value for *fn*. Once an *fn* call\'s awaited return value is truthy,\n         * the stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\n         * If all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.\n         * @since v17.5.0\n         * @param fn a function to call on each chunk of the stream. Async or not.\n         * @returns a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\n         * or `undefined` if no element was found.\n         */\n        find<T>(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => data is T,\n            options?: ArrayOptions,\n        ): Promise<T | undefined>;\n        find(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<any>;\n        /**\n         * This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\n         * to check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n         * `await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\n         * If all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.\n         * @since v17.5.0\n         * @param fn a function to call on each chunk of the stream. Async or not.\n         * @returns a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.\n         */\n        every(\n            fn: (data: any, options?: Pick<ArrayOptions, "signal">) => boolean | Promise<boolean>,\n            options?: ArrayOptions,\n        ): Promise<boolean>;\n        /**\n         * This method returns a new stream by applying the given callback to each chunk of the stream\n         * and then flattening the result.\n         *\n         * It is possible to return a stream or another iterable or async iterable from *fn* and the result streams\n         * will be merged (flattened) into the returned stream.\n         * @since v17.5.0\n         * @param fn a function to map over every chunk in the stream. May be async. May be a stream or generator.\n         * @returns a stream flat-mapped with the function *fn*.\n         */\n        flatMap(fn: (data: any, options?: Pick<ArrayOptions, "signal">) => any, options?: ArrayOptions): Readable;\n        /**\n         * This method returns a new stream with the first *limit* chunks dropped from the start.\n         * @since v17.5.0\n         * @param limit the number of chunks to drop from the readable.\n         * @returns a stream with *limit* chunks dropped from the start.\n         */\n        drop(limit: number, options?: Pick<ArrayOptions, "signal">): Readable;\n        /**\n         * This method returns a new stream with the first *limit* chunks.\n         * @since v17.5.0\n         * @param limit the number of chunks to take from the readable.\n         * @returns a stream with *limit* chunks taken.\n         */\n        take(limit: number, options?: Pick<ArrayOptions, "signal">): Readable;\n        /**\n         * This method returns a new stream with chunks of the underlying stream paired with a counter\n         * in the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.\n         * @since v17.5.0\n         * @returns a stream of indexed pairs.\n         */\n        asIndexedPairs(options?: Pick<ArrayOptions, "signal">): Readable;\n        /**\n         * This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\n         * on the previous element. It returns a promise for the final value of the reduction.\n         *\n         * If no *initial* value is supplied the first chunk of the stream is used as the initial value.\n         * If the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n         *\n         * The reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\n         * or parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.\n         * @since v17.5.0\n         * @param fn a reducer function to call over every chunk in the stream. Async or not.\n         * @param initial the initial value to use in the reduction.\n         * @returns a promise for the final value of the reduction.\n         */\n        reduce<T = any>(\n            fn: (previous: any, data: any, options?: Pick<ArrayOptions, "signal">) => T,\n            initial?: undefined,\n            options?: Pick<ArrayOptions, "signal">,\n        ): Promise<T>;\n        reduce<T = any>(\n            fn: (previous: T, data: any, options?: Pick<ArrayOptions, "signal">) => T,\n            initial: T,\n            options?: Pick<ArrayOptions, "signal">,\n        ): Promise<T>;\n        _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n        /**\n         * Destroy the stream. Optionally emit an `\'error\'` event, and emit a `\'close\'`event (unless `emitClose` is set to `false`). After this call, the readable\n         * stream will release any internal resources and subsequent calls to `push()`will be ignored.\n         *\n         * Once `destroy()` has been called any further calls will be a no-op and no\n         * further errors except from `_destroy()` may be emitted as `\'error\'`.\n         *\n         * Implementors should not override this method, but instead implement `readable._destroy()`.\n         * @since v8.0.0\n         * @param error Error which will be passed as payload in `\'error\'` event\n         */\n        destroy(error?: Error): this;\n        /**\n         * Event emitter\n         * The defined events on documents including:\n         * 1. close\n         * 2. data\n         * 3. end\n         * 4. error\n         * 5. pause\n         * 6. readable\n         * 7. resume\n         */\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "data", listener: (chunk: any) => void): this;\n        addListener(event: "end", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "pause", listener: () => void): this;\n        addListener(event: "readable", listener: () => void): this;\n        addListener(event: "resume", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: "close"): boolean;\n        emit(event: "data", chunk: any): boolean;\n        emit(event: "end"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "pause"): boolean;\n        emit(event: "readable"): boolean;\n        emit(event: "resume"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: "close", listener: () => void): this;\n        on(event: "data", listener: (chunk: any) => void): this;\n        on(event: "end", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "pause", listener: () => void): this;\n        on(event: "readable", listener: () => void): this;\n        on(event: "resume", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "data", listener: (chunk: any) => void): this;\n        once(event: "end", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "pause", listener: () => void): this;\n        once(event: "readable", listener: () => void): this;\n        once(event: "resume", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "data", listener: (chunk: any) => void): this;\n        prependListener(event: "end", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "pause", listener: () => void): this;\n        prependListener(event: "readable", listener: () => void): this;\n        prependListener(event: "resume", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "data", listener: (chunk: any) => void): this;\n        prependOnceListener(event: "end", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "pause", listener: () => void): this;\n        prependOnceListener(event: "readable", listener: () => void): this;\n        prependOnceListener(event: "resume", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: "close", listener: () => void): this;\n        removeListener(event: "data", listener: (chunk: any) => void): this;\n        removeListener(event: "end", listener: () => void): this;\n        removeListener(event: "error", listener: (err: Error) => void): this;\n        removeListener(event: "pause", listener: () => void): this;\n        removeListener(event: "readable", listener: () => void): this;\n        removeListener(event: "resume", listener: () => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        /**\n         * Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.\n         * @since v20.4.0\n         */\n        [Symbol.asyncDispose](): Promise<void>;\n    }\n    import WritableOptions = internal.WritableOptions;\n    class WritableBase extends Stream implements NodeJS.WritableStream {\n        /**\n         * Is `true` if it is safe to call `writable.write()`, which means\n         * the stream has not been destroyed, errored, or ended.\n         * @since v11.4.0\n         */\n        readonly writable: boolean;\n        /**\n         * Is `true` after `writable.end()` has been called. This property\n         * does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.\n         * @since v12.9.0\n         */\n        readonly writableEnded: boolean;\n        /**\n         * Is set to `true` immediately before the `\'finish\'` event is emitted.\n         * @since v12.6.0\n         */\n        readonly writableFinished: boolean;\n        /**\n         * Return the value of `highWaterMark` passed when creating this `Writable`.\n         * @since v9.3.0\n         */\n        readonly writableHighWaterMark: number;\n        /**\n         * This property contains the number of bytes (or objects) in the queue\n         * ready to be written. The value provides introspection data regarding\n         * the status of the `highWaterMark`.\n         * @since v9.4.0\n         */\n        readonly writableLength: number;\n        /**\n         * Getter for the property `objectMode` of a given `Writable` stream.\n         * @since v12.3.0\n         */\n        readonly writableObjectMode: boolean;\n        /**\n         * Number of times `writable.uncork()` needs to be\n         * called in order to fully uncork the stream.\n         * @since v13.2.0, v12.16.0\n         */\n        readonly writableCorked: number;\n        /**\n         * Is `true` after `writable.destroy()` has been called.\n         * @since v8.0.0\n         */\n        destroyed: boolean;\n        /**\n         * Is `true` after `\'close\'` has been emitted.\n         * @since v18.0.0\n         */\n        readonly closed: boolean;\n        /**\n         * Returns error if the stream has been destroyed with an error.\n         * @since v18.0.0\n         */\n        readonly errored: Error | null;\n        /**\n         * Is `true` if the stream\'s buffer has been full and stream will emit `\'drain\'`.\n         * @since v15.2.0, v14.17.0\n         */\n        readonly writableNeedDrain: boolean;\n        constructor(opts?: WritableOptions);\n        _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;\n        _writev?(\n            chunks: Array<{\n                chunk: any;\n                encoding: BufferEncoding;\n            }>,\n            callback: (error?: Error | null) => void,\n        ): void;\n        _construct?(callback: (error?: Error | null) => void): void;\n        _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n        _final(callback: (error?: Error | null) => void): void;\n        /**\n         * The `writable.write()` method writes some data to the stream, and calls the\n         * supplied `callback` once the data has been fully handled. If an error\n         * occurs, the `callback` will be called with the error as its\n         * first argument. The `callback` is called asynchronously and before `\'error\'` is\n         * emitted.\n         *\n         * The return value is `true` if the internal buffer is less than the`highWaterMark` configured when the stream was created after admitting `chunk`.\n         * If `false` is returned, further attempts to write data to the stream should\n         * stop until the `\'drain\'` event is emitted.\n         *\n         * While a stream is not draining, calls to `write()` will buffer `chunk`, and\n         * return false. Once all currently buffered chunks are drained (accepted for\n         * delivery by the operating system), the `\'drain\'` event will be emitted.\n         * Once `write()` returns false, do not write more chunks\n         * until the `\'drain\'` event is emitted. While calling `write()` on a stream that\n         * is not draining is allowed, Node.js will buffer all written chunks until\n         * maximum memory usage occurs, at which point it will abort unconditionally.\n         * Even before it aborts, high memory usage will cause poor garbage collector\n         * performance and high RSS (which is not typically released back to the system,\n         * even after the memory is no longer required). Since TCP sockets may never\n         * drain if the remote peer does not read the data, writing a socket that is\n         * not draining may lead to a remotely exploitable vulnerability.\n         *\n         * Writing data while the stream is not draining is particularly\n         * problematic for a `Transform`, because the `Transform` streams are paused\n         * by default until they are piped or a `\'data\'` or `\'readable\'` event handler\n         * is added.\n         *\n         * If the data to be written can be generated or fetched on demand, it is\n         * recommended to encapsulate the logic into a `Readable` and use {@link pipe}. However, if calling `write()` is preferred, it is\n         * possible to respect backpressure and avoid memory issues using the `\'drain\'` event:\n         *\n         * ```js\n         * function write(data, cb) {\n         *   if (!stream.write(data)) {\n         *     stream.once(\'drain\', cb);\n         *   } else {\n         *     process.nextTick(cb);\n         *   }\n         * }\n         *\n         * // Wait for cb to be called before doing any other write.\n         * write(\'hello\', () => {\n         *   console.log(\'Write completed, do more writes now.\');\n         * });\n         * ```\n         *\n         * A `Writable` stream in object mode will always ignore the `encoding` argument.\n         * @since v0.9.4\n         * @param chunk Optional data to write. For streams not operating in object mode, `chunk` must be a string, `Buffer` or `Uint8Array`. For object mode streams, `chunk` may be any\n         * JavaScript value other than `null`.\n         * @param [encoding=\'utf8\'] The encoding, if `chunk` is a string.\n         * @param callback Callback for when this chunk of data is flushed.\n         * @return `false` if the stream wishes for the calling code to wait for the `\'drain\'` event to be emitted before continuing to write additional data; otherwise `true`.\n         */\n        write(chunk: any, callback?: (error: Error | null | undefined) => void): boolean;\n        write(chunk: any, encoding: BufferEncoding, callback?: (error: Error | null | undefined) => void): boolean;\n        /**\n         * The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.\n         * @since v0.11.15\n         * @param encoding The new default encoding\n         */\n        setDefaultEncoding(encoding: BufferEncoding): this;\n        /**\n         * Calling the `writable.end()` method signals that no more data will be written\n         * to the `Writable`. The optional `chunk` and `encoding` arguments allow one\n         * final additional chunk of data to be written immediately before closing the\n         * stream.\n         *\n         * Calling the {@link write} method after calling {@link end} will raise an error.\n         *\n         * ```js\n         * // Write \'hello, \' and then end with \'world!\'.\n         * const fs = require(\'node:fs\');\n         * const file = fs.createWriteStream(\'example.txt\');\n         * file.write(\'hello, \');\n         * file.end(\'world!\');\n         * // Writing more now is not allowed!\n         * ```\n         * @since v0.9.4\n         * @param chunk Optional data to write. For streams not operating in object mode, `chunk` must be a string, `Buffer` or `Uint8Array`. For object mode streams, `chunk` may be any\n         * JavaScript value other than `null`.\n         * @param encoding The encoding if `chunk` is a string\n         * @param callback Callback for when the stream is finished.\n         */\n        end(cb?: () => void): this;\n        end(chunk: any, cb?: () => void): this;\n        end(chunk: any, encoding: BufferEncoding, cb?: () => void): this;\n        /**\n         * The `writable.cork()` method forces all written data to be buffered in memory.\n         * The buffered data will be flushed when either the {@link uncork} or {@link end} methods are called.\n         *\n         * The primary intent of `writable.cork()` is to accommodate a situation in which\n         * several small chunks are written to the stream in rapid succession. Instead of\n         * immediately forwarding them to the underlying destination, `writable.cork()`buffers all the chunks until `writable.uncork()` is called, which will pass them\n         * all to `writable._writev()`, if present. This prevents a head-of-line blocking\n         * situation where data is being buffered while waiting for the first small chunk\n         * to be processed. However, use of `writable.cork()` without implementing`writable._writev()` may have an adverse effect on throughput.\n         *\n         * See also: `writable.uncork()`, `writable._writev()`.\n         * @since v0.11.2\n         */\n        cork(): void;\n        /**\n         * The `writable.uncork()` method flushes all data buffered since {@link cork} was called.\n         *\n         * When using `writable.cork()` and `writable.uncork()` to manage the buffering\n         * of writes to a stream, defer calls to `writable.uncork()` using`process.nextTick()`. Doing so allows batching of all`writable.write()` calls that occur within a given Node.js event\n         * loop phase.\n         *\n         * ```js\n         * stream.cork();\n         * stream.write(\'some \');\n         * stream.write(\'data \');\n         * process.nextTick(() => stream.uncork());\n         * ```\n         *\n         * If the `writable.cork()` method is called multiple times on a stream, the\n         * same number of calls to `writable.uncork()` must be called to flush the buffered\n         * data.\n         *\n         * ```js\n         * stream.cork();\n         * stream.write(\'some \');\n         * stream.cork();\n         * stream.write(\'data \');\n         * process.nextTick(() => {\n         *   stream.uncork();\n         *   // The data will not be flushed until uncork() is called a second time.\n         *   stream.uncork();\n         * });\n         * ```\n         *\n         * See also: `writable.cork()`.\n         * @since v0.11.2\n         */\n        uncork(): void;\n        /**\n         * Destroy the stream. Optionally emit an `\'error\'` event, and emit a `\'close\'`event (unless `emitClose` is set to `false`). After this call, the writable\n         * stream has ended and subsequent calls to `write()` or `end()` will result in\n         * an `ERR_STREAM_DESTROYED` error.\n         * This is a destructive and immediate way to destroy a stream. Previous calls to`write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\n         * Use `end()` instead of destroy if data should flush before close, or wait for\n         * the `\'drain\'` event before destroying the stream.\n         *\n         * Once `destroy()` has been called any further calls will be a no-op and no\n         * further errors except from `_destroy()` may be emitted as `\'error\'`.\n         *\n         * Implementors should not override this method,\n         * but instead implement `writable._destroy()`.\n         * @since v8.0.0\n         * @param error Optional, an error to emit with `\'error\'` event.\n         */\n        destroy(error?: Error): this;\n        /**\n         * Event emitter\n         * The defined events on documents including:\n         * 1. close\n         * 2. drain\n         * 3. error\n         * 4. finish\n         * 5. pipe\n         * 6. unpipe\n         */\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "finish", listener: () => void): this;\n        addListener(event: "pipe", listener: (src: Readable) => void): this;\n        addListener(event: "unpipe", listener: (src: Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: "close"): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "finish"): boolean;\n        emit(event: "pipe", src: Readable): boolean;\n        emit(event: "unpipe", src: Readable): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: "close", listener: () => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "finish", listener: () => void): this;\n        on(event: "pipe", listener: (src: Readable) => void): this;\n        on(event: "unpipe", listener: (src: Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "finish", listener: () => void): this;\n        once(event: "pipe", listener: (src: Readable) => void): this;\n        once(event: "unpipe", listener: (src: Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "finish", listener: () => void): this;\n        prependListener(event: "pipe", listener: (src: Readable) => void): this;\n        prependListener(event: "unpipe", listener: (src: Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "finish", listener: () => void): this;\n        prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;\n        prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: "close", listener: () => void): this;\n        removeListener(event: "drain", listener: () => void): this;\n        removeListener(event: "error", listener: (err: Error) => void): this;\n        removeListener(event: "finish", listener: () => void): this;\n        removeListener(event: "pipe", listener: (src: Readable) => void): this;\n        removeListener(event: "unpipe", listener: (src: Readable) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    namespace internal {\n        class Stream extends internal {\n            constructor(opts?: ReadableOptions);\n        }\n        interface StreamOptions<T extends Stream> extends Abortable {\n            emitClose?: boolean | undefined;\n            highWaterMark?: number | undefined;\n            objectMode?: boolean | undefined;\n            construct?(this: T, callback: (error?: Error | null) => void): void;\n            destroy?(this: T, error: Error | null, callback: (error?: Error | null) => void): void;\n            autoDestroy?: boolean | undefined;\n        }\n        interface ReadableOptions extends StreamOptions<Readable> {\n            encoding?: BufferEncoding | undefined;\n            read?(this: Readable, size: number): void;\n        }\n        /**\n         * @since v0.9.4\n         */\n        class Readable extends ReadableBase {\n            /**\n             * A utility method for creating a `Readable` from a web `ReadableStream`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static fromWeb(\n                readableStream: streamWeb.ReadableStream,\n                options?: Pick<ReadableOptions, "encoding" | "highWaterMark" | "objectMode" | "signal">,\n            ): Readable;\n            /**\n             * A utility method for creating a web `ReadableStream` from a `Readable`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static toWeb(streamReadable: Readable): streamWeb.ReadableStream;\n        }\n        interface WritableOptions extends StreamOptions<Writable> {\n            decodeStrings?: boolean | undefined;\n            defaultEncoding?: BufferEncoding | undefined;\n            write?(\n                this: Writable,\n                chunk: any,\n                encoding: BufferEncoding,\n                callback: (error?: Error | null) => void,\n            ): void;\n            writev?(\n                this: Writable,\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n        }\n        /**\n         * @since v0.9.4\n         */\n        class Writable extends WritableBase {\n            /**\n             * A utility method for creating a `Writable` from a web `WritableStream`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static fromWeb(\n                writableStream: streamWeb.WritableStream,\n                options?: Pick<WritableOptions, "decodeStrings" | "highWaterMark" | "objectMode" | "signal">,\n            ): Writable;\n            /**\n             * A utility method for creating a web `WritableStream` from a `Writable`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static toWeb(streamWritable: Writable): streamWeb.WritableStream;\n        }\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean | undefined;\n            readableObjectMode?: boolean | undefined;\n            writableObjectMode?: boolean | undefined;\n            readableHighWaterMark?: number | undefined;\n            writableHighWaterMark?: number | undefined;\n            writableCorked?: number | undefined;\n            construct?(this: Duplex, callback: (error?: Error | null) => void): void;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;\n            writev?(\n                this: Duplex,\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error?: Error | null) => void): void;\n        }\n        /**\n         * Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n         *\n         * Examples of `Duplex` streams include:\n         *\n         * * `TCP sockets`\n         * * `zlib streams`\n         * * `crypto streams`\n         * @since v0.9.4\n         */\n        class Duplex extends ReadableBase implements WritableBase {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            readonly writableNeedDrain: boolean;\n            readonly closed: boolean;\n            readonly errored: Error | null;\n            /**\n             * If `false` then the stream will automatically end the writable side when the\n             * readable side ends. Set initially by the `allowHalfOpen` constructor option,\n             * which defaults to `true`.\n             *\n             * This can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `\'end\'` event is\n             * emitted.\n             * @since v0.9.4\n             */\n            allowHalfOpen: boolean;\n            constructor(opts?: DuplexOptions);\n            /**\n             * A utility method for creating duplex streams.\n             *\n             * - `Stream` converts writable stream into writable `Duplex` and readable stream\n             *   to `Duplex`.\n             * - `Blob` converts into readable `Duplex`.\n             * - `string` converts into readable `Duplex`.\n             * - `ArrayBuffer` converts into readable `Duplex`.\n             * - `AsyncIterable` converts into a readable `Duplex`. Cannot yield `null`.\n             * - `AsyncGeneratorFunction` converts into a readable/writable transform\n             *   `Duplex`. Must take a source `AsyncIterable` as first parameter. Cannot yield\n             *   `null`.\n             * - `AsyncFunction` converts into a writable `Duplex`. Must return\n             *   either `null` or `undefined`\n             * - `Object ({ writable, readable })` converts `readable` and\n             *   `writable` into `Stream` and then combines them into `Duplex` where the\n             *   `Duplex` will write to the `writable` and read from the `readable`.\n             * - `Promise` converts into readable `Duplex`. Value `null` is ignored.\n             *\n             * @since v16.8.0\n             */\n            static from(\n                src:\n                    | Stream\n                    | NodeBlob\n                    | ArrayBuffer\n                    | string\n                    | Iterable<any>\n                    | AsyncIterable<any>\n                    | AsyncGeneratorFunction\n                    | Promise<any>\n                    | Object,\n            ): Duplex;\n            _write(chunk: any, encoding: BufferEncoding, callback: (error?: Error | null) => void): void;\n            _writev?(\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, encoding?: BufferEncoding, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: BufferEncoding): this;\n            end(cb?: () => void): this;\n            end(chunk: any, cb?: () => void): this;\n            end(chunk: any, encoding?: BufferEncoding, cb?: () => void): this;\n            cork(): void;\n            uncork(): void;\n            /**\n             * A utility method for creating a web `ReadableStream` and `WritableStream` from a `Duplex`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static toWeb(streamDuplex: Duplex): {\n                readable: streamWeb.ReadableStream;\n                writable: streamWeb.WritableStream;\n            };\n            /**\n             * A utility method for creating a `Duplex` from a web `ReadableStream` and `WritableStream`.\n             * @since v17.0.0\n             * @experimental\n             */\n            static fromWeb(\n                duplexStream: {\n                    readable: streamWeb.ReadableStream;\n                    writable: streamWeb.WritableStream;\n                },\n                options?: Pick<\n                    DuplexOptions,\n                    "allowHalfOpen" | "decodeStrings" | "encoding" | "highWaterMark" | "objectMode" | "signal"\n                >,\n            ): Duplex;\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1.  close\n             * 2.  data\n             * 3.  drain\n             * 4.  end\n             * 5.  error\n             * 6.  finish\n             * 7.  pause\n             * 8.  pipe\n             * 9.  readable\n             * 10. resume\n             * 11. unpipe\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "data", listener: (chunk: any) => void): this;\n            addListener(event: "drain", listener: () => void): this;\n            addListener(event: "end", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "finish", listener: () => void): this;\n            addListener(event: "pause", listener: () => void): this;\n            addListener(event: "pipe", listener: (src: Readable) => void): this;\n            addListener(event: "readable", listener: () => void): this;\n            addListener(event: "resume", listener: () => void): this;\n            addListener(event: "unpipe", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            emit(event: "close"): boolean;\n            emit(event: "data", chunk: any): boolean;\n            emit(event: "drain"): boolean;\n            emit(event: "end"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "finish"): boolean;\n            emit(event: "pause"): boolean;\n            emit(event: "pipe", src: Readable): boolean;\n            emit(event: "readable"): boolean;\n            emit(event: "resume"): boolean;\n            emit(event: "unpipe", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n            on(event: "close", listener: () => void): this;\n            on(event: "data", listener: (chunk: any) => void): this;\n            on(event: "drain", listener: () => void): this;\n            on(event: "end", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "finish", listener: () => void): this;\n            on(event: "pause", listener: () => void): this;\n            on(event: "pipe", listener: (src: Readable) => void): this;\n            on(event: "readable", listener: () => void): this;\n            on(event: "resume", listener: () => void): this;\n            on(event: "unpipe", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n            once(event: "close", listener: () => void): this;\n            once(event: "data", listener: (chunk: any) => void): this;\n            once(event: "drain", listener: () => void): this;\n            once(event: "end", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "finish", listener: () => void): this;\n            once(event: "pause", listener: () => void): this;\n            once(event: "pipe", listener: (src: Readable) => void): this;\n            once(event: "readable", listener: () => void): this;\n            once(event: "resume", listener: () => void): this;\n            once(event: "unpipe", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "data", listener: (chunk: any) => void): this;\n            prependListener(event: "drain", listener: () => void): this;\n            prependListener(event: "end", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "finish", listener: () => void): this;\n            prependListener(event: "pause", listener: () => void): this;\n            prependListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependListener(event: "readable", listener: () => void): this;\n            prependListener(event: "resume", listener: () => void): this;\n            prependListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "data", listener: (chunk: any) => void): this;\n            prependOnceListener(event: "drain", listener: () => void): this;\n            prependOnceListener(event: "end", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "finish", listener: () => void): this;\n            prependOnceListener(event: "pause", listener: () => void): this;\n            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: "readable", listener: () => void): this;\n            prependOnceListener(event: "resume", listener: () => void): this;\n            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "data", listener: (chunk: any) => void): this;\n            removeListener(event: "drain", listener: () => void): this;\n            removeListener(event: "end", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "finish", listener: () => void): this;\n            removeListener(event: "pause", listener: () => void): this;\n            removeListener(event: "pipe", listener: (src: Readable) => void): this;\n            removeListener(event: "readable", listener: () => void): this;\n            removeListener(event: "resume", listener: () => void): this;\n            removeListener(event: "unpipe", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n        type TransformCallback = (error?: Error | null, data?: any) => void;\n        interface TransformOptions extends DuplexOptions {\n            construct?(this: Transform, callback: (error?: Error | null) => void): void;\n            read?(this: Transform, size: number): void;\n            write?(\n                this: Transform,\n                chunk: any,\n                encoding: BufferEncoding,\n                callback: (error?: Error | null) => void,\n            ): void;\n            writev?(\n                this: Transform,\n                chunks: Array<{\n                    chunk: any;\n                    encoding: BufferEncoding;\n                }>,\n                callback: (error?: Error | null) => void,\n            ): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error?: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n        /**\n         * Transform streams are `Duplex` streams where the output is in some way\n         * related to the input. Like all `Duplex` streams, `Transform` streams\n         * implement both the `Readable` and `Writable` interfaces.\n         *\n         * Examples of `Transform` streams include:\n         *\n         * * `zlib streams`\n         * * `crypto streams`\n         * @since v0.9.4\n         */\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: BufferEncoding, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n        /**\n         * The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\n         * primarily for examples and testing, but there are some use cases where`stream.PassThrough` is useful as a building block for novel sorts of streams.\n         */\n        class PassThrough extends Transform {}\n        /**\n         * A stream to attach a signal to.\n         *\n         * Attaches an AbortSignal to a readable or writeable stream. This lets code\n         * control stream destruction using an `AbortController`.\n         *\n         * Calling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream, and `controller.error(new\n         * AbortError())` for webstreams.\n         *\n         * ```js\n         * const fs = require(\'node:fs\');\n         *\n         * const controller = new AbortController();\n         * const read = addAbortSignal(\n         *   controller.signal,\n         *   fs.createReadStream((\'object.json\')),\n         * );\n         * // Later, abort the operation closing the stream\n         * controller.abort();\n         * ```\n         *\n         * Or using an `AbortSignal` with a readable stream as an async iterable:\n         *\n         * ```js\n         * const controller = new AbortController();\n         * setTimeout(() => controller.abort(), 10_000); // set a timeout\n         * const stream = addAbortSignal(\n         *   controller.signal,\n         *   fs.createReadStream((\'object.json\')),\n         * );\n         * (async () => {\n         *   try {\n         *     for await (const chunk of stream) {\n         *       await process(chunk);\n         *     }\n         *   } catch (e) {\n         *     if (e.name === \'AbortError\') {\n         *       // The operation was cancelled\n         *     } else {\n         *       throw e;\n         *     }\n         *   }\n         * })();\n         * ```\n         *\n         * Or using an `AbortSignal` with a ReadableStream:\n         *\n         * ```js\n         * const controller = new AbortController();\n         * const rs = new ReadableStream({\n         *   start(controller) {\n         *     controller.enqueue(\'hello\');\n         *     controller.enqueue(\'world\');\n         *     controller.close();\n         *   },\n         * });\n         *\n         * addAbortSignal(controller.signal, rs);\n         *\n         * finished(rs, (err) => {\n         *   if (err) {\n         *     if (err.name === \'AbortError\') {\n         *       // The operation was cancelled\n         *     }\n         *   }\n         * });\n         *\n         * const reader = rs.getReader();\n         *\n         * reader.read().then(({ value, done }) => {\n         *   console.log(value); // hello\n         *   console.log(done); // false\n         *   controller.abort();\n         * });\n         * ```\n         * @since v15.4.0\n         * @param signal A signal representing possible cancellation\n         * @param stream a stream to attach a signal to\n         */\n        function addAbortSignal<T extends Stream>(signal: AbortSignal, stream: T): T;\n        /**\n         * Returns the default highWaterMark used by streams.\n         * Defaults to `16384` (16 KiB), or `16` for `objectMode`.\n         * @since v19.9.0\n         * @param objectMode\n         */\n        function getDefaultHighWaterMark(objectMode: boolean): number;\n        /**\n         * Sets the default highWaterMark used by streams.\n         * @since v19.9.0\n         * @param objectMode\n         * @param value highWaterMark value\n         */\n        function setDefaultHighWaterMark(objectMode: boolean, value: number): void;\n        interface FinishedOptions extends Abortable {\n            error?: boolean | undefined;\n            readable?: boolean | undefined;\n            writable?: boolean | undefined;\n        }\n        /**\n         * A readable and/or writable stream/webstream.\n         *\n         * A function to get notified when a stream is no longer readable, writable\n         * or has experienced an error or a premature close event.\n         *\n         * ```js\n         * const { finished } = require(\'node:stream\');\n         * const fs = require(\'node:fs\');\n         *\n         * const rs = fs.createReadStream(\'archive.tar\');\n         *\n         * finished(rs, (err) => {\n         *   if (err) {\n         *     console.error(\'Stream failed.\', err);\n         *   } else {\n         *     console.log(\'Stream is done reading.\');\n         *   }\n         * });\n         *\n         * rs.resume(); // Drain the stream.\n         * ```\n         *\n         * Especially useful in error handling scenarios where a stream is destroyed\n         * prematurely (like an aborted HTTP request), and will not emit `\'end\'`or `\'finish\'`.\n         *\n         * The `finished` API provides `promise version`.\n         *\n         * `stream.finished()` leaves dangling event listeners (in particular`\'error\'`, `\'end\'`, `\'finish\'` and `\'close\'`) after `callback` has been\n         * invoked. The reason for this is so that unexpected `\'error\'` events (due to\n         * incorrect stream implementations) do not cause unexpected crashes.\n         * If this is unwanted behavior then the returned cleanup function needs to be\n         * invoked in the callback:\n         *\n         * ```js\n         * const cleanup = finished(rs, (err) => {\n         *   cleanup();\n         *   // ...\n         * });\n         * ```\n         * @since v10.0.0\n         * @param stream A readable and/or writable stream.\n         * @param callback A callback function that takes an optional error argument.\n         * @return A cleanup function which removes all registered listeners.\n         */\n        function finished(\n            stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,\n            options: FinishedOptions,\n            callback: (err?: NodeJS.ErrnoException | null) => void,\n        ): () => void;\n        function finished(\n            stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,\n            callback: (err?: NodeJS.ErrnoException | null) => void,\n        ): () => void;\n        namespace finished {\n            function __promisify__(\n                stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream,\n                options?: FinishedOptions,\n            ): Promise<void>;\n        }\n        type PipelineSourceFunction<T> = () => Iterable<T> | AsyncIterable<T>;\n        type PipelineSource<T> = Iterable<T> | AsyncIterable<T> | NodeJS.ReadableStream | PipelineSourceFunction<T>;\n        type PipelineTransform<S extends PipelineTransformSource<any>, U> =\n            | NodeJS.ReadWriteStream\n            | ((\n                source: S extends (...args: any[]) => Iterable<infer ST> | AsyncIterable<infer ST> ? AsyncIterable<ST>\n                    : S,\n            ) => AsyncIterable<U>);\n        type PipelineTransformSource<T> = PipelineSource<T> | PipelineTransform<any, T>;\n        type PipelineDestinationIterableFunction<T> = (source: AsyncIterable<T>) => AsyncIterable<any>;\n        type PipelineDestinationPromiseFunction<T, P> = (source: AsyncIterable<T>) => Promise<P>;\n        type PipelineDestination<S extends PipelineTransformSource<any>, P> = S extends\n            PipelineTransformSource<infer ST> ?\n                | NodeJS.WritableStream\n                | PipelineDestinationIterableFunction<ST>\n                | PipelineDestinationPromiseFunction<ST, P>\n            : never;\n        type PipelineCallback<S extends PipelineDestination<any, any>> = S extends\n            PipelineDestinationPromiseFunction<any, infer P> ? (err: NodeJS.ErrnoException | null, value: P) => void\n            : (err: NodeJS.ErrnoException | null) => void;\n        type PipelinePromise<S extends PipelineDestination<any, any>> = S extends\n            PipelineDestinationPromiseFunction<any, infer P> ? Promise<P> : Promise<void>;\n        interface PipelineOptions {\n            signal?: AbortSignal | undefined;\n            end?: boolean | undefined;\n        }\n        /**\n         * A module method to pipe between streams and generators forwarding errors and\n         * properly cleaning up and provide a callback when the pipeline is complete.\n         *\n         * ```js\n         * const { pipeline } = require(\'node:stream\');\n         * const fs = require(\'node:fs\');\n         * const zlib = require(\'node:zlib\');\n         *\n         * // Use the pipeline API to easily pipe a series of streams\n         * // together and get notified when the pipeline is fully done.\n         *\n         * // A pipeline to gzip a potentially huge tar file efficiently:\n         *\n         * pipeline(\n         *   fs.createReadStream(\'archive.tar\'),\n         *   zlib.createGzip(),\n         *   fs.createWriteStream(\'archive.tar.gz\'),\n         *   (err) => {\n         *     if (err) {\n         *       console.error(\'Pipeline failed.\', err);\n         *     } else {\n         *       console.log(\'Pipeline succeeded.\');\n         *     }\n         *   },\n         * );\n         * ```\n         *\n         * The `pipeline` API provides a `promise version`.\n         *\n         * `stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n         *\n         * * `Readable` streams which have emitted `\'end\'` or `\'close\'`.\n         * * `Writable` streams which have emitted `\'finish\'` or `\'close\'`.\n         *\n         * `stream.pipeline()` leaves dangling event listeners on the streams\n         * after the `callback` has been invoked. In the case of reuse of streams after\n         * failure, this can cause event listener leaks and swallowed errors. If the last\n         * stream is readable, dangling event listeners will be removed so that the last\n         * stream can be consumed later.\n         *\n         * `stream.pipeline()` closes all the streams when an error is raised.\n         * The `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\n         * once it would destroy the socket without sending the expected response.\n         * See the example below:\n         *\n         * ```js\n         * const fs = require(\'node:fs\');\n         * const http = require(\'node:http\');\n         * const { pipeline } = require(\'node:stream\');\n         *\n         * const server = http.createServer((req, res) => {\n         *   const fileStream = fs.createReadStream(\'./fileNotExist.txt\');\n         *   pipeline(fileStream, res, (err) => {\n         *     if (err) {\n         *       console.log(err); // No such file\n         *       // this message can\'t be sent once `pipeline` already destroyed the socket\n         *       return res.end(\'error!!!\');\n         *     }\n         *   });\n         * });\n         * ```\n         * @since v10.0.0\n         * @param callback Called when the pipeline is fully done.\n         */\n        function pipeline<A extends PipelineSource<any>, B extends PipelineDestination<A, any>>(\n            source: A,\n            destination: B,\n            callback?: PipelineCallback<B>,\n        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;\n        function pipeline<\n            A extends PipelineSource<any>,\n            T1 extends PipelineTransform<A, any>,\n            B extends PipelineDestination<T1, any>,\n        >(\n            source: A,\n            transform1: T1,\n            destination: B,\n            callback?: PipelineCallback<B>,\n        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;\n        function pipeline<\n            A extends PipelineSource<any>,\n            T1 extends PipelineTransform<A, any>,\n            T2 extends PipelineTransform<T1, any>,\n            B extends PipelineDestination<T2, any>,\n        >(\n            source: A,\n            transform1: T1,\n            transform2: T2,\n            destination: B,\n            callback?: PipelineCallback<B>,\n        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;\n        function pipeline<\n            A extends PipelineSource<any>,\n            T1 extends PipelineTransform<A, any>,\n            T2 extends PipelineTransform<T1, any>,\n            T3 extends PipelineTransform<T2, any>,\n            B extends PipelineDestination<T3, any>,\n        >(\n            source: A,\n            transform1: T1,\n            transform2: T2,\n            transform3: T3,\n            destination: B,\n            callback?: PipelineCallback<B>,\n        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;\n        function pipeline<\n            A extends PipelineSource<any>,\n            T1 extends PipelineTransform<A, any>,\n            T2 extends PipelineTransform<T1, any>,\n            T3 extends PipelineTransform<T2, any>,\n            T4 extends PipelineTransform<T3, any>,\n            B extends PipelineDestination<T4, any>,\n        >(\n            source: A,\n            transform1: T1,\n            transform2: T2,\n            transform3: T3,\n            transform4: T4,\n            destination: B,\n            callback?: PipelineCallback<B>,\n        ): B extends NodeJS.WritableStream ? B : NodeJS.WritableStream;\n        function pipeline(\n            streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<\n                NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException | null) => void)\n            >\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__<A extends PipelineSource<any>, B extends PipelineDestination<A, any>>(\n                source: A,\n                destination: B,\n                options?: PipelineOptions,\n            ): PipelinePromise<B>;\n            function __promisify__<\n                A extends PipelineSource<any>,\n                T1 extends PipelineTransform<A, any>,\n                B extends PipelineDestination<T1, any>,\n            >(\n                source: A,\n                transform1: T1,\n                destination: B,\n                options?: PipelineOptions,\n            ): PipelinePromise<B>;\n            function __promisify__<\n                A extends PipelineSource<any>,\n                T1 extends PipelineTransform<A, any>,\n                T2 extends PipelineTransform<T1, any>,\n                B extends PipelineDestination<T2, any>,\n            >(\n                source: A,\n                transform1: T1,\n                transform2: T2,\n                destination: B,\n                options?: PipelineOptions,\n            ): PipelinePromise<B>;\n            function __promisify__<\n                A extends PipelineSource<any>,\n                T1 extends PipelineTransform<A, any>,\n                T2 extends PipelineTransform<T1, any>,\n                T3 extends PipelineTransform<T2, any>,\n                B extends PipelineDestination<T3, any>,\n            >(\n                source: A,\n                transform1: T1,\n                transform2: T2,\n                transform3: T3,\n                destination: B,\n                options?: PipelineOptions,\n            ): PipelinePromise<B>;\n            function __promisify__<\n                A extends PipelineSource<any>,\n                T1 extends PipelineTransform<A, any>,\n                T2 extends PipelineTransform<T1, any>,\n                T3 extends PipelineTransform<T2, any>,\n                T4 extends PipelineTransform<T3, any>,\n                B extends PipelineDestination<T4, any>,\n            >(\n                source: A,\n                transform1: T1,\n                transform2: T2,\n                transform3: T3,\n                transform4: T4,\n                destination: B,\n                options?: PipelineOptions,\n            ): PipelinePromise<B>;\n            function __promisify__(\n                streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,\n                options?: PipelineOptions,\n            ): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | PipelineOptions>\n            ): Promise<void>;\n        }\n        interface Pipe {\n            close(): void;\n            hasRef(): boolean;\n            ref(): void;\n            unref(): void;\n        }\n        /**\n         * Returns whether the stream has encountered an error.\n         * @since v17.3.0, v16.14.0\n         * @experimental\n         */\n        function isErrored(stream: Readable | Writable | NodeJS.ReadableStream | NodeJS.WritableStream): boolean;\n        /**\n         * Returns whether the stream is readable.\n         * @since v17.4.0, v16.14.0\n         * @experimental\n         */\n        function isReadable(stream: Readable | NodeJS.ReadableStream): boolean;\n        const promises: typeof streamPromises;\n        const consumers: typeof streamConsumers;\n    }\n    export = internal;\n}\ndeclare module "node:stream" {\n    import stream = require("stream");\n    export = stream;\n}\n'},67914:e=>{e.exports="/**\n * The `node:string_decoder` module provides an API for decoding `Buffer` objects\n * into strings in a manner that preserves encoded multi-byte UTF-8 and UTF-16\n * characters. It can be accessed using:\n *\n * ```js\n * const { StringDecoder } = require('node:string_decoder');\n * ```\n *\n * The following example shows the basic use of the `StringDecoder` class.\n *\n * ```js\n * const { StringDecoder } = require('node:string_decoder');\n * const decoder = new StringDecoder('utf8');\n *\n * const cent = Buffer.from([0xC2, 0xA2]);\n * console.log(decoder.write(cent)); // Prints: ¢\n *\n * const euro = Buffer.from([0xE2, 0x82, 0xAC]);\n * console.log(decoder.write(euro)); // Prints: €\n * ```\n *\n * When a `Buffer` instance is written to the `StringDecoder` instance, an\n * internal buffer is used to ensure that the decoded string does not contain\n * any incomplete multibyte characters. These are held in the buffer until the\n * next call to `stringDecoder.write()` or until `stringDecoder.end()` is called.\n *\n * In the following example, the three UTF-8 encoded bytes of the European Euro\n * symbol (`€`) are written over three separate operations:\n *\n * ```js\n * const { StringDecoder } = require('node:string_decoder');\n * const decoder = new StringDecoder('utf8');\n *\n * decoder.write(Buffer.from([0xE2]));\n * decoder.write(Buffer.from([0x82]));\n * console.log(decoder.end(Buffer.from([0xAC]))); // Prints: €\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/string_decoder.js)\n */\ndeclare module \"string_decoder\" {\n    class StringDecoder {\n        constructor(encoding?: BufferEncoding);\n        /**\n         * Returns a decoded string, ensuring that any incomplete multibyte characters at\n         * the end of the `Buffer`, or `TypedArray`, or `DataView` are omitted from the\n         * returned string and stored in an internal buffer for the next call to`stringDecoder.write()` or `stringDecoder.end()`.\n         * @since v0.1.99\n         * @param buffer The bytes to decode.\n         */\n        write(buffer: Buffer): string;\n        /**\n         * Returns any remaining input stored in the internal buffer as a string. Bytes\n         * representing incomplete UTF-8 and UTF-16 characters will be replaced with\n         * substitution characters appropriate for the character encoding.\n         *\n         * If the `buffer` argument is provided, one final call to `stringDecoder.write()`is performed before returning the remaining input.\n         * After `end()` is called, the `stringDecoder` object can be reused for new input.\n         * @since v0.9.3\n         * @param buffer The bytes to decode.\n         */\n        end(buffer?: Buffer): string;\n    }\n}\ndeclare module \"node:string_decoder\" {\n    export * from \"string_decoder\";\n}\n"},80370:e=>{e.exports='/**\n * The `timer` module exposes a global API for scheduling functions to\n * be called at some future period of time. Because the timer functions are\n * globals, there is no need to call `require(\'node:timers\')` to use the API.\n *\n * The timer functions within Node.js implement a similar API as the timers API\n * provided by Web Browsers but use a different internal implementation that is\n * built around the Node.js [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout).\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/timers.js)\n */\ndeclare module "timers" {\n    import { Abortable } from "node:events";\n    import {\n        setImmediate as setImmediatePromise,\n        setInterval as setIntervalPromise,\n        setTimeout as setTimeoutPromise,\n    } from "node:timers/promises";\n    interface TimerOptions extends Abortable {\n        /**\n         * Set to `false` to indicate that the scheduled `Timeout`\n         * should not require the Node.js event loop to remain active.\n         * @default true\n         */\n        ref?: boolean | undefined;\n    }\n    let setTimeout: typeof global.setTimeout;\n    let clearTimeout: typeof global.clearTimeout;\n    let setInterval: typeof global.setInterval;\n    let clearInterval: typeof global.clearInterval;\n    let setImmediate: typeof global.setImmediate;\n    let clearImmediate: typeof global.clearImmediate;\n    global {\n        namespace NodeJS {\n            // compatibility with older typings\n            interface Timer extends RefCounted {\n                hasRef(): boolean;\n                refresh(): this;\n                [Symbol.toPrimitive](): number;\n            }\n            /**\n             * This object is created internally and is returned from `setImmediate()`. It\n             * can be passed to `clearImmediate()` in order to cancel the scheduled\n             * actions.\n             *\n             * By default, when an immediate is scheduled, the Node.js event loop will continue\n             * running as long as the immediate is active. The `Immediate` object returned by `setImmediate()` exports both `immediate.ref()` and `immediate.unref()`functions that can be used to\n             * control this default behavior.\n             */\n            class Immediate implements RefCounted {\n                /**\n                 * When called, requests that the Node.js event loop _not_ exit so long as the`Immediate` is active. Calling `immediate.ref()` multiple times will have no\n                 * effect.\n                 *\n                 * By default, all `Immediate` objects are "ref\'ed", making it normally unnecessary\n                 * to call `immediate.ref()` unless `immediate.unref()` had been called previously.\n                 * @since v9.7.0\n                 * @return a reference to `immediate`\n                 */\n                ref(): this;\n                /**\n                 * When called, the active `Immediate` object will not require the Node.js event\n                 * loop to remain active. If there is no other activity keeping the event loop\n                 * running, the process may exit before the `Immediate` object\'s callback is\n                 * invoked. Calling `immediate.unref()` multiple times will have no effect.\n                 * @since v9.7.0\n                 * @return a reference to `immediate`\n                 */\n                unref(): this;\n                /**\n                 * If true, the `Immediate` object will keep the Node.js event loop active.\n                 * @since v11.0.0\n                 */\n                hasRef(): boolean;\n                _onImmediate: Function; // to distinguish it from the Timeout class\n                /**\n                 * Cancels the immediate. This is similar to calling `clearImmediate()`.\n                 * @since v20.5.0\n                 */\n                [Symbol.dispose](): void;\n            }\n            /**\n             * This object is created internally and is returned from `setTimeout()` and `setInterval()`. It can be passed to either `clearTimeout()` or `clearInterval()` in order to cancel the\n             * scheduled actions.\n             *\n             * By default, when a timer is scheduled using either `setTimeout()` or `setInterval()`, the Node.js event loop will continue running as long as the\n             * timer is active. Each of the `Timeout` objects returned by these functions\n             * export both `timeout.ref()` and `timeout.unref()` functions that can be used to\n             * control this default behavior.\n             */\n            class Timeout implements Timer {\n                /**\n                 * When called, requests that the Node.js event loop _not_ exit so long as the`Timeout` is active. Calling `timeout.ref()` multiple times will have no effect.\n                 *\n                 * By default, all `Timeout` objects are "ref\'ed", making it normally unnecessary\n                 * to call `timeout.ref()` unless `timeout.unref()` had been called previously.\n                 * @since v0.9.1\n                 * @return a reference to `timeout`\n                 */\n                ref(): this;\n                /**\n                 * When called, the active `Timeout` object will not require the Node.js event loop\n                 * to remain active. If there is no other activity keeping the event loop running,\n                 * the process may exit before the `Timeout` object\'s callback is invoked. Calling`timeout.unref()` multiple times will have no effect.\n                 * @since v0.9.1\n                 * @return a reference to `timeout`\n                 */\n                unref(): this;\n                /**\n                 * If true, the `Timeout` object will keep the Node.js event loop active.\n                 * @since v11.0.0\n                 */\n                hasRef(): boolean;\n                /**\n                 * Sets the timer\'s start time to the current time, and reschedules the timer to\n                 * call its callback at the previously specified duration adjusted to the current\n                 * time. This is useful for refreshing a timer without allocating a new\n                 * JavaScript object.\n                 *\n                 * Using this on a timer that has already called its callback will reactivate the\n                 * timer.\n                 * @since v10.2.0\n                 * @return a reference to `timeout`\n                 */\n                refresh(): this;\n                [Symbol.toPrimitive](): number;\n                /**\n                 * Cancels the timeout.\n                 * @since v20.5.0\n                 */\n                [Symbol.dispose](): void;\n            }\n        }\n        /**\n         * Schedules execution of a one-time `callback` after `delay` milliseconds.\n         *\n         * The `callback` will likely not be invoked in precisely `delay` milliseconds.\n         * Node.js makes no guarantees about the exact timing of when callbacks will fire,\n         * nor of their ordering. The callback will be called as close as possible to the\n         * time specified.\n         *\n         * When `delay` is larger than `2147483647` or less than `1`, the `delay`will be set to `1`. Non-integer delays are truncated to an integer.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using `timersPromises.setTimeout()`.\n         * @since v0.0.1\n         * @param callback The function to call when the timer elapses.\n         * @param [delay=1] The number of milliseconds to wait before calling the `callback`.\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @return for use with {@link clearTimeout}\n         */\n        function setTimeout<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            ms?: number,\n            ...args: TArgs\n        ): NodeJS.Timeout;\n        // util.promisify no rest args compability\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setTimeout(callback: (args: void) => void, ms?: number): NodeJS.Timeout;\n        namespace setTimeout {\n            const __promisify__: typeof setTimeoutPromise;\n        }\n        /**\n         * Cancels a `Timeout` object created by `setTimeout()`.\n         * @since v0.0.1\n         * @param timeout A `Timeout` object as returned by {@link setTimeout} or the `primitive` of the `Timeout` object as a string or a number.\n         */\n        function clearTimeout(timeoutId: NodeJS.Timeout | string | number | undefined): void;\n        /**\n         * Schedules repeated execution of `callback` every `delay` milliseconds.\n         *\n         * When `delay` is larger than `2147483647` or less than `1`, the `delay` will be\n         * set to `1`. Non-integer delays are truncated to an integer.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using `timersPromises.setInterval()`.\n         * @since v0.0.1\n         * @param callback The function to call when the timer elapses.\n         * @param [delay=1] The number of milliseconds to wait before calling the `callback`.\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @return for use with {@link clearInterval}\n         */\n        function setInterval<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            ms?: number,\n            ...args: TArgs\n        ): NodeJS.Timeout;\n        // util.promisify no rest args compability\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setInterval(callback: (args: void) => void, ms?: number): NodeJS.Timeout;\n        namespace setInterval {\n            const __promisify__: typeof setIntervalPromise;\n        }\n        /**\n         * Cancels a `Timeout` object created by `setInterval()`.\n         * @since v0.0.1\n         * @param timeout A `Timeout` object as returned by {@link setInterval} or the `primitive` of the `Timeout` object as a string or a number.\n         */\n        function clearInterval(intervalId: NodeJS.Timeout | string | number | undefined): void;\n        /**\n         * Schedules the "immediate" execution of the `callback` after I/O events\'\n         * callbacks.\n         *\n         * When multiple calls to `setImmediate()` are made, the `callback` functions are\n         * queued for execution in the order in which they are created. The entire callback\n         * queue is processed every event loop iteration. If an immediate timer is queued\n         * from inside an executing callback, that timer will not be triggered until the\n         * next event loop iteration.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using `timersPromises.setImmediate()`.\n         * @since v0.9.1\n         * @param callback The function to call at the end of this turn of the Node.js `Event Loop`\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @return for use with {@link clearImmediate}\n         */\n        function setImmediate<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            ...args: TArgs\n        ): NodeJS.Immediate;\n        // util.promisify no rest args compability\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setImmediate(callback: (args: void) => void): NodeJS.Immediate;\n        namespace setImmediate {\n            const __promisify__: typeof setImmediatePromise;\n        }\n        /**\n         * Cancels an `Immediate` object created by `setImmediate()`.\n         * @since v0.9.1\n         * @param immediate An `Immediate` object as returned by {@link setImmediate}.\n         */\n        function clearImmediate(immediateId: NodeJS.Immediate | undefined): void;\n        function queueMicrotask(callback: () => void): void;\n    }\n}\ndeclare module "node:timers" {\n    export * from "timers";\n}\n'},10961:e=>{e.exports="/**\n * The `node:url` module provides utilities for URL resolution and parsing. It can\n * be accessed using:\n *\n * ```js\n * import url from 'node:url';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/url.js)\n */\ndeclare module \"url\" {\n    import { Blob as NodeBlob } from \"node:buffer\";\n    import { ClientRequestArgs } from \"node:http\";\n    import { ParsedUrlQuery, ParsedUrlQueryInput } from \"node:querystring\";\n    // Input to `url.format`\n    interface UrlObject {\n        auth?: string | null | undefined;\n        hash?: string | null | undefined;\n        host?: string | null | undefined;\n        hostname?: string | null | undefined;\n        href?: string | null | undefined;\n        pathname?: string | null | undefined;\n        protocol?: string | null | undefined;\n        search?: string | null | undefined;\n        slashes?: boolean | null | undefined;\n        port?: string | number | null | undefined;\n        query?: string | null | ParsedUrlQueryInput | undefined;\n    }\n    // Output of `url.parse`\n    interface Url {\n        auth: string | null;\n        hash: string | null;\n        host: string | null;\n        hostname: string | null;\n        href: string;\n        path: string | null;\n        pathname: string | null;\n        protocol: string | null;\n        search: string | null;\n        slashes: boolean | null;\n        port: string | null;\n        query: string | null | ParsedUrlQuery;\n    }\n    interface UrlWithParsedQuery extends Url {\n        query: ParsedUrlQuery;\n    }\n    interface UrlWithStringQuery extends Url {\n        query: string | null;\n    }\n    /**\n     * The `url.parse()` method takes a URL string, parses it, and returns a URL\n     * object.\n     *\n     * A `TypeError` is thrown if `urlString` is not a string.\n     *\n     * A `URIError` is thrown if the `auth` property is present but cannot be decoded.\n     *\n     * `url.parse()` uses a lenient, non-standard algorithm for parsing URL\n     * strings. It is prone to security issues such as [host name spoofing](https://hackerone.com/reports/678487) and incorrect handling of usernames and passwords. Do not use with untrusted\n     * input. CVEs are not issued for `url.parse()` vulnerabilities. Use the `WHATWG URL` API instead.\n     * @since v0.1.25\n     * @deprecated Use the WHATWG URL API instead.\n     * @param urlString The URL string to parse.\n     * @param [parseQueryString=false] If `true`, the `query` property will always be set to an object returned by the {@link querystring} module's `parse()` method. If `false`, the `query` property\n     * on the returned URL object will be an unparsed, undecoded string.\n     * @param [slashesDenoteHost=false] If `true`, the first token after the literal string `//` and preceding the next `/` will be interpreted as the `host`. For instance, given `//foo/bar`, the\n     * result would be `{host: 'foo', pathname: '/bar'}` rather than `{pathname: '//foo/bar'}`.\n     */\n    function parse(urlString: string): UrlWithStringQuery;\n    function parse(\n        urlString: string,\n        parseQueryString: false | undefined,\n        slashesDenoteHost?: boolean,\n    ): UrlWithStringQuery;\n    function parse(urlString: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;\n    function parse(urlString: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;\n    /**\n     * The `url.format()` method returns a formatted URL string derived from`urlObject`.\n     *\n     * ```js\n     * const url = require('node:url');\n     * url.format({\n     *   protocol: 'https',\n     *   hostname: 'example.com',\n     *   pathname: '/some/path',\n     *   query: {\n     *     page: 1,\n     *     format: 'json',\n     *   },\n     * });\n     *\n     * // => 'https://example.com/some/path?page=1&#x26;format=json'\n     * ```\n     *\n     * If `urlObject` is not an object or a string, `url.format()` will throw a `TypeError`.\n     *\n     * The formatting process operates as follows:\n     *\n     * * A new empty string `result` is created.\n     * * If `urlObject.protocol` is a string, it is appended as-is to `result`.\n     * * Otherwise, if `urlObject.protocol` is not `undefined` and is not a string, an `Error` is thrown.\n     * * For all string values of `urlObject.protocol` that _do not end_ with an ASCII\n     * colon (`:`) character, the literal string `:` will be appended to `result`.\n     * * If either of the following conditions is true, then the literal string `//`will be appended to `result`:\n     *    * `urlObject.slashes` property is true;\n     *    * `urlObject.protocol` begins with `http`, `https`, `ftp`, `gopher`, or`file`;\n     * * If the value of the `urlObject.auth` property is truthy, and either`urlObject.host` or `urlObject.hostname` are not `undefined`, the value of`urlObject.auth` will be coerced into a string\n     * and appended to `result`followed by the literal string `@`.\n     * * If the `urlObject.host` property is `undefined` then:\n     *    * If the `urlObject.hostname` is a string, it is appended to `result`.\n     *    * Otherwise, if `urlObject.hostname` is not `undefined` and is not a string,\n     *    an `Error` is thrown.\n     *    * If the `urlObject.port` property value is truthy, and `urlObject.hostname`is not `undefined`:\n     *          * The literal string `:` is appended to `result`, and\n     *          * The value of `urlObject.port` is coerced to a string and appended to`result`.\n     * * Otherwise, if the `urlObject.host` property value is truthy, the value of`urlObject.host` is coerced to a string and appended to `result`.\n     * * If the `urlObject.pathname` property is a string that is not an empty string:\n     *    * If the `urlObject.pathname`_does not start_ with an ASCII forward slash\n     *    (`/`), then the literal string `'/'` is appended to `result`.\n     *    * The value of `urlObject.pathname` is appended to `result`.\n     * * Otherwise, if `urlObject.pathname` is not `undefined` and is not a string, an `Error` is thrown.\n     * * If the `urlObject.search` property is `undefined` and if the `urlObject.query`property is an `Object`, the literal string `?` is appended to `result`followed by the output of calling the\n     * `querystring` module's `stringify()`method passing the value of `urlObject.query`.\n     * * Otherwise, if `urlObject.search` is a string:\n     *    * If the value of `urlObject.search`_does not start_ with the ASCII question\n     *    mark (`?`) character, the literal string `?` is appended to `result`.\n     *    * The value of `urlObject.search` is appended to `result`.\n     * * Otherwise, if `urlObject.search` is not `undefined` and is not a string, an `Error` is thrown.\n     * * If the `urlObject.hash` property is a string:\n     *    * If the value of `urlObject.hash`_does not start_ with the ASCII hash (`#`)\n     *    character, the literal string `#` is appended to `result`.\n     *    * The value of `urlObject.hash` is appended to `result`.\n     * * Otherwise, if the `urlObject.hash` property is not `undefined` and is not a\n     * string, an `Error` is thrown.\n     * * `result` is returned.\n     * @since v0.1.25\n     * @legacy Use the WHATWG URL API instead.\n     * @param urlObject A URL object (as returned by `url.parse()` or constructed otherwise). If a string, it is converted to an object by passing it to `url.parse()`.\n     */\n    function format(urlObject: URL, options?: URLFormatOptions): string;\n    /**\n     * The `url.format()` method returns a formatted URL string derived from`urlObject`.\n     *\n     * ```js\n     * const url = require('url');\n     * url.format({\n     *   protocol: 'https',\n     *   hostname: 'example.com',\n     *   pathname: '/some/path',\n     *   query: {\n     *     page: 1,\n     *     format: 'json'\n     *   }\n     * });\n     *\n     * // => 'https://example.com/some/path?page=1&#x26;format=json'\n     * ```\n     *\n     * If `urlObject` is not an object or a string, `url.format()` will throw a `TypeError`.\n     *\n     * The formatting process operates as follows:\n     *\n     * * A new empty string `result` is created.\n     * * If `urlObject.protocol` is a string, it is appended as-is to `result`.\n     * * Otherwise, if `urlObject.protocol` is not `undefined` and is not a string, an `Error` is thrown.\n     * * For all string values of `urlObject.protocol` that _do not end_ with an ASCII\n     * colon (`:`) character, the literal string `:` will be appended to `result`.\n     * * If either of the following conditions is true, then the literal string `//`will be appended to `result`:\n     *    * `urlObject.slashes` property is true;\n     *    * `urlObject.protocol` begins with `http`, `https`, `ftp`, `gopher`, or`file`;\n     * * If the value of the `urlObject.auth` property is truthy, and either`urlObject.host` or `urlObject.hostname` are not `undefined`, the value of`urlObject.auth` will be coerced into a string\n     * and appended to `result`followed by the literal string `@`.\n     * * If the `urlObject.host` property is `undefined` then:\n     *    * If the `urlObject.hostname` is a string, it is appended to `result`.\n     *    * Otherwise, if `urlObject.hostname` is not `undefined` and is not a string,\n     *    an `Error` is thrown.\n     *    * If the `urlObject.port` property value is truthy, and `urlObject.hostname`is not `undefined`:\n     *          * The literal string `:` is appended to `result`, and\n     *          * The value of `urlObject.port` is coerced to a string and appended to`result`.\n     * * Otherwise, if the `urlObject.host` property value is truthy, the value of`urlObject.host` is coerced to a string and appended to `result`.\n     * * If the `urlObject.pathname` property is a string that is not an empty string:\n     *    * If the `urlObject.pathname`_does not start_ with an ASCII forward slash\n     *    (`/`), then the literal string `'/'` is appended to `result`.\n     *    * The value of `urlObject.pathname` is appended to `result`.\n     * * Otherwise, if `urlObject.pathname` is not `undefined` and is not a string, an `Error` is thrown.\n     * * If the `urlObject.search` property is `undefined` and if the `urlObject.query`property is an `Object`, the literal string `?` is appended to `result`followed by the output of calling the\n     * `querystring` module's `stringify()`method passing the value of `urlObject.query`.\n     * * Otherwise, if `urlObject.search` is a string:\n     *    * If the value of `urlObject.search`_does not start_ with the ASCII question\n     *    mark (`?`) character, the literal string `?` is appended to `result`.\n     *    * The value of `urlObject.search` is appended to `result`.\n     * * Otherwise, if `urlObject.search` is not `undefined` and is not a string, an `Error` is thrown.\n     * * If the `urlObject.hash` property is a string:\n     *    * If the value of `urlObject.hash`_does not start_ with the ASCII hash (`#`)\n     *    character, the literal string `#` is appended to `result`.\n     *    * The value of `urlObject.hash` is appended to `result`.\n     * * Otherwise, if the `urlObject.hash` property is not `undefined` and is not a\n     * string, an `Error` is thrown.\n     * * `result` is returned.\n     * @since v0.1.25\n     * @legacy Use the WHATWG URL API instead.\n     * @param urlObject A URL object (as returned by `url.parse()` or constructed otherwise). If a string, it is converted to an object by passing it to `url.parse()`.\n     */\n    function format(urlObject: UrlObject | string): string;\n    /**\n     * The `url.resolve()` method resolves a target URL relative to a base URL in a\n     * manner similar to that of a web browser resolving an anchor tag.\n     *\n     * ```js\n     * const url = require('node:url');\n     * url.resolve('/one/two/three', 'four');         // '/one/two/four'\n     * url.resolve('http://example.com/', '/one');    // 'http://example.com/one'\n     * url.resolve('http://example.com/one', '/two'); // 'http://example.com/two'\n     * ```\n     *\n     * To achieve the same result using the WHATWG URL API:\n     *\n     * ```js\n     * function resolve(from, to) {\n     *   const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n     *   if (resolvedUrl.protocol === 'resolve:') {\n     *     // `from` is a relative URL.\n     *     const { pathname, search, hash } = resolvedUrl;\n     *     return pathname + search + hash;\n     *   }\n     *   return resolvedUrl.toString();\n     * }\n     *\n     * resolve('/one/two/three', 'four');         // '/one/two/four'\n     * resolve('http://example.com/', '/one');    // 'http://example.com/one'\n     * resolve('http://example.com/one', '/two'); // 'http://example.com/two'\n     * ```\n     * @since v0.1.25\n     * @legacy Use the WHATWG URL API instead.\n     * @param from The base URL to use if `to` is a relative URL.\n     * @param to The target URL to resolve.\n     */\n    function resolve(from: string, to: string): string;\n    /**\n     * Returns the [Punycode](https://tools.ietf.org/html/rfc5891#section-4.4) ASCII serialization of the `domain`. If `domain` is an\n     * invalid domain, the empty string is returned.\n     *\n     * It performs the inverse operation to {@link domainToUnicode}.\n     *\n     * ```js\n     * import url from 'node:url';\n     *\n     * console.log(url.domainToASCII('español.com'));\n     * // Prints xn--espaol-zwa.com\n     * console.log(url.domainToASCII('中文.com'));\n     * // Prints xn--fiq228c.com\n     * console.log(url.domainToASCII('xn--iñvalid.com'));\n     * // Prints an empty string\n     * ```\n     * @since v7.4.0, v6.13.0\n     */\n    function domainToASCII(domain: string): string;\n    /**\n     * Returns the Unicode serialization of the `domain`. If `domain` is an invalid\n     * domain, the empty string is returned.\n     *\n     * It performs the inverse operation to {@link domainToASCII}.\n     *\n     * ```js\n     * import url from 'node:url';\n     *\n     * console.log(url.domainToUnicode('xn--espaol-zwa.com'));\n     * // Prints español.com\n     * console.log(url.domainToUnicode('xn--fiq228c.com'));\n     * // Prints 中文.com\n     * console.log(url.domainToUnicode('xn--iñvalid.com'));\n     * // Prints an empty string\n     * ```\n     * @since v7.4.0, v6.13.0\n     */\n    function domainToUnicode(domain: string): string;\n    /**\n     * This function ensures the correct decodings of percent-encoded characters as\n     * well as ensuring a cross-platform valid absolute path string.\n     *\n     * ```js\n     * import { fileURLToPath } from 'node:url';\n     *\n     * const __filename = fileURLToPath(import.meta.url);\n     *\n     * new URL('file:///C:/path/').pathname;      // Incorrect: /C:/path/\n     * fileURLToPath('file:///C:/path/');         // Correct:   C:\\path\\ (Windows)\n     *\n     * new URL('file://nas/foo.txt').pathname;    // Incorrect: /foo.txt\n     * fileURLToPath('file://nas/foo.txt');       // Correct:   \\\\nas\\foo.txt (Windows)\n     *\n     * new URL('file:///你好.txt').pathname;      // Incorrect: /%E4%BD%A0%E5%A5%BD.txt\n     * fileURLToPath('file:///你好.txt');         // Correct:   /你好.txt (POSIX)\n     *\n     * new URL('file:///hello world').pathname;   // Incorrect: /hello%20world\n     * fileURLToPath('file:///hello world');      // Correct:   /hello world (POSIX)\n     * ```\n     * @since v10.12.0\n     * @param url The file URL string or URL object to convert to a path.\n     * @return The fully-resolved platform-specific Node.js file path.\n     */\n    function fileURLToPath(url: string | URL): string;\n    /**\n     * This function ensures that `path` is resolved absolutely, and that the URL\n     * control characters are correctly encoded when converting into a File URL.\n     *\n     * ```js\n     * import { pathToFileURL } from 'node:url';\n     *\n     * new URL('/foo#1', 'file:');           // Incorrect: file:///foo#1\n     * pathToFileURL('/foo#1');              // Correct:   file:///foo%231 (POSIX)\n     *\n     * new URL('/some/path%.c', 'file:');    // Incorrect: file:///some/path%.c\n     * pathToFileURL('/some/path%.c');       // Correct:   file:///some/path%25.c (POSIX)\n     * ```\n     * @since v10.12.0\n     * @param path The path to convert to a File URL.\n     * @return The file URL object.\n     */\n    function pathToFileURL(path: string): URL;\n    /**\n     * This utility function converts a URL object into an ordinary options object as\n     * expected by the `http.request()` and `https.request()` APIs.\n     *\n     * ```js\n     * import { urlToHttpOptions } from 'node:url';\n     * const myURL = new URL('https://a:b@測試?abc#foo');\n     *\n     * console.log(urlToHttpOptions(myURL));\n     * /*\n     * {\n     *   protocol: 'https:',\n     *   hostname: 'xn--g6w251d',\n     *   hash: '#foo',\n     *   search: '?abc',\n     *   pathname: '/',\n     *   path: '/?abc',\n     *   href: 'https://a:b@xn--g6w251d/?abc#foo',\n     *   auth: 'a:b'\n     * }\n     *\n     * ```\n     * @since v15.7.0, v14.18.0\n     * @param url The `WHATWG URL` object to convert to an options object.\n     * @return Options object\n     */\n    function urlToHttpOptions(url: URL): ClientRequestArgs;\n    interface URLFormatOptions {\n        auth?: boolean | undefined;\n        fragment?: boolean | undefined;\n        search?: boolean | undefined;\n        unicode?: boolean | undefined;\n    }\n    /**\n     * Browser-compatible `URL` class, implemented by following the WHATWG URL\n     * Standard. [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself.\n     * The `URL` class is also available on the global object.\n     *\n     * In accordance with browser conventions, all properties of `URL` objects\n     * are implemented as getters and setters on the class prototype, rather than as\n     * data properties on the object itself. Thus, unlike `legacy urlObject` s,\n     * using the `delete` keyword on any properties of `URL` objects (e.g. `delete myURL.protocol`, `delete myURL.pathname`, etc) has no effect but will still\n     * return `true`.\n     * @since v7.0.0, v6.13.0\n     */\n    class URL {\n        /**\n         * Creates a `'blob:nodedata:...'` URL string that represents the given `Blob` object and can be used to retrieve the `Blob` later.\n         *\n         * ```js\n         * const {\n         *   Blob,\n         *   resolveObjectURL,\n         * } = require('node:buffer');\n         *\n         * const blob = new Blob(['hello']);\n         * const id = URL.createObjectURL(blob);\n         *\n         * // later...\n         *\n         * const otherBlob = resolveObjectURL(id);\n         * console.log(otherBlob.size);\n         * ```\n         *\n         * The data stored by the registered `Blob` will be retained in memory until`URL.revokeObjectURL()` is called to remove it.\n         *\n         * `Blob` objects are registered within the current thread. If using Worker\n         * Threads, `Blob` objects registered within one Worker will not be available\n         * to other workers or the main thread.\n         * @since v16.7.0\n         * @experimental\n         */\n        static createObjectURL(blob: NodeBlob): string;\n        /**\n         * Removes the stored `Blob` identified by the given ID. Attempting to revoke a\n         * ID that isn't registered will silently fail.\n         * @since v16.7.0\n         * @experimental\n         * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.\n         */\n        static revokeObjectURL(objectUrl: string): void;\n        /**\n         * Checks if an `input` relative to the `base` can be parsed to a `URL`.\n         *\n         * ```js\n         * const isValid = URL.canParse('/foo', 'https://example.org/'); // true\n         *\n         * const isNotValid = URL.canParse('/foo'); // false\n         * ```\n         * @since v19.9.0\n         * @param input The absolute or relative input URL to parse. If `input` is relative, then `base` is required. If `input` is absolute, the `base` is ignored. If `input` is not a string, it is\n         * `converted to a string` first.\n         * @param base The base URL to resolve against if the `input` is not absolute. If `base` is not a string, it is `converted to a string` first.\n         */\n        static canParse(input: string, base?: string): boolean;\n        constructor(input: string, base?: string | URL);\n        /**\n         * Gets and sets the fragment portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/foo#bar');\n         * console.log(myURL.hash);\n         * // Prints #bar\n         *\n         * myURL.hash = 'baz';\n         * console.log(myURL.href);\n         * // Prints https://example.org/foo#baz\n         * ```\n         *\n         * Invalid URL characters included in the value assigned to the `hash` property\n         * are `percent-encoded`. The selection of which characters to\n         * percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.\n         */\n        hash: string;\n        /**\n         * Gets and sets the host portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org:81/foo');\n         * console.log(myURL.host);\n         * // Prints example.org:81\n         *\n         * myURL.host = 'example.com:82';\n         * console.log(myURL.href);\n         * // Prints https://example.com:82/foo\n         * ```\n         *\n         * Invalid host values assigned to the `host` property are ignored.\n         */\n        host: string;\n        /**\n         * Gets and sets the host name portion of the URL. The key difference between`url.host` and `url.hostname` is that `url.hostname` does _not_ include the\n         * port.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org:81/foo');\n         * console.log(myURL.hostname);\n         * // Prints example.org\n         *\n         * // Setting the hostname does not change the port\n         * myURL.hostname = 'example.com';\n         * console.log(myURL.href);\n         * // Prints https://example.com:81/foo\n         *\n         * // Use myURL.host to change the hostname and port\n         * myURL.host = 'example.org:82';\n         * console.log(myURL.href);\n         * // Prints https://example.org:82/foo\n         * ```\n         *\n         * Invalid host name values assigned to the `hostname` property are ignored.\n         */\n        hostname: string;\n        /**\n         * Gets and sets the serialized URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/foo');\n         * console.log(myURL.href);\n         * // Prints https://example.org/foo\n         *\n         * myURL.href = 'https://example.com/bar';\n         * console.log(myURL.href);\n         * // Prints https://example.com/bar\n         * ```\n         *\n         * Getting the value of the `href` property is equivalent to calling {@link toString}.\n         *\n         * Setting the value of this property to a new value is equivalent to creating a\n         * new `URL` object using `new URL(value)`. Each of the `URL`object's properties will be modified.\n         *\n         * If the value assigned to the `href` property is not a valid URL, a `TypeError`will be thrown.\n         */\n        href: string;\n        /**\n         * Gets the read-only serialization of the URL's origin.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/foo/bar?baz');\n         * console.log(myURL.origin);\n         * // Prints https://example.org\n         * ```\n         *\n         * ```js\n         * const idnURL = new URL('https://測試');\n         * console.log(idnURL.origin);\n         * // Prints https://xn--g6w251d\n         *\n         * console.log(idnURL.hostname);\n         * // Prints xn--g6w251d\n         * ```\n         */\n        readonly origin: string;\n        /**\n         * Gets and sets the password portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://abc:xyz@example.com');\n         * console.log(myURL.password);\n         * // Prints xyz\n         *\n         * myURL.password = '123';\n         * console.log(myURL.href);\n         * // Prints https://abc:123@example.com/\n         * ```\n         *\n         * Invalid URL characters included in the value assigned to the `password` property\n         * are `percent-encoded`. The selection of which characters to\n         * percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.\n         */\n        password: string;\n        /**\n         * Gets and sets the path portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/abc/xyz?123');\n         * console.log(myURL.pathname);\n         * // Prints /abc/xyz\n         *\n         * myURL.pathname = '/abcdef';\n         * console.log(myURL.href);\n         * // Prints https://example.org/abcdef?123\n         * ```\n         *\n         * Invalid URL characters included in the value assigned to the `pathname`property are `percent-encoded`. The selection of which characters\n         * to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.\n         */\n        pathname: string;\n        /**\n         * Gets and sets the port portion of the URL.\n         *\n         * The port value may be a number or a string containing a number in the range`0` to `65535` (inclusive). Setting the value to the default port of the`URL` objects given `protocol` will\n         * result in the `port` value becoming\n         * the empty string (`''`).\n         *\n         * The port value can be an empty string in which case the port depends on\n         * the protocol/scheme:\n         *\n         * <omitted>\n         *\n         * Upon assigning a value to the port, the value will first be converted to a\n         * string using `.toString()`.\n         *\n         * If that string is invalid but it begins with a number, the leading number is\n         * assigned to `port`.\n         * If the number lies outside the range denoted above, it is ignored.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org:8888');\n         * console.log(myURL.port);\n         * // Prints 8888\n         *\n         * // Default ports are automatically transformed to the empty string\n         * // (HTTPS protocol's default port is 443)\n         * myURL.port = '443';\n         * console.log(myURL.port);\n         * // Prints the empty string\n         * console.log(myURL.href);\n         * // Prints https://example.org/\n         *\n         * myURL.port = 1234;\n         * console.log(myURL.port);\n         * // Prints 1234\n         * console.log(myURL.href);\n         * // Prints https://example.org:1234/\n         *\n         * // Completely invalid port strings are ignored\n         * myURL.port = 'abcd';\n         * console.log(myURL.port);\n         * // Prints 1234\n         *\n         * // Leading numbers are treated as a port number\n         * myURL.port = '5678abcd';\n         * console.log(myURL.port);\n         * // Prints 5678\n         *\n         * // Non-integers are truncated\n         * myURL.port = 1234.5678;\n         * console.log(myURL.port);\n         * // Prints 1234\n         *\n         * // Out-of-range numbers which are not represented in scientific notation\n         * // will be ignored.\n         * myURL.port = 1e10; // 10000000000, will be range-checked as described below\n         * console.log(myURL.port);\n         * // Prints 1234\n         * ```\n         *\n         * Numbers which contain a decimal point,\n         * such as floating-point numbers or numbers in scientific notation,\n         * are not an exception to this rule.\n         * Leading numbers up to the decimal point will be set as the URL's port,\n         * assuming they are valid:\n         *\n         * ```js\n         * myURL.port = 4.567e21;\n         * console.log(myURL.port);\n         * // Prints 4 (because it is the leading number in the string '4.567e21')\n         * ```\n         */\n        port: string;\n        /**\n         * Gets and sets the protocol portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org');\n         * console.log(myURL.protocol);\n         * // Prints https:\n         *\n         * myURL.protocol = 'ftp';\n         * console.log(myURL.href);\n         * // Prints ftp://example.org/\n         * ```\n         *\n         * Invalid URL protocol values assigned to the `protocol` property are ignored.\n         */\n        protocol: string;\n        /**\n         * Gets and sets the serialized query portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/abc?123');\n         * console.log(myURL.search);\n         * // Prints ?123\n         *\n         * myURL.search = 'abc=xyz';\n         * console.log(myURL.href);\n         * // Prints https://example.org/abc?abc=xyz\n         * ```\n         *\n         * Any invalid URL characters appearing in the value assigned the `search`property will be `percent-encoded`. The selection of which\n         * characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.\n         */\n        search: string;\n        /**\n         * Gets the `URLSearchParams` object representing the query parameters of the\n         * URL. This property is read-only but the `URLSearchParams` object it provides\n         * can be used to mutate the URL instance; to replace the entirety of query\n         * parameters of the URL, use the {@link search} setter. See `URLSearchParams` documentation for details.\n         *\n         * Use care when using `.searchParams` to modify the `URL` because,\n         * per the WHATWG specification, the `URLSearchParams` object uses\n         * different rules to determine which characters to percent-encode. For\n         * instance, the `URL` object will not percent encode the ASCII tilde (`~`)\n         * character, while `URLSearchParams` will always encode it:\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/abc?foo=~bar');\n         *\n         * console.log(myURL.search);  // prints ?foo=~bar\n         *\n         * // Modify the URL via searchParams...\n         * myURL.searchParams.sort();\n         *\n         * console.log(myURL.search);  // prints ?foo=%7Ebar\n         * ```\n         */\n        readonly searchParams: URLSearchParams;\n        /**\n         * Gets and sets the username portion of the URL.\n         *\n         * ```js\n         * const myURL = new URL('https://abc:xyz@example.com');\n         * console.log(myURL.username);\n         * // Prints abc\n         *\n         * myURL.username = '123';\n         * console.log(myURL.href);\n         * // Prints https://123:xyz@example.com/\n         * ```\n         *\n         * Any invalid URL characters appearing in the value assigned the `username`property will be `percent-encoded`. The selection of which\n         * characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.\n         */\n        username: string;\n        /**\n         * The `toString()` method on the `URL` object returns the serialized URL. The\n         * value returned is equivalent to that of {@link href} and {@link toJSON}.\n         */\n        toString(): string;\n        /**\n         * The `toJSON()` method on the `URL` object returns the serialized URL. The\n         * value returned is equivalent to that of {@link href} and {@link toString}.\n         *\n         * This method is automatically called when an `URL` object is serialized\n         * with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).\n         *\n         * ```js\n         * const myURLs = [\n         *   new URL('https://www.example.com'),\n         *   new URL('https://test.example.org'),\n         * ];\n         * console.log(JSON.stringify(myURLs));\n         * // Prints [\"https://www.example.com/\",\"https://test.example.org/\"]\n         * ```\n         */\n        toJSON(): string;\n    }\n    /**\n     * The `URLSearchParams` API provides read and write access to the query of a`URL`. The `URLSearchParams` class can also be used standalone with one of the\n     * four following constructors.\n     * The `URLSearchParams` class is also available on the global object.\n     *\n     * The WHATWG `URLSearchParams` interface and the `querystring` module have\n     * similar purpose, but the purpose of the `querystring` module is more\n     * general, as it allows the customization of delimiter characters (`&#x26;` and `=`).\n     * On the other hand, this API is designed purely for URL query strings.\n     *\n     * ```js\n     * const myURL = new URL('https://example.org/?abc=123');\n     * console.log(myURL.searchParams.get('abc'));\n     * // Prints 123\n     *\n     * myURL.searchParams.append('abc', 'xyz');\n     * console.log(myURL.href);\n     * // Prints https://example.org/?abc=123&#x26;abc=xyz\n     *\n     * myURL.searchParams.delete('abc');\n     * myURL.searchParams.set('a', 'b');\n     * console.log(myURL.href);\n     * // Prints https://example.org/?a=b\n     *\n     * const newSearchParams = new URLSearchParams(myURL.searchParams);\n     * // The above is equivalent to\n     * // const newSearchParams = new URLSearchParams(myURL.search);\n     *\n     * newSearchParams.append('a', 'c');\n     * console.log(myURL.href);\n     * // Prints https://example.org/?a=b\n     * console.log(newSearchParams.toString());\n     * // Prints a=b&#x26;a=c\n     *\n     * // newSearchParams.toString() is implicitly called\n     * myURL.search = newSearchParams;\n     * console.log(myURL.href);\n     * // Prints https://example.org/?a=b&#x26;a=c\n     * newSearchParams.delete('a');\n     * console.log(myURL.href);\n     * // Prints https://example.org/?a=b&#x26;a=c\n     * ```\n     * @since v7.5.0, v6.13.0\n     */\n    class URLSearchParams implements Iterable<[string, string]> {\n        constructor(\n            init?:\n                | URLSearchParams\n                | string\n                | Record<string, string | readonly string[]>\n                | Iterable<[string, string]>\n                | ReadonlyArray<[string, string]>,\n        );\n        /**\n         * Append a new name-value pair to the query string.\n         */\n        append(name: string, value: string): void;\n        /**\n         * If `value` is provided, removes all name-value pairs\n         * where name is `name` and value is `value`..\n         *\n         * If `value` is not provided, removes all name-value pairs whose name is `name`.\n         */\n        delete(name: string, value?: string): void;\n        /**\n         * Returns an ES6 `Iterator` over each of the name-value pairs in the query.\n         * Each item of the iterator is a JavaScript `Array`. The first item of the `Array`is the `name`, the second item of the `Array` is the `value`.\n         *\n         * Alias for `urlSearchParams[@@iterator]()`.\n         */\n        entries(): IterableIterator<[string, string]>;\n        /**\n         * Iterates over each name-value pair in the query and invokes the given function.\n         *\n         * ```js\n         * const myURL = new URL('https://example.org/?a=b&#x26;c=d');\n         * myURL.searchParams.forEach((value, name, searchParams) => {\n         *   console.log(name, value, myURL.searchParams === searchParams);\n         * });\n         * // Prints:\n         * //   a b true\n         * //   c d true\n         * ```\n         * @param fn Invoked for each name-value pair in the query\n         * @param thisArg To be used as `this` value for when `fn` is called\n         */\n        forEach<TThis = this>(\n            callback: (this: TThis, value: string, name: string, searchParams: URLSearchParams) => void,\n            thisArg?: TThis,\n        ): void;\n        /**\n         * Returns the value of the first name-value pair whose name is `name`. If there\n         * are no such pairs, `null` is returned.\n         * @return or `null` if there is no name-value pair with the given `name`.\n         */\n        get(name: string): string | null;\n        /**\n         * Returns the values of all name-value pairs whose name is `name`. If there are\n         * no such pairs, an empty array is returned.\n         */\n        getAll(name: string): string[];\n        /**\n         * Checks if the `URLSearchParams` object contains key-value pair(s) based on`name` and an optional `value` argument.\n         *\n         * If `value` is provided, returns `true` when name-value pair with\n         * same `name` and `value` exists.\n         *\n         * If `value` is not provided, returns `true` if there is at least one name-value\n         * pair whose name is `name`.\n         */\n        has(name: string, value?: string): boolean;\n        /**\n         * Returns an ES6 `Iterator` over the names of each name-value pair.\n         *\n         * ```js\n         * const params = new URLSearchParams('foo=bar&#x26;foo=baz');\n         * for (const name of params.keys()) {\n         *   console.log(name);\n         * }\n         * // Prints:\n         * //   foo\n         * //   foo\n         * ```\n         */\n        keys(): IterableIterator<string>;\n        /**\n         * Sets the value in the `URLSearchParams` object associated with `name` to`value`. If there are any pre-existing name-value pairs whose names are `name`,\n         * set the first such pair's value to `value` and remove all others. If not,\n         * append the name-value pair to the query string.\n         *\n         * ```js\n         * const params = new URLSearchParams();\n         * params.append('foo', 'bar');\n         * params.append('foo', 'baz');\n         * params.append('abc', 'def');\n         * console.log(params.toString());\n         * // Prints foo=bar&#x26;foo=baz&#x26;abc=def\n         *\n         * params.set('foo', 'def');\n         * params.set('xyz', 'opq');\n         * console.log(params.toString());\n         * // Prints foo=def&#x26;abc=def&#x26;xyz=opq\n         * ```\n         */\n        set(name: string, value: string): void;\n        /**\n         * The total number of parameter entries.\n         * @since v19.8.0\n         */\n        readonly size: number;\n        /**\n         * Sort all existing name-value pairs in-place by their names. Sorting is done\n         * with a [stable sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability), so relative order between name-value pairs\n         * with the same name is preserved.\n         *\n         * This method can be used, in particular, to increase cache hits.\n         *\n         * ```js\n         * const params = new URLSearchParams('query[]=abc&#x26;type=search&#x26;query[]=123');\n         * params.sort();\n         * console.log(params.toString());\n         * // Prints query%5B%5D=abc&#x26;query%5B%5D=123&#x26;type=search\n         * ```\n         * @since v7.7.0, v6.13.0\n         */\n        sort(): void;\n        /**\n         * Returns the search parameters serialized as a string, with characters\n         * percent-encoded where necessary.\n         */\n        toString(): string;\n        /**\n         * Returns an ES6 `Iterator` over the values of each name-value pair.\n         */\n        values(): IterableIterator<string>;\n        [Symbol.iterator](): IterableIterator<[string, string]>;\n    }\n    import { URL as _URL, URLSearchParams as _URLSearchParams } from \"url\";\n    global {\n        interface URLSearchParams extends _URLSearchParams {}\n        interface URL extends _URL {}\n        interface Global {\n            URL: typeof _URL;\n            URLSearchParams: typeof _URLSearchParams;\n        }\n        /**\n         * `URL` class is a global reference for `require('url').URL`\n         * https://nodejs.org/api/url.html#the-whatwg-url-api\n         * @since v10.0.0\n         */\n        var URL: typeof globalThis extends {\n            onmessage: any;\n            URL: infer T;\n        } ? T\n            : typeof _URL;\n        /**\n         * `URLSearchParams` class is a global reference for `require('url').URLSearchParams`\n         * https://nodejs.org/api/url.html#class-urlsearchparams\n         * @since v10.0.0\n         */\n        var URLSearchParams: typeof globalThis extends {\n            onmessage: any;\n            URLSearchParams: infer T;\n        } ? T\n            : typeof _URLSearchParams;\n    }\n}\ndeclare module \"node:url\" {\n    export * from \"url\";\n}\n"},32999:e=>{e.exports="/**\n * The `node:util` module supports the needs of Node.js internal APIs. Many of the\n * utilities are useful for application and module developers as well. To access\n * it:\n *\n * ```js\n * const util = require('node:util');\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/util.js)\n */\ndeclare module \"util\" {\n    import * as types from \"node:util/types\";\n    export interface InspectOptions {\n        /**\n         * If `true`, object's non-enumerable symbols and properties are included in the formatted result.\n         * `WeakMap` and `WeakSet` entries are also included as well as user defined prototype properties (excluding method properties).\n         * @default false\n         */\n        showHidden?: boolean | undefined;\n        /**\n         * Specifies the number of times to recurse while formatting object.\n         * This is useful for inspecting large objects.\n         * To recurse up to the maximum call stack size pass `Infinity` or `null`.\n         * @default 2\n         */\n        depth?: number | null | undefined;\n        /**\n         * If `true`, the output is styled with ANSI color codes. Colors are customizable.\n         */\n        colors?: boolean | undefined;\n        /**\n         * If `false`, `[util.inspect.custom](depth, opts, inspect)` functions are not invoked.\n         * @default true\n         */\n        customInspect?: boolean | undefined;\n        /**\n         * If `true`, `Proxy` inspection includes the target and handler objects.\n         * @default false\n         */\n        showProxy?: boolean | undefined;\n        /**\n         * Specifies the maximum number of `Array`, `TypedArray`, `WeakMap`, and `WeakSet` elements\n         * to include when formatting. Set to `null` or `Infinity` to show all elements.\n         * Set to `0` or negative to show no elements.\n         * @default 100\n         */\n        maxArrayLength?: number | null | undefined;\n        /**\n         * Specifies the maximum number of characters to\n         * include when formatting. Set to `null` or `Infinity` to show all elements.\n         * Set to `0` or negative to show no characters.\n         * @default 10000\n         */\n        maxStringLength?: number | null | undefined;\n        /**\n         * The length at which input values are split across multiple lines.\n         * Set to `Infinity` to format the input as a single line\n         * (in combination with `compact` set to `true` or any number >= `1`).\n         * @default 80\n         */\n        breakLength?: number | undefined;\n        /**\n         * Setting this to `false` causes each object key\n         * to be displayed on a new line. It will also add new lines to text that is\n         * longer than `breakLength`. If set to a number, the most `n` inner elements\n         * are united on a single line as long as all properties fit into\n         * `breakLength`. Short array elements are also grouped together. Note that no\n         * text will be reduced below 16 characters, no matter the `breakLength` size.\n         * For more information, see the example below.\n         * @default true\n         */\n        compact?: boolean | number | undefined;\n        /**\n         * If set to `true` or a function, all properties of an object, and `Set` and `Map`\n         * entries are sorted in the resulting string.\n         * If set to `true` the default sort is used.\n         * If set to a function, it is used as a compare function.\n         */\n        sorted?: boolean | ((a: string, b: string) => number) | undefined;\n        /**\n         * If set to `true`, getters are going to be\n         * inspected as well. If set to `'get'` only getters without setter are going\n         * to be inspected. If set to `'set'` only getters having a corresponding\n         * setter are going to be inspected. This might cause side effects depending on\n         * the getter function.\n         * @default false\n         */\n        getters?: \"get\" | \"set\" | boolean | undefined;\n        /**\n         * If set to `true`, an underscore is used to separate every three digits in all bigints and numbers.\n         * @default false\n         */\n        numericSeparator?: boolean | undefined;\n    }\n    export type Style =\n        | \"special\"\n        | \"number\"\n        | \"bigint\"\n        | \"boolean\"\n        | \"undefined\"\n        | \"null\"\n        | \"string\"\n        | \"symbol\"\n        | \"date\"\n        | \"regexp\"\n        | \"module\";\n    export type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => any; // TODO: , inspect: inspect\n    export interface InspectOptionsStylized extends InspectOptions {\n        stylize(text: string, styleType: Style): string;\n    }\n    /**\n     * The `util.format()` method returns a formatted string using the first argument\n     * as a `printf`\\-like format string which can contain zero or more format\n     * specifiers. Each specifier is replaced with the converted value from the\n     * corresponding argument. Supported specifiers are:\n     *\n     * If a specifier does not have a corresponding argument, it is not replaced:\n     *\n     * ```js\n     * util.format('%s:%s', 'foo');\n     * // Returns: 'foo:%s'\n     * ```\n     *\n     * Values that are not part of the format string are formatted using`util.inspect()` if their type is not `string`.\n     *\n     * If there are more arguments passed to the `util.format()` method than the\n     * number of specifiers, the extra arguments are concatenated to the returned\n     * string, separated by spaces:\n     *\n     * ```js\n     * util.format('%s:%s', 'foo', 'bar', 'baz');\n     * // Returns: 'foo:bar baz'\n     * ```\n     *\n     * If the first argument does not contain a valid format specifier, `util.format()`returns a string that is the concatenation of all arguments separated by spaces:\n     *\n     * ```js\n     * util.format(1, 2, 3);\n     * // Returns: '1 2 3'\n     * ```\n     *\n     * If only one argument is passed to `util.format()`, it is returned as it is\n     * without any formatting:\n     *\n     * ```js\n     * util.format('%% %s');\n     * // Returns: '%% %s'\n     * ```\n     *\n     * `util.format()` is a synchronous method that is intended as a debugging tool.\n     * Some input values can have a significant performance overhead that can block the\n     * event loop. Use this function with care and never in a hot code path.\n     * @since v0.5.3\n     * @param format A `printf`-like format string.\n     */\n    export function format(format?: any, ...param: any[]): string;\n    /**\n     * This function is identical to {@link format}, except in that it takes\n     * an `inspectOptions` argument which specifies options that are passed along to {@link inspect}.\n     *\n     * ```js\n     * util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 });\n     * // Returns 'See object { foo: 42 }', where `42` is colored as a number\n     * // when printed to a terminal.\n     * ```\n     * @since v10.0.0\n     */\n    export function formatWithOptions(inspectOptions: InspectOptions, format?: any, ...param: any[]): string;\n    /**\n     * Returns the string name for a numeric error code that comes from a Node.js API.\n     * The mapping between error codes and error names is platform-dependent.\n     * See `Common System Errors` for the names of common errors.\n     *\n     * ```js\n     * fs.access('file/that/does/not/exist', (err) => {\n     *   const name = util.getSystemErrorName(err.errno);\n     *   console.error(name);  // ENOENT\n     * });\n     * ```\n     * @since v9.7.0\n     */\n    export function getSystemErrorName(err: number): string;\n    /**\n     * Returns a Map of all system error codes available from the Node.js API.\n     * The mapping between error codes and error names is platform-dependent.\n     * See `Common System Errors` for the names of common errors.\n     *\n     * ```js\n     * fs.access('file/that/does/not/exist', (err) => {\n     *   const errorMap = util.getSystemErrorMap();\n     *   const name = errorMap.get(err.errno);\n     *   console.error(name);  // ENOENT\n     * });\n     * ```\n     * @since v16.0.0, v14.17.0\n     */\n    export function getSystemErrorMap(): Map<number, [string, string]>;\n    /**\n     * The `util.log()` method prints the given `string` to `stdout` with an included\n     * timestamp.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.log('Timestamped message.');\n     * ```\n     * @since v0.3.0\n     * @deprecated Since v6.0.0 - Use a third party module instead.\n     */\n    export function log(string: string): void;\n    /**\n     * Returns the `string` after replacing any surrogate code points\n     * (or equivalently, any unpaired surrogate code units) with the\n     * Unicode \"replacement character\" U+FFFD.\n     * @since v16.8.0, v14.18.0\n     */\n    export function toUSVString(string: string): string;\n    /**\n     * Creates and returns an `AbortController` instance whose `AbortSignal` is marked\n     * as transferable and can be used with `structuredClone()` or `postMessage()`.\n     * @since v18.11.0\n     * @experimental\n     * @returns A transferable AbortController\n     */\n    export function transferableAbortController(): AbortController;\n    /**\n     * Marks the given `AbortSignal` as transferable so that it can be used with`structuredClone()` and `postMessage()`.\n     *\n     * ```js\n     * const signal = transferableAbortSignal(AbortSignal.timeout(100));\n     * const channel = new MessageChannel();\n     * channel.port2.postMessage(signal, [signal]);\n     * ```\n     * @since v18.11.0\n     * @experimental\n     * @param signal The AbortSignal\n     * @returns The same AbortSignal\n     */\n    export function transferableAbortSignal(signal: AbortSignal): AbortSignal;\n    /**\n     * Listens to abort event on the provided `signal` and\n     * returns a promise that is fulfilled when the `signal` is\n     * aborted. If the passed `resource` is garbage collected before the `signal` is\n     * aborted, the returned promise shall remain pending indefinitely.\n     *\n     * ```js\n     * import { aborted } from 'node:util';\n     *\n     * const dependent = obtainSomethingAbortable();\n     *\n     * aborted(dependent.signal, dependent).then(() => {\n     *   // Do something when dependent is aborted.\n     * });\n     *\n     * dependent.on('event', () => {\n     *   dependent.abort();\n     * });\n     * ```\n     * @since v19.7.0\n     * @experimental\n     * @param resource Any non-null entity, reference to which is held weakly.\n     */\n    export function aborted(signal: AbortSignal, resource: any): Promise<void>;\n    /**\n     * The `util.inspect()` method returns a string representation of `object` that is\n     * intended for debugging. The output of `util.inspect` may change at any time\n     * and should not be depended upon programmatically. Additional `options` may be\n     * passed that alter the result.`util.inspect()` will use the constructor's name and/or `@@toStringTag` to make\n     * an identifiable tag for an inspected value.\n     *\n     * ```js\n     * class Foo {\n     *   get [Symbol.toStringTag]() {\n     *     return 'bar';\n     *   }\n     * }\n     *\n     * class Bar {}\n     *\n     * const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });\n     *\n     * util.inspect(new Foo()); // 'Foo [bar] {}'\n     * util.inspect(new Bar()); // 'Bar {}'\n     * util.inspect(baz);       // '[foo] {}'\n     * ```\n     *\n     * Circular references point to their anchor by using a reference index:\n     *\n     * ```js\n     * const { inspect } = require('node:util');\n     *\n     * const obj = {};\n     * obj.a = [obj];\n     * obj.b = {};\n     * obj.b.inner = obj.b;\n     * obj.b.obj = obj;\n     *\n     * console.log(inspect(obj));\n     * // <ref *1> {\n     * //   a: [ [Circular *1] ],\n     * //   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] }\n     * // }\n     * ```\n     *\n     * The following example inspects all properties of the `util` object:\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * console.log(util.inspect(util, { showHidden: true, depth: null }));\n     * ```\n     *\n     * The following example highlights the effect of the `compact` option:\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * const o = {\n     *   a: [1, 2, [[\n     *     'Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit, sed do ' +\n     *       'eiusmod \\ntempor incididunt ut labore et dolore magna aliqua.',\n     *     'test',\n     *     'foo']], 4],\n     *   b: new Map([['za', 1], ['zb', 'test']]),\n     * };\n     * console.log(util.inspect(o, { compact: true, depth: 5, breakLength: 80 }));\n     *\n     * // { a:\n     * //   [ 1,\n     * //     2,\n     * //     [ [ 'Lorem ipsum dolor sit amet,\\nconsectetur [...]', // A long line\n     * //           'test',\n     * //           'foo' ] ],\n     * //     4 ],\n     * //   b: Map(2) { 'za' => 1, 'zb' => 'test' } }\n     *\n     * // Setting `compact` to false or an integer creates more reader friendly output.\n     * console.log(util.inspect(o, { compact: false, depth: 5, breakLength: 80 }));\n     *\n     * // {\n     * //   a: [\n     * //     1,\n     * //     2,\n     * //     [\n     * //       [\n     * //         'Lorem ipsum dolor sit amet,\\n' +\n     * //           'consectetur adipiscing elit, sed do eiusmod \\n' +\n     * //           'tempor incididunt ut labore et dolore magna aliqua.',\n     * //         'test',\n     * //         'foo'\n     * //       ]\n     * //     ],\n     * //     4\n     * //   ],\n     * //   b: Map(2) {\n     * //     'za' => 1,\n     * //     'zb' => 'test'\n     * //   }\n     * // }\n     *\n     * // Setting `breakLength` to e.g. 150 will print the \"Lorem ipsum\" text in a\n     * // single line.\n     * ```\n     *\n     * The `showHidden` option allows [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) and\n     * [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) entries to be\n     * inspected. If there are more entries than `maxArrayLength`, there is no\n     * guarantee which entries are displayed. That means retrieving the same [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) entries twice may\n     * result in different output. Furthermore, entries\n     * with no remaining strong references may be garbage collected at any time.\n     *\n     * ```js\n     * const { inspect } = require('node:util');\n     *\n     * const obj = { a: 1 };\n     * const obj2 = { b: 2 };\n     * const weakSet = new WeakSet([obj, obj2]);\n     *\n     * console.log(inspect(weakSet, { showHidden: true }));\n     * // WeakSet { { a: 1 }, { b: 2 } }\n     * ```\n     *\n     * The `sorted` option ensures that an object's property insertion order does not\n     * impact the result of `util.inspect()`.\n     *\n     * ```js\n     * const { inspect } = require('node:util');\n     * const assert = require('node:assert');\n     *\n     * const o1 = {\n     *   b: [2, 3, 1],\n     *   a: '`a` comes before `b`',\n     *   c: new Set([2, 3, 1]),\n     * };\n     * console.log(inspect(o1, { sorted: true }));\n     * // { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } }\n     * console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) }));\n     * // { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }\n     *\n     * const o2 = {\n     *   c: new Set([2, 1, 3]),\n     *   a: '`a` comes before `b`',\n     *   b: [2, 3, 1],\n     * };\n     * assert.strict.equal(\n     *   inspect(o1, { sorted: true }),\n     *   inspect(o2, { sorted: true }),\n     * );\n     * ```\n     *\n     * The `numericSeparator` option adds an underscore every three digits to all\n     * numbers.\n     *\n     * ```js\n     * const { inspect } = require('node:util');\n     *\n     * const thousand = 1_000;\n     * const million = 1_000_000;\n     * const bigNumber = 123_456_789n;\n     * const bigDecimal = 1_234.123_45;\n     *\n     * console.log(inspect(thousand, { numericSeparator: true }));\n     * // 1_000\n     * console.log(inspect(million, { numericSeparator: true }));\n     * // 1_000_000\n     * console.log(inspect(bigNumber, { numericSeparator: true }));\n     * // 123_456_789n\n     * console.log(inspect(bigDecimal, { numericSeparator: true }));\n     * // 1_234.123_45\n     * ```\n     *\n     * `util.inspect()` is a synchronous method intended for debugging. Its maximum\n     * output length is approximately 128 MiB. Inputs that result in longer output will\n     * be truncated.\n     * @since v0.3.0\n     * @param object Any JavaScript primitive or `Object`.\n     * @return The representation of `object`.\n     */\n    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n    export function inspect(object: any, options?: InspectOptions): string;\n    export namespace inspect {\n        let colors: NodeJS.Dict<[number, number]>;\n        let styles: {\n            [K in Style]: string;\n        };\n        let defaultOptions: InspectOptions;\n        /**\n         * Allows changing inspect settings from the repl.\n         */\n        let replDefaults: InspectOptions;\n        /**\n         * That can be used to declare custom inspect functions.\n         */\n        const custom: unique symbol;\n    }\n    /**\n     * Alias for [`Array.isArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).\n     *\n     * Returns `true` if the given `object` is an `Array`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isArray([]);\n     * // Returns: true\n     * util.isArray(new Array());\n     * // Returns: true\n     * util.isArray({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use `isArray` instead.\n     */\n    export function isArray(object: unknown): object is unknown[];\n    /**\n     * Returns `true` if the given `object` is a `RegExp`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isRegExp(/some regexp/);\n     * // Returns: true\n     * util.isRegExp(new RegExp('another regexp'));\n     * // Returns: true\n     * util.isRegExp({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Deprecated\n     */\n    export function isRegExp(object: unknown): object is RegExp;\n    /**\n     * Returns `true` if the given `object` is a `Date`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isDate(new Date());\n     * // Returns: true\n     * util.isDate(Date());\n     * // false (without 'new' returns a String)\n     * util.isDate({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use {@link types.isDate} instead.\n     */\n    export function isDate(object: unknown): object is Date;\n    /**\n     * Returns `true` if the given `object` is an `Error`. Otherwise, returns`false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isError(new Error());\n     * // Returns: true\n     * util.isError(new TypeError());\n     * // Returns: true\n     * util.isError({ name: 'Error', message: 'an error occurred' });\n     * // Returns: false\n     * ```\n     *\n     * This method relies on `Object.prototype.toString()` behavior. It is\n     * possible to obtain an incorrect result when the `object` argument manipulates`@@toStringTag`.\n     *\n     * ```js\n     * const util = require('node:util');\n     * const obj = { name: 'Error', message: 'an error occurred' };\n     *\n     * util.isError(obj);\n     * // Returns: false\n     * obj[Symbol.toStringTag] = 'Error';\n     * util.isError(obj);\n     * // Returns: true\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use {@link types.isNativeError} instead.\n     */\n    export function isError(object: unknown): object is Error;\n    /**\n     * Usage of `util.inherits()` is discouraged. Please use the ES6 `class` and`extends` keywords to get language level inheritance support. Also note\n     * that the two styles are [semantically incompatible](https://github.com/nodejs/node/issues/4179).\n     *\n     * Inherit the prototype methods from one [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) into another. The\n     * prototype of `constructor` will be set to a new object created from`superConstructor`.\n     *\n     * This mainly adds some input validation on top of`Object.setPrototypeOf(constructor.prototype, superConstructor.prototype)`.\n     * As an additional convenience, `superConstructor` will be accessible\n     * through the `constructor.super_` property.\n     *\n     * ```js\n     * const util = require('node:util');\n     * const EventEmitter = require('node:events');\n     *\n     * function MyStream() {\n     *   EventEmitter.call(this);\n     * }\n     *\n     * util.inherits(MyStream, EventEmitter);\n     *\n     * MyStream.prototype.write = function(data) {\n     *   this.emit('data', data);\n     * };\n     *\n     * const stream = new MyStream();\n     *\n     * console.log(stream instanceof EventEmitter); // true\n     * console.log(MyStream.super_ === EventEmitter); // true\n     *\n     * stream.on('data', (data) => {\n     *   console.log(`Received data: \"${data}\"`);\n     * });\n     * stream.write('It works!'); // Received data: \"It works!\"\n     * ```\n     *\n     * ES6 example using `class` and `extends`:\n     *\n     * ```js\n     * const EventEmitter = require('node:events');\n     *\n     * class MyStream extends EventEmitter {\n     *   write(data) {\n     *     this.emit('data', data);\n     *   }\n     * }\n     *\n     * const stream = new MyStream();\n     *\n     * stream.on('data', (data) => {\n     *   console.log(`Received data: \"${data}\"`);\n     * });\n     * stream.write('With ES6');\n     * ```\n     * @since v0.3.0\n     * @legacy Use ES2015 class syntax and `extends` keyword instead.\n     */\n    export function inherits(constructor: unknown, superConstructor: unknown): void;\n    export type DebugLoggerFunction = (msg: string, ...param: unknown[]) => void;\n    export interface DebugLogger extends DebugLoggerFunction {\n        enabled: boolean;\n    }\n    /**\n     * The `util.debuglog()` method is used to create a function that conditionally\n     * writes debug messages to `stderr` based on the existence of the `NODE_DEBUG`environment variable. If the `section` name appears within the value of that\n     * environment variable, then the returned function operates similar to `console.error()`. If not, then the returned function is a no-op.\n     *\n     * ```js\n     * const util = require('node:util');\n     * const debuglog = util.debuglog('foo');\n     *\n     * debuglog('hello from foo [%d]', 123);\n     * ```\n     *\n     * If this program is run with `NODE_DEBUG=foo` in the environment, then\n     * it will output something like:\n     *\n     * ```console\n     * FOO 3245: hello from foo [123]\n     * ```\n     *\n     * where `3245` is the process id. If it is not run with that\n     * environment variable set, then it will not print anything.\n     *\n     * The `section` supports wildcard also:\n     *\n     * ```js\n     * const util = require('node:util');\n     * const debuglog = util.debuglog('foo-bar');\n     *\n     * debuglog('hi there, it\\'s foo-bar [%d]', 2333);\n     * ```\n     *\n     * if it is run with `NODE_DEBUG=foo*` in the environment, then it will output\n     * something like:\n     *\n     * ```console\n     * FOO-BAR 3257: hi there, it's foo-bar [2333]\n     * ```\n     *\n     * Multiple comma-separated `section` names may be specified in the `NODE_DEBUG`environment variable: `NODE_DEBUG=fs,net,tls`.\n     *\n     * The optional `callback` argument can be used to replace the logging function\n     * with a different function that doesn't have any initialization or\n     * unnecessary wrapping.\n     *\n     * ```js\n     * const util = require('node:util');\n     * let debuglog = util.debuglog('internals', (debug) => {\n     *   // Replace with a logging function that optimizes out\n     *   // testing if the section is enabled\n     *   debuglog = debug;\n     * });\n     * ```\n     * @since v0.11.3\n     * @param section A string identifying the portion of the application for which the `debuglog` function is being created.\n     * @param callback A callback invoked the first time the logging function is called with a function argument that is a more optimized logging function.\n     * @return The logging function\n     */\n    export function debuglog(section: string, callback?: (fn: DebugLoggerFunction) => void): DebugLogger;\n    export const debug: typeof debuglog;\n    /**\n     * Returns `true` if the given `object` is a `Boolean`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isBoolean(1);\n     * // Returns: false\n     * util.isBoolean(0);\n     * // Returns: false\n     * util.isBoolean(false);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'boolean'` instead.\n     */\n    export function isBoolean(object: unknown): object is boolean;\n    /**\n     * Returns `true` if the given `object` is a `Buffer`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isBuffer({ length: 0 });\n     * // Returns: false\n     * util.isBuffer([]);\n     * // Returns: false\n     * util.isBuffer(Buffer.from('hello world'));\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `isBuffer` instead.\n     */\n    export function isBuffer(object: unknown): object is Buffer;\n    /**\n     * Returns `true` if the given `object` is a `Function`. Otherwise, returns`false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * function Foo() {}\n     * const Bar = () => {};\n     *\n     * util.isFunction({});\n     * // Returns: false\n     * util.isFunction(Foo);\n     * // Returns: true\n     * util.isFunction(Bar);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'function'` instead.\n     */\n    export function isFunction(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is strictly `null`. Otherwise, returns`false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isNull(0);\n     * // Returns: false\n     * util.isNull(undefined);\n     * // Returns: false\n     * util.isNull(null);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === null` instead.\n     */\n    export function isNull(object: unknown): object is null;\n    /**\n     * Returns `true` if the given `object` is `null` or `undefined`. Otherwise,\n     * returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isNullOrUndefined(0);\n     * // Returns: false\n     * util.isNullOrUndefined(undefined);\n     * // Returns: true\n     * util.isNullOrUndefined(null);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === undefined || value === null` instead.\n     */\n    export function isNullOrUndefined(object: unknown): object is null | undefined;\n    /**\n     * Returns `true` if the given `object` is a `Number`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isNumber(false);\n     * // Returns: false\n     * util.isNumber(Infinity);\n     * // Returns: true\n     * util.isNumber(0);\n     * // Returns: true\n     * util.isNumber(NaN);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'number'` instead.\n     */\n    export function isNumber(object: unknown): object is number;\n    /**\n     * Returns `true` if the given `object` is strictly an `Object`**and** not a`Function` (even though functions are objects in JavaScript).\n     * Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isObject(5);\n     * // Returns: false\n     * util.isObject(null);\n     * // Returns: false\n     * util.isObject({});\n     * // Returns: true\n     * util.isObject(() => {});\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value !== null && typeof value === 'object'` instead.\n     */\n    export function isObject(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is a primitive type. Otherwise, returns`false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isPrimitive(5);\n     * // Returns: true\n     * util.isPrimitive('foo');\n     * // Returns: true\n     * util.isPrimitive(false);\n     * // Returns: true\n     * util.isPrimitive(null);\n     * // Returns: true\n     * util.isPrimitive(undefined);\n     * // Returns: true\n     * util.isPrimitive({});\n     * // Returns: false\n     * util.isPrimitive(() => {});\n     * // Returns: false\n     * util.isPrimitive(/^$/);\n     * // Returns: false\n     * util.isPrimitive(new Date());\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead.\n     */\n    export function isPrimitive(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is a `string`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isString('');\n     * // Returns: true\n     * util.isString('foo');\n     * // Returns: true\n     * util.isString(String('foo'));\n     * // Returns: true\n     * util.isString(5);\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'string'` instead.\n     */\n    export function isString(object: unknown): object is string;\n    /**\n     * Returns `true` if the given `object` is a `Symbol`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * util.isSymbol(5);\n     * // Returns: false\n     * util.isSymbol('foo');\n     * // Returns: false\n     * util.isSymbol(Symbol('foo'));\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'symbol'` instead.\n     */\n    export function isSymbol(object: unknown): object is symbol;\n    /**\n     * Returns `true` if the given `object` is `undefined`. Otherwise, returns `false`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * const foo = undefined;\n     * util.isUndefined(5);\n     * // Returns: false\n     * util.isUndefined(foo);\n     * // Returns: true\n     * util.isUndefined(null);\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === undefined` instead.\n     */\n    export function isUndefined(object: unknown): object is undefined;\n    /**\n     * The `util.deprecate()` method wraps `fn` (which may be a function or class) in\n     * such a way that it is marked as deprecated.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * exports.obsoleteFunction = util.deprecate(() => {\n     *   // Do something here.\n     * }, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');\n     * ```\n     *\n     * When called, `util.deprecate()` will return a function that will emit a`DeprecationWarning` using the `'warning'` event. The warning will\n     * be emitted and printed to `stderr` the first time the returned function is\n     * called. After the warning is emitted, the wrapped function is called without\n     * emitting a warning.\n     *\n     * If the same optional `code` is supplied in multiple calls to `util.deprecate()`,\n     * the warning will be emitted only once for that `code`.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * const fn1 = util.deprecate(someFunction, someMessage, 'DEP0001');\n     * const fn2 = util.deprecate(someOtherFunction, someOtherMessage, 'DEP0001');\n     * fn1(); // Emits a deprecation warning with code DEP0001\n     * fn2(); // Does not emit a deprecation warning because it has the same code\n     * ```\n     *\n     * If either the `--no-deprecation` or `--no-warnings` command-line flags are\n     * used, or if the `process.noDeprecation` property is set to `true`_prior_ to\n     * the first deprecation warning, the `util.deprecate()` method does nothing.\n     *\n     * If the `--trace-deprecation` or `--trace-warnings` command-line flags are set,\n     * or the `process.traceDeprecation` property is set to `true`, a warning and a\n     * stack trace are printed to `stderr` the first time the deprecated function is\n     * called.\n     *\n     * If the `--throw-deprecation` command-line flag is set, or the`process.throwDeprecation` property is set to `true`, then an exception will be\n     * thrown when the deprecated function is called.\n     *\n     * The `--throw-deprecation` command-line flag and `process.throwDeprecation`property take precedence over `--trace-deprecation` and`process.traceDeprecation`.\n     * @since v0.8.0\n     * @param fn The function that is being deprecated.\n     * @param msg A warning message to display when the deprecated function is invoked.\n     * @param code A deprecation code. See the `list of deprecated APIs` for a list of codes.\n     * @return The deprecated function wrapped to emit a warning.\n     */\n    export function deprecate<T extends Function>(fn: T, msg: string, code?: string): T;\n    /**\n     * Returns `true` if there is deep strict equality between `val1` and `val2`.\n     * Otherwise, returns `false`.\n     *\n     * See `assert.deepStrictEqual()` for more information about deep strict\n     * equality.\n     * @since v9.0.0\n     */\n    export function isDeepStrictEqual(val1: unknown, val2: unknown): boolean;\n    /**\n     * Returns `str` with any ANSI escape codes removed.\n     *\n     * ```js\n     * console.log(util.stripVTControlCharacters('\\u001B[4mvalue\\u001B[0m'));\n     * // Prints \"value\"\n     * ```\n     * @since v16.11.0\n     */\n    export function stripVTControlCharacters(str: string): string;\n    /**\n     * Takes an `async` function (or a function that returns a `Promise`) and returns a\n     * function following the error-first callback style, i.e. taking\n     * an `(err, value) => ...` callback as the last argument. In the callback, the\n     * first argument will be the rejection reason (or `null` if the `Promise`resolved), and the second argument will be the resolved value.\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * async function fn() {\n     *   return 'hello world';\n     * }\n     * const callbackFunction = util.callbackify(fn);\n     *\n     * callbackFunction((err, ret) => {\n     *   if (err) throw err;\n     *   console.log(ret);\n     * });\n     * ```\n     *\n     * Will print:\n     *\n     * ```text\n     * hello world\n     * ```\n     *\n     * The callback is executed asynchronously, and will have a limited stack trace.\n     * If the callback throws, the process will emit an `'uncaughtException'` event, and if not handled will exit.\n     *\n     * Since `null` has a special meaning as the first argument to a callback, if a\n     * wrapped function rejects a `Promise` with a falsy value as a reason, the value\n     * is wrapped in an `Error` with the original value stored in a field named`reason`.\n     *\n     * ```js\n     * function fn() {\n     *   return Promise.reject(null);\n     * }\n     * const callbackFunction = util.callbackify(fn);\n     *\n     * callbackFunction((err, ret) => {\n     *   // When the Promise was rejected with `null` it is wrapped with an Error and\n     *   // the original value is stored in `reason`.\n     *   err &#x26;&#x26; Object.hasOwn(err, 'reason') &#x26;&#x26; err.reason === null;  // true\n     * });\n     * ```\n     * @since v8.2.0\n     * @param fn An `async` function\n     * @return a callback style function\n     */\n    export function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<TResult>(\n        fn: () => Promise<TResult>,\n    ): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    export function callbackify<T1>(\n        fn: (arg1: T1) => Promise<void>,\n    ): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, TResult>(\n        fn: (arg1: T1) => Promise<TResult>,\n    ): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    export function callbackify<T1, T2>(\n        fn: (arg1: T1, arg2: T2) => Promise<void>,\n    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, TResult>(\n        fn: (arg1: T1, arg2: T2) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    export function callbackify<T1, T2, T3>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    export function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        arg6: T6,\n        callback: (err: NodeJS.ErrnoException) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        arg6: T6,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export interface CustomPromisifyLegacy<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n    export interface CustomPromisifySymbol<TCustom extends Function> extends Function {\n        [promisify.custom]: TCustom;\n    }\n    export type CustomPromisify<TCustom extends Function> =\n        | CustomPromisifySymbol<TCustom>\n        | CustomPromisifyLegacy<TCustom>;\n    /**\n     * Takes a function following the common error-first callback style, i.e. taking\n     * an `(err, value) => ...` callback as the last argument, and returns a version\n     * that returns promises.\n     *\n     * ```js\n     * const util = require('node:util');\n     * const fs = require('node:fs');\n     *\n     * const stat = util.promisify(fs.stat);\n     * stat('.').then((stats) => {\n     *   // Do something with `stats`\n     * }).catch((error) => {\n     *   // Handle the error.\n     * });\n     * ```\n     *\n     * Or, equivalently using `async function`s:\n     *\n     * ```js\n     * const util = require('node:util');\n     * const fs = require('node:fs');\n     *\n     * const stat = util.promisify(fs.stat);\n     *\n     * async function callStat() {\n     *   const stats = await stat('.');\n     *   console.log(`This directory is owned by ${stats.uid}`);\n     * }\n     *\n     * callStat();\n     * ```\n     *\n     * If there is an `original[util.promisify.custom]` property present, `promisify`will return its value, see `Custom promisified functions`.\n     *\n     * `promisify()` assumes that `original` is a function taking a callback as its\n     * final argument in all cases. If `original` is not a function, `promisify()`will throw an error. If `original` is a function but its last argument is not\n     * an error-first callback, it will still be passed an error-first\n     * callback as its last argument.\n     *\n     * Using `promisify()` on class methods or other methods that use `this` may not\n     * work as expected unless handled specially:\n     *\n     * ```js\n     * const util = require('node:util');\n     *\n     * class Foo {\n     *   constructor() {\n     *     this.a = 42;\n     *   }\n     *\n     *   bar(callback) {\n     *     callback(null, this.a);\n     *   }\n     * }\n     *\n     * const foo = new Foo();\n     *\n     * const naiveBar = util.promisify(foo.bar);\n     * // TypeError: Cannot read property 'a' of undefined\n     * // naiveBar().then(a => console.log(a));\n     *\n     * naiveBar.call(foo).then((a) => console.log(a)); // '42'\n     *\n     * const bindBar = naiveBar.bind(foo);\n     * bindBar().then((a) => console.log(a)); // '42'\n     * ```\n     * @since v8.0.0\n     */\n    export function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    export function promisify<TResult>(\n        fn: (callback: (err: any, result: TResult) => void) => void,\n    ): () => Promise<TResult>;\n    export function promisify(fn: (callback: (err?: any) => void) => void): () => Promise<void>;\n    export function promisify<T1, TResult>(\n        fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1) => Promise<TResult>;\n    export function promisify<T1>(fn: (arg1: T1, callback: (err?: any) => void) => void): (arg1: T1) => Promise<void>;\n    export function promisify<T1, T2, TResult>(\n        fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2) => Promise<TResult>;\n    export function promisify<T1, T2>(\n        fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2) => Promise<void>;\n    export function promisify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    export function promisify<T1, T2, T3>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    export function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    export function promisify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    export function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    export function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    export function promisify(fn: Function): Function;\n    export namespace promisify {\n        /**\n         * That can be used to declare custom promisified variants of functions.\n         */\n        const custom: unique symbol;\n    }\n    /**\n     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextDecoder` API.\n     *\n     * ```js\n     * const decoder = new TextDecoder();\n     * const u8arr = new Uint8Array([72, 101, 108, 108, 111]);\n     * console.log(decoder.decode(u8arr)); // Hello\n     * ```\n     * @since v8.3.0\n     */\n    export class TextDecoder {\n        /**\n         * The encoding supported by the `TextDecoder` instance.\n         */\n        readonly encoding: string;\n        /**\n         * The value will be `true` if decoding errors result in a `TypeError` being\n         * thrown.\n         */\n        readonly fatal: boolean;\n        /**\n         * The value will be `true` if the decoding result will include the byte order\n         * mark.\n         */\n        readonly ignoreBOM: boolean;\n        constructor(\n            encoding?: string,\n            options?: {\n                fatal?: boolean | undefined;\n                ignoreBOM?: boolean | undefined;\n            },\n        );\n        /**\n         * Decodes the `input` and returns a string. If `options.stream` is `true`, any\n         * incomplete byte sequences occurring at the end of the `input` are buffered\n         * internally and emitted after the next call to `textDecoder.decode()`.\n         *\n         * If `textDecoder.fatal` is `true`, decoding errors that occur will result in a`TypeError` being thrown.\n         * @param input An `ArrayBuffer`, `DataView`, or `TypedArray` instance containing the encoded data.\n         */\n        decode(\n            input?: NodeJS.ArrayBufferView | ArrayBuffer | null,\n            options?: {\n                stream?: boolean | undefined;\n            },\n        ): string;\n    }\n    export interface EncodeIntoResult {\n        /**\n         * The read Unicode code units of input.\n         */\n        read: number;\n        /**\n         * The written UTF-8 bytes of output.\n         */\n        written: number;\n    }\n    export { types };\n\n    //// TextEncoder/Decoder\n    /**\n     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextEncoder` API. All\n     * instances of `TextEncoder` only support UTF-8 encoding.\n     *\n     * ```js\n     * const encoder = new TextEncoder();\n     * const uint8array = encoder.encode('this is some data');\n     * ```\n     *\n     * The `TextEncoder` class is also available on the global object.\n     * @since v8.3.0\n     */\n    export class TextEncoder {\n        /**\n         * The encoding supported by the `TextEncoder` instance. Always set to `'utf-8'`.\n         */\n        readonly encoding: string;\n        /**\n         * UTF-8 encodes the `input` string and returns a `Uint8Array` containing the\n         * encoded bytes.\n         * @param [input='an empty string'] The text to encode.\n         */\n        encode(input?: string): Uint8Array;\n        /**\n         * UTF-8 encodes the `src` string to the `dest` Uint8Array and returns an object\n         * containing the read Unicode code units and written UTF-8 bytes.\n         *\n         * ```js\n         * const encoder = new TextEncoder();\n         * const src = 'this is some data';\n         * const dest = new Uint8Array(10);\n         * const { read, written } = encoder.encodeInto(src, dest);\n         * ```\n         * @param src The text to encode.\n         * @param dest The array to hold the encode result.\n         */\n        encodeInto(src: string, dest: Uint8Array): EncodeIntoResult;\n    }\n    import { TextDecoder as _TextDecoder, TextEncoder as _TextEncoder } from \"util\";\n    global {\n        /**\n         * `TextDecoder` class is a global reference for `require('util').TextDecoder`\n         * https://nodejs.org/api/globals.html#textdecoder\n         * @since v11.0.0\n         */\n        var TextDecoder: typeof globalThis extends {\n            onmessage: any;\n            TextDecoder: infer TextDecoder;\n        } ? TextDecoder\n            : typeof _TextDecoder;\n        /**\n         * `TextEncoder` class is a global reference for `require('util').TextEncoder`\n         * https://nodejs.org/api/globals.html#textencoder\n         * @since v11.0.0\n         */\n        var TextEncoder: typeof globalThis extends {\n            onmessage: any;\n            TextEncoder: infer TextEncoder;\n        } ? TextEncoder\n            : typeof _TextEncoder;\n    }\n\n    //// parseArgs\n    /**\n     * Provides a higher level API for command-line argument parsing than interacting\n     * with `process.argv` directly. Takes a specification for the expected arguments\n     * and returns a structured object with the parsed options and positionals.\n     *\n     * ```js\n     * import { parseArgs } from 'node:util';\n     * const args = ['-f', '--bar', 'b'];\n     * const options = {\n     *   foo: {\n     *     type: 'boolean',\n     *     short: 'f',\n     *   },\n     *   bar: {\n     *     type: 'string',\n     *   },\n     * };\n     * const {\n     *   values,\n     *   positionals,\n     * } = parseArgs({ args, options });\n     * console.log(values, positionals);\n     * // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n     * ```\n     * @since v18.3.0, v16.17.0\n     * @param config Used to provide arguments for parsing and to configure the parser. `config` supports the following properties:\n     * @return The parsed command line arguments:\n     */\n    export function parseArgs<T extends ParseArgsConfig>(config?: T): ParsedResults<T>;\n    interface ParseArgsOptionConfig {\n        /**\n         * Type of argument.\n         */\n        type: \"string\" | \"boolean\";\n        /**\n         * Whether this option can be provided multiple times.\n         * If `true`, all values will be collected in an array.\n         * If `false`, values for the option are last-wins.\n         * @default false.\n         */\n        multiple?: boolean | undefined;\n        /**\n         * A single character alias for the option.\n         */\n        short?: string | undefined;\n        /**\n         * The default option value when it is not set by args.\n         * It must be of the same type as the the `type` property.\n         * When `multiple` is `true`, it must be an array.\n         * @since v18.11.0\n         */\n        default?: string | boolean | string[] | boolean[] | undefined;\n    }\n    interface ParseArgsOptionsConfig {\n        [longOption: string]: ParseArgsOptionConfig;\n    }\n    export interface ParseArgsConfig {\n        /**\n         * Array of argument strings.\n         */\n        args?: string[] | undefined;\n        /**\n         * Used to describe arguments known to the parser.\n         */\n        options?: ParseArgsOptionsConfig | undefined;\n        /**\n         * Should an error be thrown when unknown arguments are encountered,\n         * or when arguments are passed that do not match the `type` configured in `options`.\n         * @default true\n         */\n        strict?: boolean | undefined;\n        /**\n         * Whether this command accepts positional arguments.\n         */\n        allowPositionals?: boolean | undefined;\n        /**\n         * Return the parsed tokens. This is useful for extending the built-in behavior,\n         * from adding additional checks through to reprocessing the tokens in different ways.\n         * @default false\n         */\n        tokens?: boolean | undefined;\n    }\n    /*\n    IfDefaultsTrue and IfDefaultsFalse are helpers to handle default values for missing boolean properties.\n    TypeScript does not have exact types for objects: https://github.com/microsoft/TypeScript/issues/12936\n    This means it is impossible to distinguish between \"field X is definitely not present\" and \"field X may or may not be present\".\n    But we expect users to generally provide their config inline or `as const`, which means TS will always know whether a given field is present.\n    So this helper treats \"not definitely present\" (i.e., not `extends boolean`) as being \"definitely not present\", i.e. it should have its default value.\n    This is technically incorrect but is a much nicer UX for the common case.\n    The IfDefaultsTrue version is for things which default to true; the IfDefaultsFalse version is for things which default to false.\n    */\n    type IfDefaultsTrue<T, IfTrue, IfFalse> = T extends true ? IfTrue\n        : T extends false ? IfFalse\n        : IfTrue;\n\n    // we put the `extends false` condition first here because `undefined` compares like `any` when `strictNullChecks: false`\n    type IfDefaultsFalse<T, IfTrue, IfFalse> = T extends false ? IfFalse\n        : T extends true ? IfTrue\n        : IfFalse;\n\n    type ExtractOptionValue<T extends ParseArgsConfig, O extends ParseArgsOptionConfig> = IfDefaultsTrue<\n        T[\"strict\"],\n        O[\"type\"] extends \"string\" ? string : O[\"type\"] extends \"boolean\" ? boolean : string | boolean,\n        string | boolean\n    >;\n\n    type ParsedValues<T extends ParseArgsConfig> =\n        & IfDefaultsTrue<T[\"strict\"], unknown, { [longOption: string]: undefined | string | boolean }>\n        & (T[\"options\"] extends ParseArgsOptionsConfig ? {\n                -readonly [LongOption in keyof T[\"options\"]]: IfDefaultsFalse<\n                    T[\"options\"][LongOption][\"multiple\"],\n                    undefined | Array<ExtractOptionValue<T, T[\"options\"][LongOption]>>,\n                    undefined | ExtractOptionValue<T, T[\"options\"][LongOption]>\n                >;\n            }\n            : {});\n\n    type ParsedPositionals<T extends ParseArgsConfig> = IfDefaultsTrue<\n        T[\"strict\"],\n        IfDefaultsFalse<T[\"allowPositionals\"], string[], []>,\n        IfDefaultsTrue<T[\"allowPositionals\"], string[], []>\n    >;\n\n    type PreciseTokenForOptions<\n        K extends string,\n        O extends ParseArgsOptionConfig,\n    > = O[\"type\"] extends \"string\" ? {\n            kind: \"option\";\n            index: number;\n            name: K;\n            rawName: string;\n            value: string;\n            inlineValue: boolean;\n        }\n        : O[\"type\"] extends \"boolean\" ? {\n                kind: \"option\";\n                index: number;\n                name: K;\n                rawName: string;\n                value: undefined;\n                inlineValue: undefined;\n            }\n        : OptionToken & { name: K };\n\n    type TokenForOptions<\n        T extends ParseArgsConfig,\n        K extends keyof T[\"options\"] = keyof T[\"options\"],\n    > = K extends unknown\n        ? T[\"options\"] extends ParseArgsOptionsConfig ? PreciseTokenForOptions<K & string, T[\"options\"][K]>\n        : OptionToken\n        : never;\n\n    type ParsedOptionToken<T extends ParseArgsConfig> = IfDefaultsTrue<T[\"strict\"], TokenForOptions<T>, OptionToken>;\n\n    type ParsedPositionalToken<T extends ParseArgsConfig> = IfDefaultsTrue<\n        T[\"strict\"],\n        IfDefaultsFalse<T[\"allowPositionals\"], { kind: \"positional\"; index: number; value: string }, never>,\n        IfDefaultsTrue<T[\"allowPositionals\"], { kind: \"positional\"; index: number; value: string }, never>\n    >;\n\n    type ParsedTokens<T extends ParseArgsConfig> = Array<\n        ParsedOptionToken<T> | ParsedPositionalToken<T> | { kind: \"option-terminator\"; index: number }\n    >;\n\n    type PreciseParsedResults<T extends ParseArgsConfig> = IfDefaultsFalse<\n        T[\"tokens\"],\n        {\n            values: ParsedValues<T>;\n            positionals: ParsedPositionals<T>;\n            tokens: ParsedTokens<T>;\n        },\n        {\n            values: ParsedValues<T>;\n            positionals: ParsedPositionals<T>;\n        }\n    >;\n\n    type OptionToken =\n        | { kind: \"option\"; index: number; name: string; rawName: string; value: string; inlineValue: boolean }\n        | {\n            kind: \"option\";\n            index: number;\n            name: string;\n            rawName: string;\n            value: undefined;\n            inlineValue: undefined;\n        };\n\n    type Token =\n        | OptionToken\n        | { kind: \"positional\"; index: number; value: string }\n        | { kind: \"option-terminator\"; index: number };\n\n    // If ParseArgsConfig extends T, then the user passed config constructed elsewhere.\n    // So we can't rely on the `\"not definitely present\" implies \"definitely not present\"` assumption mentioned above.\n    type ParsedResults<T extends ParseArgsConfig> = ParseArgsConfig extends T ? {\n            values: {\n                [longOption: string]: undefined | string | boolean | Array<string | boolean>;\n            };\n            positionals: string[];\n            tokens?: Token[];\n        }\n        : PreciseParsedResults<T>;\n\n    /**\n     * An implementation of [the MIMEType class](https://bmeck.github.io/node-proposal-mime-api/).\n     *\n     * In accordance with browser conventions, all properties of `MIMEType` objects\n     * are implemented as getters and setters on the class prototype, rather than as\n     * data properties on the object itself.\n     *\n     * A MIME string is a structured string containing multiple meaningful\n     * components. When parsed, a `MIMEType` object is returned containing\n     * properties for each of these components.\n     * @since v19.1.0, v18.13.0\n     * @experimental\n     */\n    export class MIMEType {\n        /**\n         * Creates a new MIMEType object by parsing the input.\n         *\n         * A `TypeError` will be thrown if the `input` is not a valid MIME.\n         * Note that an effort will be made to coerce the given values into strings.\n         * @param input The input MIME to parse.\n         */\n        constructor(input: string | { toString: () => string });\n\n        /**\n         * Gets and sets the type portion of the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/javascript');\n         * console.log(myMIME.type);\n         * // Prints: text\n         * myMIME.type = 'application';\n         * console.log(myMIME.type);\n         * // Prints: application\n         * console.log(String(myMIME));\n         * // Prints: application/javascript\n         * ```\n         */\n        type: string;\n        /**\n         * Gets and sets the subtype portion of the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/ecmascript');\n         * console.log(myMIME.subtype);\n         * // Prints: ecmascript\n         * myMIME.subtype = 'javascript';\n         * console.log(myMIME.subtype);\n         * // Prints: javascript\n         * console.log(String(myMIME));\n         * // Prints: text/javascript\n         * ```\n         */\n        subtype: string;\n        /**\n         * Gets the essence of the MIME. This property is read only.\n         * Use `mime.type` or `mime.subtype` to alter the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/javascript;key=value');\n         * console.log(myMIME.essence);\n         * // Prints: text/javascript\n         * myMIME.type = 'application';\n         * console.log(myMIME.essence);\n         * // Prints: application/javascript\n         * console.log(String(myMIME));\n         * // Prints: application/javascript;key=value\n         * ```\n         */\n        readonly essence: string;\n        /**\n         * Gets the `MIMEParams` object representing the\n         * parameters of the MIME. This property is read-only. See `MIMEParams` documentation for details.\n         */\n        readonly params: MIMEParams;\n        /**\n         * The `toString()` method on the `MIMEType` object returns the serialized MIME.\n         *\n         * Because of the need for standard compliance, this method does not allow users\n         * to customize the serialization process of the MIME.\n         */\n        toString(): string;\n    }\n    /**\n     * The `MIMEParams` API provides read and write access to the parameters of a`MIMEType`.\n     * @since v19.1.0, v18.13.0\n     */\n    export class MIMEParams {\n        /**\n         * Remove all name-value pairs whose name is `name`.\n         */\n        delete(name: string): void;\n        /**\n         * Returns an iterator over each of the name-value pairs in the parameters.\n         * Each item of the iterator is a JavaScript `Array`. The first item of the array\n         * is the `name`, the second item of the array is the `value`.\n         */\n        entries(): IterableIterator<[name: string, value: string]>;\n        /**\n         * Returns the value of the first name-value pair whose name is `name`. If there\n         * are no such pairs, `null` is returned.\n         * @return or `null` if there is no name-value pair with the given `name`.\n         */\n        get(name: string): string | null;\n        /**\n         * Returns `true` if there is at least one name-value pair whose name is `name`.\n         */\n        has(name: string): boolean;\n        /**\n         * Returns an iterator over the names of each name-value pair.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const { params } = new MIMEType('text/plain;foo=0;bar=1');\n         * for (const name of params.keys()) {\n         *   console.log(name);\n         * }\n         * // Prints:\n         * //   foo\n         * //   bar\n         * ```\n         */\n        keys(): IterableIterator<string>;\n        /**\n         * Sets the value in the `MIMEParams` object associated with `name` to`value`. If there are any pre-existing name-value pairs whose names are `name`,\n         * set the first such pair's value to `value`.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const { params } = new MIMEType('text/plain;foo=0;bar=1');\n         * params.set('foo', 'def');\n         * params.set('baz', 'xyz');\n         * console.log(params.toString());\n         * // Prints: foo=def;bar=1;baz=xyz\n         * ```\n         */\n        set(name: string, value: string): void;\n        /**\n         * Returns an iterator over the values of each name-value pair.\n         */\n        values(): IterableIterator<string>;\n        /**\n         * Returns an iterator over each of the name-value pairs in the parameters.\n         */\n        [Symbol.iterator]: typeof MIMEParams.prototype.entries;\n    }\n}\ndeclare module \"util/types\" {\n    import { KeyObject, webcrypto } from \"node:crypto\";\n    /**\n     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or\n     * [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.\n     *\n     * See also `util.types.isArrayBuffer()` and `util.types.isSharedArrayBuffer()`.\n     *\n     * ```js\n     * util.types.isAnyArrayBuffer(new ArrayBuffer());  // Returns true\n     * util.types.isAnyArrayBuffer(new SharedArrayBuffer());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isAnyArrayBuffer(object: unknown): object is ArrayBufferLike;\n    /**\n     * Returns `true` if the value is an `arguments` object.\n     *\n     * ```js\n     * function foo() {\n     *   util.types.isArgumentsObject(arguments);  // Returns true\n     * }\n     * ```\n     * @since v10.0.0\n     */\n    function isArgumentsObject(object: unknown): object is IArguments;\n    /**\n     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instance.\n     * This does _not_ include [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instances. Usually, it is\n     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.\n     *\n     * ```js\n     * util.types.isArrayBuffer(new ArrayBuffer());  // Returns true\n     * util.types.isArrayBuffer(new SharedArrayBuffer());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isArrayBuffer(object: unknown): object is ArrayBuffer;\n    /**\n     * Returns `true` if the value is an instance of one of the [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) views, such as typed\n     * array objects or [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView). Equivalent to\n     * [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     *\n     * ```js\n     * util.types.isArrayBufferView(new Int8Array());  // true\n     * util.types.isArrayBufferView(Buffer.from('hello world')); // true\n     * util.types.isArrayBufferView(new DataView(new ArrayBuffer(16)));  // true\n     * util.types.isArrayBufferView(new ArrayBuffer());  // false\n     * ```\n     * @since v10.0.0\n     */\n    function isArrayBufferView(object: unknown): object is NodeJS.ArrayBufferView;\n    /**\n     * Returns `true` if the value is an [async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * util.types.isAsyncFunction(function foo() {});  // Returns false\n     * util.types.isAsyncFunction(async function foo() {});  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isAsyncFunction(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a `BigInt64Array` instance.\n     *\n     * ```js\n     * util.types.isBigInt64Array(new BigInt64Array());   // Returns true\n     * util.types.isBigInt64Array(new BigUint64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isBigInt64Array(value: unknown): value is BigInt64Array;\n    /**\n     * Returns `true` if the value is a `BigUint64Array` instance.\n     *\n     * ```js\n     * util.types.isBigUint64Array(new BigInt64Array());   // Returns false\n     * util.types.isBigUint64Array(new BigUint64Array());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isBigUint64Array(value: unknown): value is BigUint64Array;\n    /**\n     * Returns `true` if the value is a boolean object, e.g. created\n     * by `new Boolean()`.\n     *\n     * ```js\n     * util.types.isBooleanObject(false);  // Returns false\n     * util.types.isBooleanObject(true);   // Returns false\n     * util.types.isBooleanObject(new Boolean(false)); // Returns true\n     * util.types.isBooleanObject(new Boolean(true));  // Returns true\n     * util.types.isBooleanObject(Boolean(false)); // Returns false\n     * util.types.isBooleanObject(Boolean(true));  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isBooleanObject(object: unknown): object is Boolean;\n    /**\n     * Returns `true` if the value is any boxed primitive object, e.g. created\n     * by `new Boolean()`, `new String()` or `Object(Symbol())`.\n     *\n     * For example:\n     *\n     * ```js\n     * util.types.isBoxedPrimitive(false); // Returns false\n     * util.types.isBoxedPrimitive(new Boolean(false)); // Returns true\n     * util.types.isBoxedPrimitive(Symbol('foo')); // Returns false\n     * util.types.isBoxedPrimitive(Object(Symbol('foo'))); // Returns true\n     * util.types.isBoxedPrimitive(Object(BigInt(5))); // Returns true\n     * ```\n     * @since v10.11.0\n     */\n    function isBoxedPrimitive(object: unknown): object is String | Number | BigInt | Boolean | Symbol;\n    /**\n     * Returns `true` if the value is a built-in [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) instance.\n     *\n     * ```js\n     * const ab = new ArrayBuffer(20);\n     * util.types.isDataView(new DataView(ab));  // Returns true\n     * util.types.isDataView(new Float64Array());  // Returns false\n     * ```\n     *\n     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     * @since v10.0.0\n     */\n    function isDataView(object: unknown): object is DataView;\n    /**\n     * Returns `true` if the value is a built-in [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     *\n     * ```js\n     * util.types.isDate(new Date());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isDate(object: unknown): object is Date;\n    /**\n     * Returns `true` if the value is a native `External` value.\n     *\n     * A native `External` value is a special type of object that contains a\n     * raw C++ pointer (`void*`) for access from native code, and has no other\n     * properties. Such objects are created either by Node.js internals or native\n     * addons. In JavaScript, they are [frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) objects with a`null` prototype.\n     *\n     * ```c\n     * #include <js_native_api.h>\n     * #include <stdlib.h>\n     * napi_value result;\n     * static napi_value MyNapi(napi_env env, napi_callback_info info) {\n     *   int* raw = (int*) malloc(1024);\n     *   napi_status status = napi_create_external(env, (void*) raw, NULL, NULL, &#x26;result);\n     *   if (status != napi_ok) {\n     *     napi_throw_error(env, NULL, \"napi_create_external failed\");\n     *     return NULL;\n     *   }\n     *   return result;\n     * }\n     * ...\n     * DECLARE_NAPI_PROPERTY(\"myNapi\", MyNapi)\n     * ...\n     * ```\n     *\n     * ```js\n     * const native = require('napi_addon.node');\n     * const data = native.myNapi();\n     * util.types.isExternal(data); // returns true\n     * util.types.isExternal(0); // returns false\n     * util.types.isExternal(new String('foo')); // returns false\n     * ```\n     *\n     * For further information on `napi_create_external`, refer to `napi_create_external()`.\n     * @since v10.0.0\n     */\n    function isExternal(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a built-in [`Float32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array) instance.\n     *\n     * ```js\n     * util.types.isFloat32Array(new ArrayBuffer());  // Returns false\n     * util.types.isFloat32Array(new Float32Array());  // Returns true\n     * util.types.isFloat32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isFloat32Array(object: unknown): object is Float32Array;\n    /**\n     * Returns `true` if the value is a built-in [`Float64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array) instance.\n     *\n     * ```js\n     * util.types.isFloat64Array(new ArrayBuffer());  // Returns false\n     * util.types.isFloat64Array(new Uint8Array());  // Returns false\n     * util.types.isFloat64Array(new Float64Array());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isFloat64Array(object: unknown): object is Float64Array;\n    /**\n     * Returns `true` if the value is a generator function.\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * util.types.isGeneratorFunction(function foo() {});  // Returns false\n     * util.types.isGeneratorFunction(function* foo() {});  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isGeneratorFunction(object: unknown): object is GeneratorFunction;\n    /**\n     * Returns `true` if the value is a generator object as returned from a\n     * built-in generator function.\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * function* foo() {}\n     * const generator = foo();\n     * util.types.isGeneratorObject(generator);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isGeneratorObject(object: unknown): object is Generator;\n    /**\n     * Returns `true` if the value is a built-in [`Int8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) instance.\n     *\n     * ```js\n     * util.types.isInt8Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt8Array(new Int8Array());  // Returns true\n     * util.types.isInt8Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt8Array(object: unknown): object is Int8Array;\n    /**\n     * Returns `true` if the value is a built-in [`Int16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array) instance.\n     *\n     * ```js\n     * util.types.isInt16Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt16Array(new Int16Array());  // Returns true\n     * util.types.isInt16Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt16Array(object: unknown): object is Int16Array;\n    /**\n     * Returns `true` if the value is a built-in [`Int32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array) instance.\n     *\n     * ```js\n     * util.types.isInt32Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt32Array(new Int32Array());  // Returns true\n     * util.types.isInt32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt32Array(object: unknown): object is Int32Array;\n    /**\n     * Returns `true` if the value is a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.\n     *\n     * ```js\n     * util.types.isMap(new Map());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isMap<T>(\n        object: T | {},\n    ): object is T extends ReadonlyMap<any, any> ? (unknown extends T ? never : ReadonlyMap<any, any>)\n        : Map<unknown, unknown>;\n    /**\n     * Returns `true` if the value is an iterator returned for a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.\n     *\n     * ```js\n     * const map = new Map();\n     * util.types.isMapIterator(map.keys());  // Returns true\n     * util.types.isMapIterator(map.values());  // Returns true\n     * util.types.isMapIterator(map.entries());  // Returns true\n     * util.types.isMapIterator(map[Symbol.iterator]());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isMapIterator(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is an instance of a [Module Namespace Object](https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects).\n     *\n     * ```js\n     * import * as ns from './a.js';\n     *\n     * util.types.isModuleNamespaceObject(ns);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isModuleNamespaceObject(value: unknown): boolean;\n    /**\n     * Returns `true` if the value was returned by the constructor of a [built-in `Error` type](https://tc39.es/ecma262/#sec-error-objects).\n     *\n     * ```js\n     * console.log(util.types.isNativeError(new Error()));  // true\n     * console.log(util.types.isNativeError(new TypeError()));  // true\n     * console.log(util.types.isNativeError(new RangeError()));  // true\n     * ```\n     *\n     * Subclasses of the native error types are also native errors:\n     *\n     * ```js\n     * class MyError extends Error {}\n     * console.log(util.types.isNativeError(new MyError()));  // true\n     * ```\n     *\n     * A value being `instanceof` a native error class is not equivalent to `isNativeError()`returning `true` for that value. `isNativeError()` returns `true` for errors\n     * which come from a different [realm](https://tc39.es/ecma262/#realm) while `instanceof Error` returns `false`for these errors:\n     *\n     * ```js\n     * const vm = require('node:vm');\n     * const context = vm.createContext({});\n     * const myError = vm.runInContext('new Error()', context);\n     * console.log(util.types.isNativeError(myError)); // true\n     * console.log(myError instanceof Error); // false\n     * ```\n     *\n     * Conversely, `isNativeError()` returns `false` for all objects which were not\n     * returned by the constructor of a native error. That includes values\n     * which are `instanceof` native errors:\n     *\n     * ```js\n     * const myError = { __proto__: Error.prototype };\n     * console.log(util.types.isNativeError(myError)); // false\n     * console.log(myError instanceof Error); // true\n     * ```\n     * @since v10.0.0\n     */\n    function isNativeError(object: unknown): object is Error;\n    /**\n     * Returns `true` if the value is a number object, e.g. created\n     * by `new Number()`.\n     *\n     * ```js\n     * util.types.isNumberObject(0);  // Returns false\n     * util.types.isNumberObject(new Number(0));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isNumberObject(object: unknown): object is Number;\n    /**\n     * Returns `true` if the value is a built-in [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n     *\n     * ```js\n     * util.types.isPromise(Promise.resolve(42));  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isPromise(object: unknown): object is Promise<unknown>;\n    /**\n     * Returns `true` if the value is a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) instance.\n     *\n     * ```js\n     * const target = {};\n     * const proxy = new Proxy(target, {});\n     * util.types.isProxy(target);  // Returns false\n     * util.types.isProxy(proxy);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isProxy(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a regular expression object.\n     *\n     * ```js\n     * util.types.isRegExp(/abc/);  // Returns true\n     * util.types.isRegExp(new RegExp('abc'));  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isRegExp(object: unknown): object is RegExp;\n    /**\n     * Returns `true` if the value is a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.\n     *\n     * ```js\n     * util.types.isSet(new Set());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSet<T>(\n        object: T | {},\n    ): object is T extends ReadonlySet<any> ? (unknown extends T ? never : ReadonlySet<any>) : Set<unknown>;\n    /**\n     * Returns `true` if the value is an iterator returned for a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.\n     *\n     * ```js\n     * const set = new Set();\n     * util.types.isSetIterator(set.keys());  // Returns true\n     * util.types.isSetIterator(set.values());  // Returns true\n     * util.types.isSetIterator(set.entries());  // Returns true\n     * util.types.isSetIterator(set[Symbol.iterator]());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSetIterator(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a built-in [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.\n     * This does _not_ include [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instances. Usually, it is\n     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.\n     *\n     * ```js\n     * util.types.isSharedArrayBuffer(new ArrayBuffer());  // Returns false\n     * util.types.isSharedArrayBuffer(new SharedArrayBuffer());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSharedArrayBuffer(object: unknown): object is SharedArrayBuffer;\n    /**\n     * Returns `true` if the value is a string object, e.g. created\n     * by `new String()`.\n     *\n     * ```js\n     * util.types.isStringObject('foo');  // Returns false\n     * util.types.isStringObject(new String('foo'));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isStringObject(object: unknown): object is String;\n    /**\n     * Returns `true` if the value is a symbol object, created\n     * by calling `Object()` on a `Symbol` primitive.\n     *\n     * ```js\n     * const symbol = Symbol('foo');\n     * util.types.isSymbolObject(symbol);  // Returns false\n     * util.types.isSymbolObject(Object(symbol));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSymbolObject(object: unknown): object is Symbol;\n    /**\n     * Returns `true` if the value is a built-in [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) instance.\n     *\n     * ```js\n     * util.types.isTypedArray(new ArrayBuffer());  // Returns false\n     * util.types.isTypedArray(new Uint8Array());  // Returns true\n     * util.types.isTypedArray(new Float64Array());  // Returns true\n     * ```\n     *\n     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     * @since v10.0.0\n     */\n    function isTypedArray(object: unknown): object is NodeJS.TypedArray;\n    /**\n     * Returns `true` if the value is a built-in [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instance.\n     *\n     * ```js\n     * util.types.isUint8Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint8Array(new Uint8Array());  // Returns true\n     * util.types.isUint8Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint8Array(object: unknown): object is Uint8Array;\n    /**\n     * Returns `true` if the value is a built-in [`Uint8ClampedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) instance.\n     *\n     * ```js\n     * util.types.isUint8ClampedArray(new ArrayBuffer());  // Returns false\n     * util.types.isUint8ClampedArray(new Uint8ClampedArray());  // Returns true\n     * util.types.isUint8ClampedArray(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint8ClampedArray(object: unknown): object is Uint8ClampedArray;\n    /**\n     * Returns `true` if the value is a built-in [`Uint16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array) instance.\n     *\n     * ```js\n     * util.types.isUint16Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint16Array(new Uint16Array());  // Returns true\n     * util.types.isUint16Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint16Array(object: unknown): object is Uint16Array;\n    /**\n     * Returns `true` if the value is a built-in [`Uint32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array) instance.\n     *\n     * ```js\n     * util.types.isUint32Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint32Array(new Uint32Array());  // Returns true\n     * util.types.isUint32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint32Array(object: unknown): object is Uint32Array;\n    /**\n     * Returns `true` if the value is a built-in [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) instance.\n     *\n     * ```js\n     * util.types.isWeakMap(new WeakMap());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isWeakMap(object: unknown): object is WeakMap<object, unknown>;\n    /**\n     * Returns `true` if the value is a built-in [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) instance.\n     *\n     * ```js\n     * util.types.isWeakSet(new WeakSet());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isWeakSet(object: unknown): object is WeakSet<object>;\n    /**\n     * Returns `true` if `value` is a `KeyObject`, `false` otherwise.\n     * @since v16.2.0\n     */\n    function isKeyObject(object: unknown): object is KeyObject;\n    /**\n     * Returns `true` if `value` is a `CryptoKey`, `false` otherwise.\n     * @since v16.2.0\n     */\n    function isCryptoKey(object: unknown): object is webcrypto.CryptoKey;\n}\ndeclare module \"node:util\" {\n    export * from \"util\";\n}\ndeclare module \"node:util/types\" {\n    export * from \"util/types\";\n}\n"}}]);